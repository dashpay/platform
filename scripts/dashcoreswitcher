#!/usr/bin/env python3
import argparse
import os
import re
import sys


DESC = """
dashcoreswitcher: switch all Cargo.toml dashcore deps between local path and git (rev/branch).

Usage:
  dashcoreswitcher local
  dashcoreswitcher rev <rev>
  dashcoreswitcher branch <branch>

This edits inline-table dependencies like:
  dashcore = { path = "../../../rust-dashcore/dash", features = [ ... ], default-features = false }
  dashcore = { git = "https://github.com/dashpay/rust-dashcore", rev = "<rev>", features = [ ... ], default-features = false }

It preserves existing features and default-features and only switches path/git+rev/branch keys.
Commented lines are not modified.
"""


GIT_URL = "https://github.com/dashpay/rust-dashcore"
LOCAL_PATH = "../../../rust-dashcore/dash"


def find_cargo_tomls(root: str):
    for dirpath, dirnames, filenames in os.walk(root):
        # skip typical build dirs
        skip = any(part in dirpath for part in ("/target/", "/.git/", "/node_modules/", "/.build/"))
        if skip:
            continue
        if "Cargo.toml" in filenames:
            yield os.path.join(dirpath, "Cargo.toml")


def iter_inline_dashcore_blocks(text: str):
    # Regex across lines to capture inline table from 'dashcore = {' to the first closing '}'
    pattern = re.compile(r"(^|\n)(?P<indent>\s*)dashcore\s*=\s*\{[^}]*\}", re.S)
    for m in pattern.finditer(text):
        block_start = m.start() + (0 if text[m.start()] != '\n' else 1)
        block_end = m.end()
        # Skip commented lines
        line_start = text.rfind('\n', 0, block_start) + 1
        line_end = text.find('\n', line_start)
        if line_end == -1:
            line_end = len(text)
        if text[line_start:line_end].lstrip().startswith('#'):
            continue
        yield (block_start, block_end)


def parse_inline_table(s: str):
    # input like: dashcore = { key = value, features = [ ... ] }
    # we only parse inside braces
    brace_open = s.find('{')
    brace_close = s.rfind('}')
    inner = s[brace_open + 1:brace_close]
    # split commas at top level (not inside [ ... ])
    parts = []
    buf = []
    depth = 0
    for ch in inner:
        if ch == '[':
            depth += 1
        elif ch == ']':
            depth -= 1
        if ch == ',' and depth == 0:
            parts.append(''.join(buf).strip())
            buf = []
        else:
            buf.append(ch)
    if buf:
        parts.append(''.join(buf).strip())
    kv = []
    for p in parts:
        if not p:
            continue
        if '=' not in p:
            continue
        k, v = p.split('=', 1)
        kv.append((k.strip(), v.strip()))
    return kv


def serialize_inline_table(prefix: str, pairs):
    # prefix like "dashcore = "
    body = ', '.join(f"{k} = {v}" for k, v in pairs)
    return f"{prefix}{{ {body} }}"


def switch_dep(block_text: str, mode: str, value: str | None):
    # keep the spacing before the '{'
    prefix = block_text[:block_text.find('{')]
    pairs = parse_inline_table(block_text)
    # Turn into dict but preserve order (features often last)
    keys = [k for k, _ in pairs]
    d = {k: v for k, v in pairs}

    # Remove conflicting keys
    for k in ("git", "rev", "branch", "path"):
        if k in d:
            del d[k]
            if k in keys:
                keys.remove(k)

    if mode == 'local':
        # Insert path first
        keys.insert(0, 'path')
        d['path'] = f'"{LOCAL_PATH}"'
    elif mode == 'rev':
        keys.insert(0, 'git')
        d['git'] = f'"{GIT_URL}"'
        keys.insert(1, 'rev')
        d['rev'] = f'"{value}"'
    elif mode == 'branch':
        keys.insert(0, 'git')
        d['git'] = f'"{GIT_URL}"'
        keys.insert(1, 'branch')
        d['branch'] = f'"{value}"'
    else:
        raise RuntimeError(f"Unknown mode {mode}")

    # Rebuild pairs keeping existing order for other keys
    # Ensure features/default-features remain if they existed
    ordered_pairs = []
    for k in keys:
        if k in d:
            ordered_pairs.append((k, d[k]))
    # Append any remaining keys (if any)
    for k, v in d.items():
        if k not in keys:
            ordered_pairs.append((k, v))

    return serialize_inline_table(prefix, ordered_pairs)


def process_file(path: str, mode: str, value: str | None) -> bool:
    with open(path, 'r', encoding='utf-8') as f:
        text = f.read()

    # Collect blocks first because we will mutate the text
    blocks = list(iter_inline_dashcore_blocks(text))
    if not blocks:
        return False

    # Apply from end to start to keep indices valid
    changed = False
    for start, end in reversed(blocks):
        block_text = text[start:end]
        new_block = switch_dep(block_text, mode, value)
        if new_block != block_text:
            text = text[:start] + new_block + text[end:]
            changed = True

    if changed:
        with open(path, 'w', encoding='utf-8', newline='\n') as f:
            f.write(text)
    return changed


def main():
    parser = argparse.ArgumentParser(description=DESC)
    sub = parser.add_subparsers(dest='cmd', required=True)
    sub.add_parser('local')
    p_rev = sub.add_parser('rev')
    p_rev.add_argument('rev')
    p_branch = sub.add_parser('branch')
    p_branch.add_argument('branch')
    args = parser.parse_args()

    mode = args.cmd
    val = None
    if mode == 'rev':
        val = args.rev
    elif mode == 'branch':
        val = args.branch

    repo_root = os.getcwd()
    edited = []
    for cargo in find_cargo_tomls(repo_root):
        if process_file(cargo, mode, val):
            edited.append(cargo)

    if edited:
        print(f"Updated dashcore dependency in {len(edited)} file(s):")
        for p in edited:
            print(f" - {os.path.relpath(p, repo_root)}")
    else:
        print("No Cargo.toml files with inline dashcore dependency found to update.")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
