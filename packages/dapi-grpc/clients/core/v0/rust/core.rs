// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `core.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusRequest)
pub struct GetStatusRequest {
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStatusRequest {
    fn default() -> &'a GetStatusRequest {
        <GetStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusRequest {
    pub fn new() -> GetStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStatusRequest>(
            "GetStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStatusRequest {
    const NAME: &'static str = "GetStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStatusRequest {
        GetStatusRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStatusRequest {
        static instance: GetStatusRequest = GetStatusRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse)
pub struct GetStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.version)
    pub version: ::protobuf::MessageField<get_status_response::Version>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.time)
    pub time: ::protobuf::MessageField<get_status_response::Time>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.status)
    pub status: ::protobuf::EnumOrUnknown<get_status_response::Status>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.sync_progress)
    pub sync_progress: f64,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.chain)
    pub chain: ::protobuf::MessageField<get_status_response::Chain>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.masternode)
    pub masternode: ::protobuf::MessageField<get_status_response::Masternode>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.network)
    pub network: ::protobuf::MessageField<get_status_response::Network>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStatusResponse {
    fn default() -> &'a GetStatusResponse {
        <GetStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusResponse {
    pub fn new() -> GetStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_status_response::Version>(
            "version",
            |m: &GetStatusResponse| { &m.version },
            |m: &mut GetStatusResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_status_response::Time>(
            "time",
            |m: &GetStatusResponse| { &m.time },
            |m: &mut GetStatusResponse| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &GetStatusResponse| { &m.status },
            |m: &mut GetStatusResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sync_progress",
            |m: &GetStatusResponse| { &m.sync_progress },
            |m: &mut GetStatusResponse| { &mut m.sync_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_status_response::Chain>(
            "chain",
            |m: &GetStatusResponse| { &m.chain },
            |m: &mut GetStatusResponse| { &mut m.chain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_status_response::Masternode>(
            "masternode",
            |m: &GetStatusResponse| { &m.masternode },
            |m: &mut GetStatusResponse| { &mut m.masternode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_status_response::Network>(
            "network",
            |m: &GetStatusResponse| { &m.network },
            |m: &mut GetStatusResponse| { &mut m.network },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStatusResponse>(
            "GetStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStatusResponse {
    const NAME: &'static str = "GetStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                24 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                33 => {
                    self.sync_progress = is.read_double()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chain)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.masternode)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.network)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(get_status_response::Status::NOT_STARTED) {
            my_size += ::protobuf::rt::int32_size(3, self.status.value());
        }
        if self.sync_progress != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.masternode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(get_status_response::Status::NOT_STARTED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.sync_progress != 0. {
            os.write_double(4, self.sync_progress)?;
        }
        if let Some(v) = self.chain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.masternode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.network.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStatusResponse {
        GetStatusResponse::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.time.clear();
        self.status = ::protobuf::EnumOrUnknown::new(get_status_response::Status::NOT_STARTED);
        self.sync_progress = 0.;
        self.chain.clear();
        self.masternode.clear();
        self.network.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStatusResponse {
        static instance: GetStatusResponse = GetStatusResponse {
            version: ::protobuf::MessageField::none(),
            time: ::protobuf::MessageField::none(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            sync_progress: 0.,
            chain: ::protobuf::MessageField::none(),
            masternode: ::protobuf::MessageField::none(),
            network: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetStatusResponse`
pub mod get_status_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.Version)
    pub struct Version {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Version.protocol)
        pub protocol: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Version.software)
        pub software: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Version.agent)
        pub agent: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.Version.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Version {
        fn default() -> &'a Version {
            <Version as ::protobuf::Message>::default_instance()
        }
    }

    impl Version {
        pub fn new() -> Version {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "protocol",
                |m: &Version| { &m.protocol },
                |m: &mut Version| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "software",
                |m: &Version| { &m.software },
                |m: &mut Version| { &mut m.software },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "agent",
                |m: &Version| { &m.agent },
                |m: &mut Version| { &mut m.agent },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
                "GetStatusResponse.Version",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Version {
        const NAME: &'static str = "Version";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.protocol = is.read_uint32()?;
                    },
                    16 => {
                        self.software = is.read_uint32()?;
                    },
                    26 => {
                        self.agent = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.protocol != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.protocol);
            }
            if self.software != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.software);
            }
            if !self.agent.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.agent);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.protocol != 0 {
                os.write_uint32(1, self.protocol)?;
            }
            if self.software != 0 {
                os.write_uint32(2, self.software)?;
            }
            if !self.agent.is_empty() {
                os.write_string(3, &self.agent)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Version {
            Version::new()
        }

        fn clear(&mut self) {
            self.protocol = 0;
            self.software = 0;
            self.agent.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Version {
            static instance: Version = Version {
                protocol: 0,
                software: 0,
                agent: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Version {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.Version").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Version {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Version {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.Time)
    pub struct Time {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Time.now)
        pub now: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Time.offset)
        pub offset: i32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Time.median)
        pub median: u32,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.Time.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Time {
        fn default() -> &'a Time {
            <Time as ::protobuf::Message>::default_instance()
        }
    }

    impl Time {
        pub fn new() -> Time {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "now",
                |m: &Time| { &m.now },
                |m: &mut Time| { &mut m.now },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "offset",
                |m: &Time| { &m.offset },
                |m: &mut Time| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "median",
                |m: &Time| { &m.median },
                |m: &mut Time| { &mut m.median },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Time>(
                "GetStatusResponse.Time",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Time {
        const NAME: &'static str = "Time";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.now = is.read_uint32()?;
                    },
                    16 => {
                        self.offset = is.read_int32()?;
                    },
                    24 => {
                        self.median = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.now != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.now);
            }
            if self.offset != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.offset);
            }
            if self.median != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.median);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.now != 0 {
                os.write_uint32(1, self.now)?;
            }
            if self.offset != 0 {
                os.write_int32(2, self.offset)?;
            }
            if self.median != 0 {
                os.write_uint32(3, self.median)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Time {
            Time::new()
        }

        fn clear(&mut self) {
            self.now = 0;
            self.offset = 0;
            self.median = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Time {
            static instance: Time = Time {
                now: 0,
                offset: 0,
                median: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Time {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.Time").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Time {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Time {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.Chain)
    pub struct Chain {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.headers_count)
        pub headers_count: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.blocks_count)
        pub blocks_count: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.best_block_hash)
        pub best_block_hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.difficulty)
        pub difficulty: f64,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.chain_work)
        pub chain_work: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.is_synced)
        pub is_synced: bool,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.sync_progress)
        pub sync_progress: f64,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.Chain.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Chain {
        fn default() -> &'a Chain {
            <Chain as ::protobuf::Message>::default_instance()
        }
    }

    impl Chain {
        pub fn new() -> Chain {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Chain| { &m.name },
                |m: &mut Chain| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "headers_count",
                |m: &Chain| { &m.headers_count },
                |m: &mut Chain| { &mut m.headers_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "blocks_count",
                |m: &Chain| { &m.blocks_count },
                |m: &mut Chain| { &mut m.blocks_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "best_block_hash",
                |m: &Chain| { &m.best_block_hash },
                |m: &mut Chain| { &mut m.best_block_hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "difficulty",
                |m: &Chain| { &m.difficulty },
                |m: &mut Chain| { &mut m.difficulty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "chain_work",
                |m: &Chain| { &m.chain_work },
                |m: &mut Chain| { &mut m.chain_work },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_synced",
                |m: &Chain| { &m.is_synced },
                |m: &mut Chain| { &mut m.is_synced },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sync_progress",
                |m: &Chain| { &m.sync_progress },
                |m: &mut Chain| { &mut m.sync_progress },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Chain>(
                "GetStatusResponse.Chain",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Chain {
        const NAME: &'static str = "Chain";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    16 => {
                        self.headers_count = is.read_uint32()?;
                    },
                    24 => {
                        self.blocks_count = is.read_uint32()?;
                    },
                    34 => {
                        self.best_block_hash = is.read_bytes()?;
                    },
                    41 => {
                        self.difficulty = is.read_double()?;
                    },
                    50 => {
                        self.chain_work = is.read_bytes()?;
                    },
                    56 => {
                        self.is_synced = is.read_bool()?;
                    },
                    65 => {
                        self.sync_progress = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if self.headers_count != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.headers_count);
            }
            if self.blocks_count != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.blocks_count);
            }
            if !self.best_block_hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.best_block_hash);
            }
            if self.difficulty != 0. {
                my_size += 1 + 8;
            }
            if !self.chain_work.is_empty() {
                my_size += ::protobuf::rt::bytes_size(6, &self.chain_work);
            }
            if self.is_synced != false {
                my_size += 1 + 1;
            }
            if self.sync_progress != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if self.headers_count != 0 {
                os.write_uint32(2, self.headers_count)?;
            }
            if self.blocks_count != 0 {
                os.write_uint32(3, self.blocks_count)?;
            }
            if !self.best_block_hash.is_empty() {
                os.write_bytes(4, &self.best_block_hash)?;
            }
            if self.difficulty != 0. {
                os.write_double(5, self.difficulty)?;
            }
            if !self.chain_work.is_empty() {
                os.write_bytes(6, &self.chain_work)?;
            }
            if self.is_synced != false {
                os.write_bool(7, self.is_synced)?;
            }
            if self.sync_progress != 0. {
                os.write_double(8, self.sync_progress)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Chain {
            Chain::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.headers_count = 0;
            self.blocks_count = 0;
            self.best_block_hash.clear();
            self.difficulty = 0.;
            self.chain_work.clear();
            self.is_synced = false;
            self.sync_progress = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Chain {
            static instance: Chain = Chain {
                name: ::std::string::String::new(),
                headers_count: 0,
                blocks_count: 0,
                best_block_hash: ::std::vec::Vec::new(),
                difficulty: 0.,
                chain_work: ::std::vec::Vec::new(),
                is_synced: false,
                sync_progress: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Chain {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.Chain").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Chain {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.Masternode)
    pub struct Masternode {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.status)
        pub status: ::protobuf::EnumOrUnknown<masternode::Status>,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.pro_tx_hash)
        pub pro_tx_hash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.pose_penalty)
        pub pose_penalty: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.is_synced)
        pub is_synced: bool,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.sync_progress)
        pub sync_progress: f64,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Masternode {
        fn default() -> &'a Masternode {
            <Masternode as ::protobuf::Message>::default_instance()
        }
    }

    impl Masternode {
        pub fn new() -> Masternode {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "status",
                |m: &Masternode| { &m.status },
                |m: &mut Masternode| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "pro_tx_hash",
                |m: &Masternode| { &m.pro_tx_hash },
                |m: &mut Masternode| { &mut m.pro_tx_hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "pose_penalty",
                |m: &Masternode| { &m.pose_penalty },
                |m: &mut Masternode| { &mut m.pose_penalty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_synced",
                |m: &Masternode| { &m.is_synced },
                |m: &mut Masternode| { &mut m.is_synced },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sync_progress",
                |m: &Masternode| { &m.sync_progress },
                |m: &mut Masternode| { &mut m.sync_progress },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Masternode>(
                "GetStatusResponse.Masternode",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Masternode {
        const NAME: &'static str = "Masternode";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.status = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        self.pro_tx_hash = is.read_bytes()?;
                    },
                    24 => {
                        self.pose_penalty = is.read_uint32()?;
                    },
                    32 => {
                        self.is_synced = is.read_bool()?;
                    },
                    41 => {
                        self.sync_progress = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.status != ::protobuf::EnumOrUnknown::new(masternode::Status::UNKNOWN) {
                my_size += ::protobuf::rt::int32_size(1, self.status.value());
            }
            if !self.pro_tx_hash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.pro_tx_hash);
            }
            if self.pose_penalty != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.pose_penalty);
            }
            if self.is_synced != false {
                my_size += 1 + 1;
            }
            if self.sync_progress != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.status != ::protobuf::EnumOrUnknown::new(masternode::Status::UNKNOWN) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.status))?;
            }
            if !self.pro_tx_hash.is_empty() {
                os.write_bytes(2, &self.pro_tx_hash)?;
            }
            if self.pose_penalty != 0 {
                os.write_uint32(3, self.pose_penalty)?;
            }
            if self.is_synced != false {
                os.write_bool(4, self.is_synced)?;
            }
            if self.sync_progress != 0. {
                os.write_double(5, self.sync_progress)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Masternode {
            Masternode::new()
        }

        fn clear(&mut self) {
            self.status = ::protobuf::EnumOrUnknown::new(masternode::Status::UNKNOWN);
            self.pro_tx_hash.clear();
            self.pose_penalty = 0;
            self.is_synced = false;
            self.sync_progress = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Masternode {
            static instance: Masternode = Masternode {
                status: ::protobuf::EnumOrUnknown::from_i32(0),
                pro_tx_hash: ::std::vec::Vec::new(),
                pose_penalty: 0,
                is_synced: false,
                sync_progress: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Masternode {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.Masternode").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Masternode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Masternode {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Masternode`
    pub mod masternode {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status)
        pub enum Status {
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.UNKNOWN)
            UNKNOWN = 0,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.WAITING_FOR_PROTX)
            WAITING_FOR_PROTX = 1,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.POSE_BANNED)
            POSE_BANNED = 2,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.REMOVED)
            REMOVED = 3,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.OPERATOR_KEY_CHANGED)
            OPERATOR_KEY_CHANGED = 4,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.PROTX_IP_CHANGED)
            PROTX_IP_CHANGED = 5,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.READY)
            READY = 6,
            // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Masternode.Status.ERROR)
            ERROR = 7,
        }

        impl ::protobuf::Enum for Status {
            const NAME: &'static str = "Status";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Status> {
                match value {
                    0 => ::std::option::Option::Some(Status::UNKNOWN),
                    1 => ::std::option::Option::Some(Status::WAITING_FOR_PROTX),
                    2 => ::std::option::Option::Some(Status::POSE_BANNED),
                    3 => ::std::option::Option::Some(Status::REMOVED),
                    4 => ::std::option::Option::Some(Status::OPERATOR_KEY_CHANGED),
                    5 => ::std::option::Option::Some(Status::PROTX_IP_CHANGED),
                    6 => ::std::option::Option::Some(Status::READY),
                    7 => ::std::option::Option::Some(Status::ERROR),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Status] = &[
                Status::UNKNOWN,
                Status::WAITING_FOR_PROTX,
                Status::POSE_BANNED,
                Status::REMOVED,
                Status::OPERATOR_KEY_CHANGED,
                Status::PROTX_IP_CHANGED,
                Status::READY,
                Status::ERROR,
            ];
        }

        impl ::protobuf::EnumFull for Status {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("GetStatusResponse.Masternode.Status").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Status {
            fn default() -> Self {
                Status::UNKNOWN
            }
        }

        impl Status {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetStatusResponse.Masternode.Status")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.NetworkFee)
    pub struct NetworkFee {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.NetworkFee.relay)
        pub relay: f64,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.NetworkFee.incremental)
        pub incremental: f64,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.NetworkFee.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NetworkFee {
        fn default() -> &'a NetworkFee {
            <NetworkFee as ::protobuf::Message>::default_instance()
        }
    }

    impl NetworkFee {
        pub fn new() -> NetworkFee {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "relay",
                |m: &NetworkFee| { &m.relay },
                |m: &mut NetworkFee| { &mut m.relay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "incremental",
                |m: &NetworkFee| { &m.incremental },
                |m: &mut NetworkFee| { &mut m.incremental },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NetworkFee>(
                "GetStatusResponse.NetworkFee",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NetworkFee {
        const NAME: &'static str = "NetworkFee";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.relay = is.read_double()?;
                    },
                    17 => {
                        self.incremental = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.relay != 0. {
                my_size += 1 + 8;
            }
            if self.incremental != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.relay != 0. {
                os.write_double(1, self.relay)?;
            }
            if self.incremental != 0. {
                os.write_double(2, self.incremental)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NetworkFee {
            NetworkFee::new()
        }

        fn clear(&mut self) {
            self.relay = 0.;
            self.incremental = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NetworkFee {
            static instance: NetworkFee = NetworkFee {
                relay: 0.,
                incremental: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NetworkFee {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.NetworkFee").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NetworkFee {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NetworkFee {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetStatusResponse.Network)
    pub struct Network {
        // message fields
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Network.peers_count)
        pub peers_count: u32,
        // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetStatusResponse.Network.fee)
        pub fee: ::protobuf::MessageField<NetworkFee>,
        // special fields
        // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetStatusResponse.Network.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Network {
        fn default() -> &'a Network {
            <Network as ::protobuf::Message>::default_instance()
        }
    }

    impl Network {
        pub fn new() -> Network {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "peers_count",
                |m: &Network| { &m.peers_count },
                |m: &mut Network| { &mut m.peers_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NetworkFee>(
                "fee",
                |m: &Network| { &m.fee },
                |m: &mut Network| { &mut m.fee },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Network>(
                "GetStatusResponse.Network",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Network {
        const NAME: &'static str = "Network";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.peers_count = is.read_uint32()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.fee)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.peers_count != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.peers_count);
            }
            if let Some(v) = self.fee.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.peers_count != 0 {
                os.write_uint32(1, self.peers_count)?;
            }
            if let Some(v) = self.fee.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Network {
            Network::new()
        }

        fn clear(&mut self) {
            self.peers_count = 0;
            self.fee.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Network {
            static instance: Network = Network {
                peers_count: 0,
                fee: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Network {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetStatusResponse.Network").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Network {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Network {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:org.dash.platform.dapi.v0.GetStatusResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Status.NOT_STARTED)
        NOT_STARTED = 0,
        // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Status.SYNCING)
        SYNCING = 1,
        // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Status.READY)
        READY = 2,
        // @@protoc_insertion_point(enum_value:org.dash.platform.dapi.v0.GetStatusResponse.Status.ERROR)
        ERROR = 3,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::NOT_STARTED),
                1 => ::std::option::Option::Some(Status::SYNCING),
                2 => ::std::option::Option::Some(Status::READY),
                3 => ::std::option::Option::Some(Status::ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::NOT_STARTED,
            Status::SYNCING,
            Status::READY,
            Status::ERROR,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetStatusResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::NOT_STARTED
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("GetStatusResponse.Status")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetBlockRequest)
pub struct GetBlockRequest {
    // message oneof groups
    pub block: ::std::option::Option<get_block_request::Block>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlockRequest {
    fn default() -> &'a GetBlockRequest {
        <GetBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockRequest {
    pub fn new() -> GetBlockRequest {
        ::std::default::Default::default()
    }

    // uint32 height = 1;

    pub fn height(&self) -> u32 {
        match self.block {
            ::std::option::Option::Some(get_block_request::Block::Height(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_height(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(get_block_request::Block::Height(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.block = ::std::option::Option::Some(get_block_request::Block::Height(v))
    }

    // string hash = 2;

    pub fn hash(&self) -> &str {
        match self.block {
            ::std::option::Option::Some(get_block_request::Block::Hash(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_hash(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(get_block_request::Block::Hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.block = ::std::option::Option::Some(get_block_request::Block::Hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(get_block_request::Block::Hash(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(get_block_request::Block::Hash(::std::string::String::new()));
        }
        match self.block {
            ::std::option::Option::Some(get_block_request::Block::Hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        if self.has_hash() {
            match self.block.take() {
                ::std::option::Option::Some(get_block_request::Block::Hash(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "height",
            GetBlockRequest::has_height,
            GetBlockRequest::height,
            GetBlockRequest::set_height,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "hash",
            GetBlockRequest::has_hash,
            GetBlockRequest::hash,
            GetBlockRequest::set_hash,
        ));
        oneofs.push(get_block_request::Block::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlockRequest>(
            "GetBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlockRequest {
    const NAME: &'static str = "GetBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.block = ::std::option::Option::Some(get_block_request::Block::Height(is.read_uint32()?));
                },
                18 => {
                    self.block = ::std::option::Option::Some(get_block_request::Block::Hash(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &get_block_request::Block::Height(v) => {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                },
                &get_block_request::Block::Hash(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &get_block_request::Block::Height(v) => {
                    os.write_uint32(1, v)?;
                },
                &get_block_request::Block::Hash(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlockRequest {
        GetBlockRequest::new()
    }

    fn clear(&mut self) {
        self.block = ::std::option::Option::None;
        self.block = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlockRequest {
        static instance: GetBlockRequest = GetBlockRequest {
            block: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetBlockRequest`
pub mod get_block_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.dash.platform.dapi.v0.GetBlockRequest.block)
    pub enum Block {
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.GetBlockRequest.height)
        Height(u32),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.GetBlockRequest.hash)
        Hash(::std::string::String),
    }

    impl ::protobuf::Oneof for Block {
    }

    impl ::protobuf::OneofFull for Block {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::GetBlockRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("block").unwrap()).clone()
        }
    }

    impl Block {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Block>("block")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetBlockResponse)
pub struct GetBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetBlockResponse.block)
    pub block: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlockResponse {
    fn default() -> &'a GetBlockResponse {
        <GetBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockResponse {
    pub fn new() -> GetBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block",
            |m: &GetBlockResponse| { &m.block },
            |m: &mut GetBlockResponse| { &mut m.block },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlockResponse>(
            "GetBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlockResponse {
    const NAME: &'static str = "GetBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.block = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.block.is_empty() {
            os.write_bytes(1, &self.block)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlockResponse {
        GetBlockResponse::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlockResponse {
        static instance: GetBlockResponse = GetBlockResponse {
            block: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BroadcastTransactionRequest)
pub struct BroadcastTransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BroadcastTransactionRequest.transaction)
    pub transaction: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BroadcastTransactionRequest.allow_high_fees)
    pub allow_high_fees: bool,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BroadcastTransactionRequest.bypass_limits)
    pub bypass_limits: bool,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BroadcastTransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BroadcastTransactionRequest {
    fn default() -> &'a BroadcastTransactionRequest {
        <BroadcastTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastTransactionRequest {
    pub fn new() -> BroadcastTransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction",
            |m: &BroadcastTransactionRequest| { &m.transaction },
            |m: &mut BroadcastTransactionRequest| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_high_fees",
            |m: &BroadcastTransactionRequest| { &m.allow_high_fees },
            |m: &mut BroadcastTransactionRequest| { &mut m.allow_high_fees },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bypass_limits",
            |m: &BroadcastTransactionRequest| { &m.bypass_limits },
            |m: &mut BroadcastTransactionRequest| { &mut m.bypass_limits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcastTransactionRequest>(
            "BroadcastTransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BroadcastTransactionRequest {
    const NAME: &'static str = "BroadcastTransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transaction = is.read_bytes()?;
                },
                16 => {
                    self.allow_high_fees = is.read_bool()?;
                },
                24 => {
                    self.bypass_limits = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transaction);
        }
        if self.allow_high_fees != false {
            my_size += 1 + 1;
        }
        if self.bypass_limits != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(1, &self.transaction)?;
        }
        if self.allow_high_fees != false {
            os.write_bool(2, self.allow_high_fees)?;
        }
        if self.bypass_limits != false {
            os.write_bool(3, self.bypass_limits)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BroadcastTransactionRequest {
        BroadcastTransactionRequest::new()
    }

    fn clear(&mut self) {
        self.transaction.clear();
        self.allow_high_fees = false;
        self.bypass_limits = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BroadcastTransactionRequest {
        static instance: BroadcastTransactionRequest = BroadcastTransactionRequest {
            transaction: ::std::vec::Vec::new(),
            allow_high_fees: false,
            bypass_limits: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BroadcastTransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BroadcastTransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BroadcastTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastTransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BroadcastTransactionResponse)
pub struct BroadcastTransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BroadcastTransactionResponse.transaction_id)
    pub transaction_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BroadcastTransactionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BroadcastTransactionResponse {
    fn default() -> &'a BroadcastTransactionResponse {
        <BroadcastTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastTransactionResponse {
    pub fn new() -> BroadcastTransactionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction_id",
            |m: &BroadcastTransactionResponse| { &m.transaction_id },
            |m: &mut BroadcastTransactionResponse| { &mut m.transaction_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BroadcastTransactionResponse>(
            "BroadcastTransactionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BroadcastTransactionResponse {
    const NAME: &'static str = "BroadcastTransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transaction_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.transaction_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transaction_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.transaction_id.is_empty() {
            os.write_string(1, &self.transaction_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BroadcastTransactionResponse {
        BroadcastTransactionResponse::new()
    }

    fn clear(&mut self) {
        self.transaction_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BroadcastTransactionResponse {
        static instance: BroadcastTransactionResponse = BroadcastTransactionResponse {
            transaction_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BroadcastTransactionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BroadcastTransactionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BroadcastTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastTransactionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetTransactionRequest)
pub struct GetTransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetTransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTransactionRequest {
    fn default() -> &'a GetTransactionRequest {
        <GetTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionRequest {
    pub fn new() -> GetTransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetTransactionRequest| { &m.id },
            |m: &mut GetTransactionRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTransactionRequest>(
            "GetTransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTransactionRequest {
    const NAME: &'static str = "GetTransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTransactionRequest {
        GetTransactionRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTransactionRequest {
        static instance: GetTransactionRequest = GetTransactionRequest {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetTransactionResponse)
pub struct GetTransactionResponse {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.transaction)
    pub transaction: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.block_hash)
    pub block_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.height)
    pub height: u32,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.confirmations)
    pub confirmations: u32,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.is_instant_locked)
    pub is_instant_locked: bool,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetTransactionResponse.is_chain_locked)
    pub is_chain_locked: bool,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetTransactionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTransactionResponse {
    fn default() -> &'a GetTransactionResponse {
        <GetTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionResponse {
    pub fn new() -> GetTransactionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction",
            |m: &GetTransactionResponse| { &m.transaction },
            |m: &mut GetTransactionResponse| { &mut m.transaction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_hash",
            |m: &GetTransactionResponse| { &m.block_hash },
            |m: &mut GetTransactionResponse| { &mut m.block_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetTransactionResponse| { &m.height },
            |m: &mut GetTransactionResponse| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "confirmations",
            |m: &GetTransactionResponse| { &m.confirmations },
            |m: &mut GetTransactionResponse| { &mut m.confirmations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_instant_locked",
            |m: &GetTransactionResponse| { &m.is_instant_locked },
            |m: &mut GetTransactionResponse| { &mut m.is_instant_locked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_chain_locked",
            |m: &GetTransactionResponse| { &m.is_chain_locked },
            |m: &mut GetTransactionResponse| { &mut m.is_chain_locked },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTransactionResponse>(
            "GetTransactionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTransactionResponse {
    const NAME: &'static str = "GetTransactionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transaction = is.read_bytes()?;
                },
                18 => {
                    self.block_hash = is.read_bytes()?;
                },
                24 => {
                    self.height = is.read_uint32()?;
                },
                32 => {
                    self.confirmations = is.read_uint32()?;
                },
                40 => {
                    self.is_instant_locked = is.read_bool()?;
                },
                48 => {
                    self.is_chain_locked = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transaction);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.block_hash);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.height);
        }
        if self.confirmations != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.confirmations);
        }
        if self.is_instant_locked != false {
            my_size += 1 + 1;
        }
        if self.is_chain_locked != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(1, &self.transaction)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(2, &self.block_hash)?;
        }
        if self.height != 0 {
            os.write_uint32(3, self.height)?;
        }
        if self.confirmations != 0 {
            os.write_uint32(4, self.confirmations)?;
        }
        if self.is_instant_locked != false {
            os.write_bool(5, self.is_instant_locked)?;
        }
        if self.is_chain_locked != false {
            os.write_bool(6, self.is_chain_locked)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTransactionResponse {
        GetTransactionResponse::new()
    }

    fn clear(&mut self) {
        self.transaction.clear();
        self.block_hash.clear();
        self.height = 0;
        self.confirmations = 0;
        self.is_instant_locked = false;
        self.is_chain_locked = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTransactionResponse {
        static instance: GetTransactionResponse = GetTransactionResponse {
            transaction: ::std::vec::Vec::new(),
            block_hash: ::std::vec::Vec::new(),
            height: 0,
            confirmations: 0,
            is_instant_locked: false,
            is_chain_locked: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTransactionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTransactionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest)
pub struct BlockHeadersWithChainLocksRequest {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest.count)
    pub count: u32,
    // message oneof groups
    pub from_block: ::std::option::Option<block_headers_with_chain_locks_request::From_block>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeadersWithChainLocksRequest {
    fn default() -> &'a BlockHeadersWithChainLocksRequest {
        <BlockHeadersWithChainLocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeadersWithChainLocksRequest {
    pub fn new() -> BlockHeadersWithChainLocksRequest {
        ::std::default::Default::default()
    }

    // bytes from_block_hash = 1;

    pub fn from_block_hash(&self) -> &[u8] {
        match self.from_block {
            ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_from_block_hash(&mut self) {
        self.from_block = ::std::option::Option::None;
    }

    pub fn has_from_block_hash(&self) -> bool {
        match self.from_block {
            ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_block = ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_from_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(_)) = self.from_block {
        } else {
            self.from_block = ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(::std::vec::Vec::new()));
        }
        match self.from_block {
            ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_from_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_from_block_hash() {
            match self.from_block.take() {
                ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // uint32 from_block_height = 2;

    pub fn from_block_height(&self) -> u32 {
        match self.from_block {
            ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHeight(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_from_block_height(&mut self) {
        self.from_block = ::std::option::Option::None;
    }

    pub fn has_from_block_height(&self) -> bool {
        match self.from_block {
            ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHeight(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_block_height(&mut self, v: u32) {
        self.from_block = ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHeight(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "from_block_hash",
            BlockHeadersWithChainLocksRequest::has_from_block_hash,
            BlockHeadersWithChainLocksRequest::from_block_hash,
            BlockHeadersWithChainLocksRequest::set_from_block_hash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_block_height",
            BlockHeadersWithChainLocksRequest::has_from_block_height,
            BlockHeadersWithChainLocksRequest::from_block_height,
            BlockHeadersWithChainLocksRequest::set_from_block_height,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &BlockHeadersWithChainLocksRequest| { &m.count },
            |m: &mut BlockHeadersWithChainLocksRequest| { &mut m.count },
        ));
        oneofs.push(block_headers_with_chain_locks_request::From_block::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeadersWithChainLocksRequest>(
            "BlockHeadersWithChainLocksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeadersWithChainLocksRequest {
    const NAME: &'static str = "BlockHeadersWithChainLocksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.from_block = ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHash(is.read_bytes()?));
                },
                16 => {
                    self.from_block = ::std::option::Option::Some(block_headers_with_chain_locks_request::From_block::FromBlockHeight(is.read_uint32()?));
                },
                24 => {
                    self.count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.count);
        }
        if let ::std::option::Option::Some(ref v) = self.from_block {
            match v {
                &block_headers_with_chain_locks_request::From_block::FromBlockHash(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &block_headers_with_chain_locks_request::From_block::FromBlockHeight(v) => {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_uint32(3, self.count)?;
        }
        if let ::std::option::Option::Some(ref v) = self.from_block {
            match v {
                &block_headers_with_chain_locks_request::From_block::FromBlockHash(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &block_headers_with_chain_locks_request::From_block::FromBlockHeight(v) => {
                    os.write_uint32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeadersWithChainLocksRequest {
        BlockHeadersWithChainLocksRequest::new()
    }

    fn clear(&mut self) {
        self.from_block = ::std::option::Option::None;
        self.from_block = ::std::option::Option::None;
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeadersWithChainLocksRequest {
        static instance: BlockHeadersWithChainLocksRequest = BlockHeadersWithChainLocksRequest {
            count: 0,
            from_block: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeadersWithChainLocksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeadersWithChainLocksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeadersWithChainLocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeadersWithChainLocksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BlockHeadersWithChainLocksRequest`
pub mod block_headers_with_chain_locks_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest.from_block)
    pub enum From_block {
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest.from_block_hash)
        FromBlockHash(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksRequest.from_block_height)
        FromBlockHeight(u32),
    }

    impl ::protobuf::Oneof for From_block {
    }

    impl ::protobuf::OneofFull for From_block {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BlockHeadersWithChainLocksRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("from_block").unwrap()).clone()
        }
    }

    impl From_block {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<From_block>("from_block")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksResponse)
pub struct BlockHeadersWithChainLocksResponse {
    // message oneof groups
    pub responses: ::std::option::Option<block_headers_with_chain_locks_response::Responses>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeadersWithChainLocksResponse {
    fn default() -> &'a BlockHeadersWithChainLocksResponse {
        <BlockHeadersWithChainLocksResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeadersWithChainLocksResponse {
    pub fn new() -> BlockHeadersWithChainLocksResponse {
        ::std::default::Default::default()
    }

    // .org.dash.platform.dapi.v0.BlockHeaders block_headers = 1;

    pub fn block_headers(&self) -> &BlockHeaders {
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(ref v)) => v,
            _ => <BlockHeaders as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_headers(&mut self) {
        self.responses = ::std::option::Option::None;
    }

    pub fn has_block_headers(&self) -> bool {
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_headers(&mut self, v: BlockHeaders) {
        self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_headers(&mut self) -> &mut BlockHeaders {
        if let ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(_)) = self.responses {
        } else {
            self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(BlockHeaders::new()));
        }
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_headers(&mut self) -> BlockHeaders {
        if self.has_block_headers() {
            match self.responses.take() {
                ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockHeaders::new()
        }
    }

    // bytes chain_lock = 2;

    pub fn chain_lock(&self) -> &[u8] {
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_chain_lock(&mut self) {
        self.responses = ::std::option::Option::None;
    }

    pub fn has_chain_lock(&self) -> bool {
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chain_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chain_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(_)) = self.responses {
        } else {
            self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(::std::vec::Vec::new()));
        }
        match self.responses {
            ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chain_lock(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_chain_lock() {
            match self.responses.take() {
                ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockHeaders>(
            "block_headers",
            BlockHeadersWithChainLocksResponse::has_block_headers,
            BlockHeadersWithChainLocksResponse::block_headers,
            BlockHeadersWithChainLocksResponse::mut_block_headers,
            BlockHeadersWithChainLocksResponse::set_block_headers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "chain_lock",
            BlockHeadersWithChainLocksResponse::has_chain_lock,
            BlockHeadersWithChainLocksResponse::chain_lock,
            BlockHeadersWithChainLocksResponse::set_chain_lock,
        ));
        oneofs.push(block_headers_with_chain_locks_response::Responses::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeadersWithChainLocksResponse>(
            "BlockHeadersWithChainLocksResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeadersWithChainLocksResponse {
    const NAME: &'static str = "BlockHeadersWithChainLocksResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::BlockHeaders(is.read_message()?));
                },
                18 => {
                    self.responses = ::std::option::Option::Some(block_headers_with_chain_locks_response::Responses::ChainLock(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.responses {
            match v {
                &block_headers_with_chain_locks_response::Responses::BlockHeaders(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &block_headers_with_chain_locks_response::Responses::ChainLock(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.responses {
            match v {
                &block_headers_with_chain_locks_response::Responses::BlockHeaders(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &block_headers_with_chain_locks_response::Responses::ChainLock(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeadersWithChainLocksResponse {
        BlockHeadersWithChainLocksResponse::new()
    }

    fn clear(&mut self) {
        self.responses = ::std::option::Option::None;
        self.responses = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeadersWithChainLocksResponse {
        static instance: BlockHeadersWithChainLocksResponse = BlockHeadersWithChainLocksResponse {
            responses: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeadersWithChainLocksResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeadersWithChainLocksResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeadersWithChainLocksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeadersWithChainLocksResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BlockHeadersWithChainLocksResponse`
pub mod block_headers_with_chain_locks_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksResponse.responses)
    pub enum Responses {
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksResponse.block_headers)
        BlockHeaders(super::BlockHeaders),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.BlockHeadersWithChainLocksResponse.chain_lock)
        ChainLock(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Responses {
    }

    impl ::protobuf::OneofFull for Responses {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BlockHeadersWithChainLocksResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("responses").unwrap()).clone()
        }
    }

    impl Responses {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Responses>("responses")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BlockHeaders)
pub struct BlockHeaders {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BlockHeaders.headers)
    pub headers: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BlockHeaders.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockHeaders {
    fn default() -> &'a BlockHeaders {
        <BlockHeaders as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeaders {
    pub fn new() -> BlockHeaders {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "headers",
            |m: &BlockHeaders| { &m.headers },
            |m: &mut BlockHeaders| { &mut m.headers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockHeaders>(
            "BlockHeaders",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockHeaders {
    const NAME: &'static str = "BlockHeaders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.headers.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.headers {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.headers {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockHeaders {
        BlockHeaders::new()
    }

    fn clear(&mut self) {
        self.headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockHeaders {
        static instance: BlockHeaders = BlockHeaders {
            headers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockHeaders {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockHeaders").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockHeaders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeaders {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeRequest)
pub struct GetEstimatedTransactionFeeRequest {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeRequest.blocks)
    pub blocks: u32,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEstimatedTransactionFeeRequest {
    fn default() -> &'a GetEstimatedTransactionFeeRequest {
        <GetEstimatedTransactionFeeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEstimatedTransactionFeeRequest {
    pub fn new() -> GetEstimatedTransactionFeeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blocks",
            |m: &GetEstimatedTransactionFeeRequest| { &m.blocks },
            |m: &mut GetEstimatedTransactionFeeRequest| { &mut m.blocks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEstimatedTransactionFeeRequest>(
            "GetEstimatedTransactionFeeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEstimatedTransactionFeeRequest {
    const NAME: &'static str = "GetEstimatedTransactionFeeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.blocks = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.blocks != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.blocks);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.blocks != 0 {
            os.write_uint32(1, self.blocks)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEstimatedTransactionFeeRequest {
        GetEstimatedTransactionFeeRequest::new()
    }

    fn clear(&mut self) {
        self.blocks = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEstimatedTransactionFeeRequest {
        static instance: GetEstimatedTransactionFeeRequest = GetEstimatedTransactionFeeRequest {
            blocks: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEstimatedTransactionFeeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEstimatedTransactionFeeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEstimatedTransactionFeeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEstimatedTransactionFeeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeResponse)
pub struct GetEstimatedTransactionFeeResponse {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeResponse.fee)
    pub fee: f64,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.GetEstimatedTransactionFeeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEstimatedTransactionFeeResponse {
    fn default() -> &'a GetEstimatedTransactionFeeResponse {
        <GetEstimatedTransactionFeeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetEstimatedTransactionFeeResponse {
    pub fn new() -> GetEstimatedTransactionFeeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fee",
            |m: &GetEstimatedTransactionFeeResponse| { &m.fee },
            |m: &mut GetEstimatedTransactionFeeResponse| { &mut m.fee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEstimatedTransactionFeeResponse>(
            "GetEstimatedTransactionFeeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEstimatedTransactionFeeResponse {
    const NAME: &'static str = "GetEstimatedTransactionFeeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.fee = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fee != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fee != 0. {
            os.write_double(1, self.fee)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEstimatedTransactionFeeResponse {
        GetEstimatedTransactionFeeResponse::new()
    }

    fn clear(&mut self) {
        self.fee = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEstimatedTransactionFeeResponse {
        static instance: GetEstimatedTransactionFeeResponse = GetEstimatedTransactionFeeResponse {
            fee: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEstimatedTransactionFeeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEstimatedTransactionFeeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEstimatedTransactionFeeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEstimatedTransactionFeeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.TransactionsWithProofsRequest)
pub struct TransactionsWithProofsRequest {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.bloom_filter)
    pub bloom_filter: ::protobuf::MessageField<BloomFilter>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.count)
    pub count: u32,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.send_transaction_hashes)
    pub send_transaction_hashes: bool,
    // message oneof groups
    pub from_block: ::std::option::Option<transactions_with_proofs_request::From_block>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionsWithProofsRequest {
    fn default() -> &'a TransactionsWithProofsRequest {
        <TransactionsWithProofsRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransactionsWithProofsRequest {
    pub fn new() -> TransactionsWithProofsRequest {
        ::std::default::Default::default()
    }

    // bytes from_block_hash = 2;

    pub fn from_block_hash(&self) -> &[u8] {
        match self.from_block {
            ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_from_block_hash(&mut self) {
        self.from_block = ::std::option::Option::None;
    }

    pub fn has_from_block_hash(&self) -> bool {
        match self.from_block {
            ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_block = ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_from_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(_)) = self.from_block {
        } else {
            self.from_block = ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(::std::vec::Vec::new()));
        }
        match self.from_block {
            ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_from_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_from_block_hash() {
            match self.from_block.take() {
                ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // uint32 from_block_height = 3;

    pub fn from_block_height(&self) -> u32 {
        match self.from_block {
            ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHeight(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_from_block_height(&mut self) {
        self.from_block = ::std::option::Option::None;
    }

    pub fn has_from_block_height(&self) -> bool {
        match self.from_block {
            ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHeight(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_from_block_height(&mut self, v: u32) {
        self.from_block = ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHeight(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BloomFilter>(
            "bloom_filter",
            |m: &TransactionsWithProofsRequest| { &m.bloom_filter },
            |m: &mut TransactionsWithProofsRequest| { &mut m.bloom_filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "from_block_hash",
            TransactionsWithProofsRequest::has_from_block_hash,
            TransactionsWithProofsRequest::from_block_hash,
            TransactionsWithProofsRequest::set_from_block_hash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "from_block_height",
            TransactionsWithProofsRequest::has_from_block_height,
            TransactionsWithProofsRequest::from_block_height,
            TransactionsWithProofsRequest::set_from_block_height,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &TransactionsWithProofsRequest| { &m.count },
            |m: &mut TransactionsWithProofsRequest| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "send_transaction_hashes",
            |m: &TransactionsWithProofsRequest| { &m.send_transaction_hashes },
            |m: &mut TransactionsWithProofsRequest| { &mut m.send_transaction_hashes },
        ));
        oneofs.push(transactions_with_proofs_request::From_block::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionsWithProofsRequest>(
            "TransactionsWithProofsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionsWithProofsRequest {
    const NAME: &'static str = "TransactionsWithProofsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bloom_filter)?;
                },
                18 => {
                    self.from_block = ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHash(is.read_bytes()?));
                },
                24 => {
                    self.from_block = ::std::option::Option::Some(transactions_with_proofs_request::From_block::FromBlockHeight(is.read_uint32()?));
                },
                32 => {
                    self.count = is.read_uint32()?;
                },
                40 => {
                    self.send_transaction_hashes = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bloom_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.count);
        }
        if self.send_transaction_hashes != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.from_block {
            match v {
                &transactions_with_proofs_request::From_block::FromBlockHash(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &transactions_with_proofs_request::From_block::FromBlockHeight(v) => {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bloom_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_uint32(4, self.count)?;
        }
        if self.send_transaction_hashes != false {
            os.write_bool(5, self.send_transaction_hashes)?;
        }
        if let ::std::option::Option::Some(ref v) = self.from_block {
            match v {
                &transactions_with_proofs_request::From_block::FromBlockHash(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &transactions_with_proofs_request::From_block::FromBlockHeight(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionsWithProofsRequest {
        TransactionsWithProofsRequest::new()
    }

    fn clear(&mut self) {
        self.bloom_filter.clear();
        self.from_block = ::std::option::Option::None;
        self.from_block = ::std::option::Option::None;
        self.count = 0;
        self.send_transaction_hashes = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionsWithProofsRequest {
        static instance: TransactionsWithProofsRequest = TransactionsWithProofsRequest {
            bloom_filter: ::protobuf::MessageField::none(),
            count: 0,
            send_transaction_hashes: false,
            from_block: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionsWithProofsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionsWithProofsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionsWithProofsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionsWithProofsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionsWithProofsRequest`
pub mod transactions_with_proofs_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.from_block)
    pub enum From_block {
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.from_block_hash)
        FromBlockHash(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.TransactionsWithProofsRequest.from_block_height)
        FromBlockHeight(u32),
    }

    impl ::protobuf::Oneof for From_block {
    }

    impl ::protobuf::OneofFull for From_block {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionsWithProofsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("from_block").unwrap()).clone()
        }
    }

    impl From_block {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<From_block>("from_block")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.BloomFilter)
pub struct BloomFilter {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BloomFilter.v_data)
    pub v_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BloomFilter.n_hash_funcs)
    pub n_hash_funcs: u32,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BloomFilter.n_tweak)
    pub n_tweak: u32,
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.BloomFilter.n_flags)
    pub n_flags: u32,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.BloomFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BloomFilter {
    fn default() -> &'a BloomFilter {
        <BloomFilter as ::protobuf::Message>::default_instance()
    }
}

impl BloomFilter {
    pub fn new() -> BloomFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "v_data",
            |m: &BloomFilter| { &m.v_data },
            |m: &mut BloomFilter| { &mut m.v_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_hash_funcs",
            |m: &BloomFilter| { &m.n_hash_funcs },
            |m: &mut BloomFilter| { &mut m.n_hash_funcs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_tweak",
            |m: &BloomFilter| { &m.n_tweak },
            |m: &mut BloomFilter| { &mut m.n_tweak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_flags",
            |m: &BloomFilter| { &m.n_flags },
            |m: &mut BloomFilter| { &mut m.n_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BloomFilter>(
            "BloomFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BloomFilter {
    const NAME: &'static str = "BloomFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.v_data = is.read_bytes()?;
                },
                16 => {
                    self.n_hash_funcs = is.read_uint32()?;
                },
                24 => {
                    self.n_tweak = is.read_uint32()?;
                },
                32 => {
                    self.n_flags = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.v_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.v_data);
        }
        if self.n_hash_funcs != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.n_hash_funcs);
        }
        if self.n_tweak != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.n_tweak);
        }
        if self.n_flags != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.n_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.v_data.is_empty() {
            os.write_bytes(1, &self.v_data)?;
        }
        if self.n_hash_funcs != 0 {
            os.write_uint32(2, self.n_hash_funcs)?;
        }
        if self.n_tweak != 0 {
            os.write_uint32(3, self.n_tweak)?;
        }
        if self.n_flags != 0 {
            os.write_uint32(4, self.n_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BloomFilter {
        BloomFilter::new()
    }

    fn clear(&mut self) {
        self.v_data.clear();
        self.n_hash_funcs = 0;
        self.n_tweak = 0;
        self.n_flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BloomFilter {
        static instance: BloomFilter = BloomFilter {
            v_data: ::std::vec::Vec::new(),
            n_hash_funcs: 0,
            n_tweak: 0,
            n_flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BloomFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BloomFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BloomFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.TransactionsWithProofsResponse)
pub struct TransactionsWithProofsResponse {
    // message oneof groups
    pub responses: ::std::option::Option<transactions_with_proofs_response::Responses>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.TransactionsWithProofsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionsWithProofsResponse {
    fn default() -> &'a TransactionsWithProofsResponse {
        <TransactionsWithProofsResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransactionsWithProofsResponse {
    pub fn new() -> TransactionsWithProofsResponse {
        ::std::default::Default::default()
    }

    // .org.dash.platform.dapi.v0.RawTransactions raw_transactions = 1;

    pub fn raw_transactions(&self) -> &RawTransactions {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(ref v)) => v,
            _ => <RawTransactions as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_raw_transactions(&mut self) {
        self.responses = ::std::option::Option::None;
    }

    pub fn has_raw_transactions(&self) -> bool {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_transactions(&mut self, v: RawTransactions) {
        self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_transactions(&mut self) -> &mut RawTransactions {
        if let ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(_)) = self.responses {
        } else {
            self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(RawTransactions::new()));
        }
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_transactions(&mut self) -> RawTransactions {
        if self.has_raw_transactions() {
            match self.responses.take() {
                ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(v)) => v,
                _ => panic!(),
            }
        } else {
            RawTransactions::new()
        }
    }

    // .org.dash.platform.dapi.v0.InstantSendLockMessages instant_send_lock_messages = 2;

    pub fn instant_send_lock_messages(&self) -> &InstantSendLockMessages {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(ref v)) => v,
            _ => <InstantSendLockMessages as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instant_send_lock_messages(&mut self) {
        self.responses = ::std::option::Option::None;
    }

    pub fn has_instant_send_lock_messages(&self) -> bool {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instant_send_lock_messages(&mut self, v: InstantSendLockMessages) {
        self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instant_send_lock_messages(&mut self) -> &mut InstantSendLockMessages {
        if let ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(_)) = self.responses {
        } else {
            self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(InstantSendLockMessages::new()));
        }
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instant_send_lock_messages(&mut self) -> InstantSendLockMessages {
        if self.has_instant_send_lock_messages() {
            match self.responses.take() {
                ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(v)) => v,
                _ => panic!(),
            }
        } else {
            InstantSendLockMessages::new()
        }
    }

    // bytes raw_merkle_block = 3;

    pub fn raw_merkle_block(&self) -> &[u8] {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_raw_merkle_block(&mut self) {
        self.responses = ::std::option::Option::None;
    }

    pub fn has_raw_merkle_block(&self) -> bool {
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_merkle_block(&mut self, v: ::std::vec::Vec<u8>) {
        self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_merkle_block(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(_)) = self.responses {
        } else {
            self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(::std::vec::Vec::new()));
        }
        match self.responses {
            ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_merkle_block(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_raw_merkle_block() {
            match self.responses.take() {
                ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RawTransactions>(
            "raw_transactions",
            TransactionsWithProofsResponse::has_raw_transactions,
            TransactionsWithProofsResponse::raw_transactions,
            TransactionsWithProofsResponse::mut_raw_transactions,
            TransactionsWithProofsResponse::set_raw_transactions,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InstantSendLockMessages>(
            "instant_send_lock_messages",
            TransactionsWithProofsResponse::has_instant_send_lock_messages,
            TransactionsWithProofsResponse::instant_send_lock_messages,
            TransactionsWithProofsResponse::mut_instant_send_lock_messages,
            TransactionsWithProofsResponse::set_instant_send_lock_messages,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "raw_merkle_block",
            TransactionsWithProofsResponse::has_raw_merkle_block,
            TransactionsWithProofsResponse::raw_merkle_block,
            TransactionsWithProofsResponse::set_raw_merkle_block,
        ));
        oneofs.push(transactions_with_proofs_response::Responses::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionsWithProofsResponse>(
            "TransactionsWithProofsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionsWithProofsResponse {
    const NAME: &'static str = "TransactionsWithProofsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawTransactions(is.read_message()?));
                },
                18 => {
                    self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::InstantSendLockMessages(is.read_message()?));
                },
                26 => {
                    self.responses = ::std::option::Option::Some(transactions_with_proofs_response::Responses::RawMerkleBlock(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.responses {
            match v {
                &transactions_with_proofs_response::Responses::RawTransactions(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transactions_with_proofs_response::Responses::InstantSendLockMessages(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transactions_with_proofs_response::Responses::RawMerkleBlock(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.responses {
            match v {
                &transactions_with_proofs_response::Responses::RawTransactions(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &transactions_with_proofs_response::Responses::InstantSendLockMessages(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &transactions_with_proofs_response::Responses::RawMerkleBlock(ref v) => {
                    os.write_bytes(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionsWithProofsResponse {
        TransactionsWithProofsResponse::new()
    }

    fn clear(&mut self) {
        self.responses = ::std::option::Option::None;
        self.responses = ::std::option::Option::None;
        self.responses = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionsWithProofsResponse {
        static instance: TransactionsWithProofsResponse = TransactionsWithProofsResponse {
            responses: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionsWithProofsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionsWithProofsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionsWithProofsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionsWithProofsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionsWithProofsResponse`
pub mod transactions_with_proofs_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:org.dash.platform.dapi.v0.TransactionsWithProofsResponse.responses)
    pub enum Responses {
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.TransactionsWithProofsResponse.raw_transactions)
        RawTransactions(super::RawTransactions),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.TransactionsWithProofsResponse.instant_send_lock_messages)
        InstantSendLockMessages(super::InstantSendLockMessages),
        // @@protoc_insertion_point(oneof_field:org.dash.platform.dapi.v0.TransactionsWithProofsResponse.raw_merkle_block)
        RawMerkleBlock(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Responses {
    }

    impl ::protobuf::OneofFull for Responses {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionsWithProofsResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("responses").unwrap()).clone()
        }
    }

    impl Responses {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Responses>("responses")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.RawTransactions)
pub struct RawTransactions {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.RawTransactions.transactions)
    pub transactions: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.RawTransactions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RawTransactions {
    fn default() -> &'a RawTransactions {
        <RawTransactions as ::protobuf::Message>::default_instance()
    }
}

impl RawTransactions {
    pub fn new() -> RawTransactions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &RawTransactions| { &m.transactions },
            |m: &mut RawTransactions| { &mut m.transactions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RawTransactions>(
            "RawTransactions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RawTransactions {
    const NAME: &'static str = "RawTransactions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transactions.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.transactions {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.transactions {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RawTransactions {
        RawTransactions::new()
    }

    fn clear(&mut self) {
        self.transactions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RawTransactions {
        static instance: RawTransactions = RawTransactions {
            transactions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RawTransactions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RawTransactions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RawTransactions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawTransactions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:org.dash.platform.dapi.v0.InstantSendLockMessages)
pub struct InstantSendLockMessages {
    // message fields
    // @@protoc_insertion_point(field:org.dash.platform.dapi.v0.InstantSendLockMessages.messages)
    pub messages: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:org.dash.platform.dapi.v0.InstantSendLockMessages.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstantSendLockMessages {
    fn default() -> &'a InstantSendLockMessages {
        <InstantSendLockMessages as ::protobuf::Message>::default_instance()
    }
}

impl InstantSendLockMessages {
    pub fn new() -> InstantSendLockMessages {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &InstantSendLockMessages| { &m.messages },
            |m: &mut InstantSendLockMessages| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstantSendLockMessages>(
            "InstantSendLockMessages",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstantSendLockMessages {
    const NAME: &'static str = "InstantSendLockMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstantSendLockMessages {
        InstantSendLockMessages::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstantSendLockMessages {
        static instance: InstantSendLockMessages = InstantSendLockMessages {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstantSendLockMessages {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstantSendLockMessages").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstantSendLockMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstantSendLockMessages {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ncore.proto\x12\x19org.dash.platform.dapi.v0\"\x12\n\x10GetStatusRequ\
    est\"\xbb\x0c\n\x11GetStatusResponse\x12N\n\x07version\x18\x01\x20\x01(\
    \x0b24.org.dash.platform.dapi.v0.GetStatusResponse.VersionR\x07version\
    \x12E\n\x04time\x18\x02\x20\x01(\x0b21.org.dash.platform.dapi.v0.GetStat\
    usResponse.TimeR\x04time\x12K\n\x06status\x18\x03\x20\x01(\x0e23.org.das\
    h.platform.dapi.v0.GetStatusResponse.StatusR\x06status\x12#\n\rsync_prog\
    ress\x18\x04\x20\x01(\x01R\x0csyncProgress\x12H\n\x05chain\x18\x05\x20\
    \x01(\x0b22.org.dash.platform.dapi.v0.GetStatusResponse.ChainR\x05chain\
    \x12W\n\nmasternode\x18\x06\x20\x01(\x0b27.org.dash.platform.dapi.v0.Get\
    StatusResponse.MasternodeR\nmasternode\x12N\n\x07network\x18\x07\x20\x01\
    (\x0b24.org.dash.platform.dapi.v0.GetStatusResponse.NetworkR\x07network\
    \x1aW\n\x07Version\x12\x1a\n\x08protocol\x18\x01\x20\x01(\rR\x08protocol\
    \x12\x1a\n\x08software\x18\x02\x20\x01(\rR\x08software\x12\x14\n\x05agen\
    t\x18\x03\x20\x01(\tR\x05agent\x1aH\n\x04Time\x12\x10\n\x03now\x18\x01\
    \x20\x01(\rR\x03now\x12\x16\n\x06offset\x18\x02\x20\x01(\x05R\x06offset\
    \x12\x16\n\x06median\x18\x03\x20\x01(\rR\x06median\x1a\x8c\x02\n\x05Chai\
    n\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12#\n\rheaders_count\
    \x18\x02\x20\x01(\rR\x0cheadersCount\x12!\n\x0cblocks_count\x18\x03\x20\
    \x01(\rR\x0bblocksCount\x12&\n\x0fbest_block_hash\x18\x04\x20\x01(\x0cR\
    \rbestBlockHash\x12\x1e\n\ndifficulty\x18\x05\x20\x01(\x01R\ndifficulty\
    \x12\x1d\n\nchain_work\x18\x06\x20\x01(\x0cR\tchainWork\x12\x1b\n\tis_sy\
    nced\x18\x07\x20\x01(\x08R\x08isSynced\x12#\n\rsync_progress\x18\x08\x20\
    \x01(\x01R\x0csyncProgress\x1a\xfc\x02\n\nMasternode\x12V\n\x06status\
    \x18\x01\x20\x01(\x0e2>.org.dash.platform.dapi.v0.GetStatusResponse.Mast\
    ernode.StatusR\x06status\x12\x1e\n\x0bpro_tx_hash\x18\x02\x20\x01(\x0cR\
    \tproTxHash\x12!\n\x0cpose_penalty\x18\x03\x20\x01(\rR\x0bposePenalty\
    \x12\x1b\n\tis_synced\x18\x04\x20\x01(\x08R\x08isSynced\x12#\n\rsync_pro\
    gress\x18\x05\x20\x01(\x01R\x0csyncProgress\"\x90\x01\n\x06Status\x12\
    \x0b\n\x07UNKNOWN\x10\0\x12\x15\n\x11WAITING_FOR_PROTX\x10\x01\x12\x0f\n\
    \x0bPOSE_BANNED\x10\x02\x12\x0b\n\x07REMOVED\x10\x03\x12\x18\n\x14OPERAT\
    OR_KEY_CHANGED\x10\x04\x12\x14\n\x10PROTX_IP_CHANGED\x10\x05\x12\t\n\x05\
    READY\x10\x06\x12\t\n\x05ERROR\x10\x07\x1aD\n\nNetworkFee\x12\x14\n\x05r\
    elay\x18\x01\x20\x01(\x01R\x05relay\x12\x20\n\x0bincremental\x18\x02\x20\
    \x01(\x01R\x0bincremental\x1au\n\x07Network\x12\x1f\n\x0bpeers_count\x18\
    \x01\x20\x01(\rR\npeersCount\x12I\n\x03fee\x18\x02\x20\x01(\x0b27.org.da\
    sh.platform.dapi.v0.GetStatusResponse.NetworkFeeR\x03fee\"<\n\x06Status\
    \x12\x0f\n\x0bNOT_STARTED\x10\0\x12\x0b\n\x07SYNCING\x10\x01\x12\t\n\x05\
    READY\x10\x02\x12\t\n\x05ERROR\x10\x03\"J\n\x0fGetBlockRequest\x12\x18\n\
    \x06height\x18\x01\x20\x01(\rH\0R\x06height\x12\x14\n\x04hash\x18\x02\
    \x20\x01(\tH\0R\x04hashB\x07\n\x05block\"(\n\x10GetBlockResponse\x12\x14\
    \n\x05block\x18\x01\x20\x01(\x0cR\x05block\"\x8c\x01\n\x1bBroadcastTrans\
    actionRequest\x12\x20\n\x0btransaction\x18\x01\x20\x01(\x0cR\x0btransact\
    ion\x12&\n\x0fallow_high_fees\x18\x02\x20\x01(\x08R\rallowHighFees\x12#\
    \n\rbypass_limits\x18\x03\x20\x01(\x08R\x0cbypassLimits\"E\n\x1cBroadcas\
    tTransactionResponse\x12%\n\x0etransaction_id\x18\x01\x20\x01(\tR\rtrans\
    actionId\"'\n\x15GetTransactionRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\"\xeb\x01\n\x16GetTransactionResponse\x12\x20\n\x0btransaction\
    \x18\x01\x20\x01(\x0cR\x0btransaction\x12\x1d\n\nblock_hash\x18\x02\x20\
    \x01(\x0cR\tblockHash\x12\x16\n\x06height\x18\x03\x20\x01(\rR\x06height\
    \x12$\n\rconfirmations\x18\x04\x20\x01(\rR\rconfirmations\x12*\n\x11is_i\
    nstant_locked\x18\x05\x20\x01(\x08R\x0fisInstantLocked\x12&\n\x0fis_chai\
    n_locked\x18\x06\x20\x01(\x08R\risChainLocked\"\x9f\x01\n!BlockHeadersWi\
    thChainLocksRequest\x12(\n\x0ffrom_block_hash\x18\x01\x20\x01(\x0cH\0R\r\
    fromBlockHash\x12,\n\x11from_block_height\x18\x02\x20\x01(\rH\0R\x0ffrom\
    BlockHeight\x12\x14\n\x05count\x18\x03\x20\x01(\rR\x05countB\x0c\n\nfrom\
    _block\"\xa2\x01\n\"BlockHeadersWithChainLocksResponse\x12N\n\rblock_hea\
    ders\x18\x01\x20\x01(\x0b2'.org.dash.platform.dapi.v0.BlockHeadersH\0R\
    \x0cblockHeaders\x12\x1f\n\nchain_lock\x18\x02\x20\x01(\x0cH\0R\tchainLo\
    ckB\x0b\n\tresponses\"(\n\x0cBlockHeaders\x12\x18\n\x07headers\x18\x01\
    \x20\x03(\x0cR\x07headers\";\n!GetEstimatedTransactionFeeRequest\x12\x16\
    \n\x06blocks\x18\x01\x20\x01(\rR\x06blocks\"6\n\"GetEstimatedTransaction\
    FeeResponse\x12\x10\n\x03fee\x18\x01\x20\x01(\x01R\x03fee\"\x9e\x02\n\
    \x1dTransactionsWithProofsRequest\x12I\n\x0cbloom_filter\x18\x01\x20\x01\
    (\x0b2&.org.dash.platform.dapi.v0.BloomFilterR\x0bbloomFilter\x12(\n\x0f\
    from_block_hash\x18\x02\x20\x01(\x0cH\0R\rfromBlockHash\x12,\n\x11from_b\
    lock_height\x18\x03\x20\x01(\rH\0R\x0ffromBlockHeight\x12\x14\n\x05count\
    \x18\x04\x20\x01(\rR\x05count\x126\n\x17send_transaction_hashes\x18\x05\
    \x20\x01(\x08R\x15sendTransactionHashesB\x0c\n\nfrom_block\"x\n\x0bBloom\
    Filter\x12\x15\n\x06v_data\x18\x01\x20\x01(\x0cR\x05vData\x12\x20\n\x0cn\
    _hash_funcs\x18\x02\x20\x01(\rR\nnHashFuncs\x12\x17\n\x07n_tweak\x18\x03\
    \x20\x01(\rR\x06nTweak\x12\x17\n\x07n_flags\x18\x04\x20\x01(\rR\x06nFlag\
    s\"\xa5\x02\n\x1eTransactionsWithProofsResponse\x12W\n\x10raw_transactio\
    ns\x18\x01\x20\x01(\x0b2*.org.dash.platform.dapi.v0.RawTransactionsH\0R\
    \x0frawTransactions\x12q\n\x1ainstant_send_lock_messages\x18\x02\x20\x01\
    (\x0b22.org.dash.platform.dapi.v0.InstantSendLockMessagesH\0R\x17instant\
    SendLockMessages\x12*\n\x10raw_merkle_block\x18\x03\x20\x01(\x0cH\0R\x0e\
    rawMerkleBlockB\x0b\n\tresponses\"5\n\x0fRawTransactions\x12\"\n\x0ctran\
    sactions\x18\x01\x20\x03(\x0cR\x0ctransactions\"5\n\x17InstantSendLockMe\
    ssages\x12\x1a\n\x08messages\x18\x01\x20\x03(\x0cR\x08messages2\xb6\x07\
    \n\x04Core\x12f\n\tgetStatus\x12+.org.dash.platform.dapi.v0.GetStatusReq\
    uest\x1a,.org.dash.platform.dapi.v0.GetStatusResponse\x12c\n\x08getBlock\
    \x12*.org.dash.platform.dapi.v0.GetBlockRequest\x1a+.org.dash.platform.d\
    api.v0.GetBlockResponse\x12\x87\x01\n\x14broadcastTransaction\x126.org.d\
    ash.platform.dapi.v0.BroadcastTransactionRequest\x1a7.org.dash.platform.\
    dapi.v0.BroadcastTransactionResponse\x12u\n\x0egetTransaction\x120.org.d\
    ash.platform.dapi.v0.GetTransactionRequest\x1a1.org.dash.platform.dapi.v\
    0.GetTransactionResponse\x12\x99\x01\n\x1agetEstimatedTransactionFee\x12\
    <.org.dash.platform.dapi.v0.GetEstimatedTransactionFeeRequest\x1a=.org.d\
    ash.platform.dapi.v0.GetEstimatedTransactionFeeResponse\x12\xa6\x01\n%su\
    bscribeToBlockHeadersWithChainLocks\x12<.org.dash.platform.dapi.v0.Block\
    HeadersWithChainLocksRequest\x1a=.org.dash.platform.dapi.v0.BlockHeaders\
    WithChainLocksResponse0\x01\x12\x9a\x01\n!subscribeToTransactionsWithPro\
    ofs\x128.org.dash.platform.dapi.v0.TransactionsWithProofsRequest\x1a9.or\
    g.dash.platform.dapi.v0.TransactionsWithProofsResponse0\x01J\xdc-\n\x07\
    \x12\x05\0\0\xb7\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\0\"\n\n\n\x02\x06\0\x12\x04\x04\0\x0c\x01\n\n\n\x03\x06\0\
    \x01\x12\x03\x04\x08\x0c\n\x0b\n\x04\x06\0\x02\0\x12\x03\x05\x02?\n\x0c\
    \n\x05\x06\0\x02\0\x01\x12\x03\x05\x06\x0f\n\x0c\n\x05\x06\0\x02\0\x02\
    \x12\x03\x05\x11!\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x05,=\n\x0b\n\x04\
    \x06\0\x02\x01\x12\x03\x06\x02<\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\
    \x06\x06\x0e\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x06\x10\x1f\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03\x06*:\n\x0b\n\x04\x06\0\x02\x02\x12\x03\
    \x07\x02`\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x07\x06\x1a\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03\x07\x1c7\n\x0c\n\x05\x06\0\x02\x02\x03\x12\
    \x03\x07B^\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x08\x02N\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03\x08\x06\x14\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x08\x16+\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x086L\n\x0b\n\x04\x06\0\
    \x02\x04\x12\x03\t\x02r\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\t\x06\x20\
    \n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\t\"C\n\x0c\n\x05\x06\0\x02\x04\
    \x03\x12\x03\tNp\n\x0c\n\x04\x06\0\x02\x05\x12\x04\n\x02\x84\x01\n\x0c\n\
    \x05\x06\0\x02\x05\x01\x12\x03\n\x06+\n\x0c\n\x05\x06\0\x02\x05\x02\x12\
    \x03\n-N\n\x0c\n\x05\x06\0\x02\x05\x06\x12\x03\nY_\n\r\n\x05\x06\0\x02\
    \x05\x03\x12\x04\n`\x82\x01\n\x0b\n\x04\x06\0\x02\x06\x12\x03\x0b\x02x\n\
    \x0c\n\x05\x06\0\x02\x06\x01\x12\x03\x0b\x06'\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x03\x0b)F\n\x0c\n\x05\x06\0\x02\x06\x06\x12\x03\x0bQW\n\x0c\n\
    \x05\x06\0\x02\x06\x03\x12\x03\x0bXv\n\n\n\x02\x04\0\x12\x04\x0e\0\x10\
    \x01\n\n\n\x03\x04\0\x01\x12\x03\x0e\x08\x18\n\n\n\x02\x04\x01\x12\x04\
    \x12\0U\x01\n\n\n\x03\x04\x01\x01\x12\x03\x12\x08\x19\n\x0c\n\x04\x04\
    \x01\x03\0\x12\x04\x13\x02\x17\x03\n\x0c\n\x05\x04\x01\x03\0\x01\x12\x03\
    \x13\n\x11\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03\x14\x04\x18\n\x0e\n\x07\
    \x04\x01\x03\0\x02\0\x05\x12\x03\x14\x04\n\n\x0e\n\x07\x04\x01\x03\0\x02\
    \0\x01\x12\x03\x14\x0b\x13\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x03\
    \x14\x16\x17\n\r\n\x06\x04\x01\x03\0\x02\x01\x12\x03\x15\x04\x18\n\x0e\n\
    \x07\x04\x01\x03\0\x02\x01\x05\x12\x03\x15\x04\n\n\x0e\n\x07\x04\x01\x03\
    \0\x02\x01\x01\x12\x03\x15\x0b\x13\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x03\
    \x12\x03\x15\x16\x17\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03\x16\x04\x15\
    \n\x0e\n\x07\x04\x01\x03\0\x02\x02\x05\x12\x03\x16\x04\n\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x02\x01\x12\x03\x16\x0b\x10\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x02\x03\x12\x03\x16\x13\x14\n\x0c\n\x04\x04\x01\x03\x01\x12\x04\x19\x02\
    \x1d\x03\n\x0c\n\x05\x04\x01\x03\x01\x01\x12\x03\x19\n\x0e\n\r\n\x06\x04\
    \x01\x03\x01\x02\0\x12\x03\x1a\x04\x13\n\x0e\n\x07\x04\x01\x03\x01\x02\0\
    \x05\x12\x03\x1a\x04\n\n\x0e\n\x07\x04\x01\x03\x01\x02\0\x01\x12\x03\x1a\
    \x0b\x0e\n\x0e\n\x07\x04\x01\x03\x01\x02\0\x03\x12\x03\x1a\x11\x12\n\r\n\
    \x06\x04\x01\x03\x01\x02\x01\x12\x03\x1b\x04\x15\n\x0e\n\x07\x04\x01\x03\
    \x01\x02\x01\x05\x12\x03\x1b\x04\t\n\x0e\n\x07\x04\x01\x03\x01\x02\x01\
    \x01\x12\x03\x1b\n\x10\n\x0e\n\x07\x04\x01\x03\x01\x02\x01\x03\x12\x03\
    \x1b\x13\x14\n\r\n\x06\x04\x01\x03\x01\x02\x02\x12\x03\x1c\x04\x16\n\x0e\
    \n\x07\x04\x01\x03\x01\x02\x02\x05\x12\x03\x1c\x04\n\n\x0e\n\x07\x04\x01\
    \x03\x01\x02\x02\x01\x12\x03\x1c\x0b\x11\n\x0e\n\x07\x04\x01\x03\x01\x02\
    \x02\x03\x12\x03\x1c\x14\x15\n\x0c\n\x04\x04\x01\x04\0\x12\x04\x1f\x02$\
    \x03\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03\x1f\x07\r\n\r\n\x06\x04\x01\
    \x04\0\x02\0\x12\x03\x20\x04\x14\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\
    \x03\x20\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03\x20\x12\x13\
    \n\r\n\x06\x04\x01\x04\0\x02\x01\x12\x03!\x04\x10\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x01\x01\x12\x03!\x04\x0b\n\x0e\n\x07\x04\x01\x04\0\x02\x01\
    \x02\x12\x03!\x0e\x0f\n\r\n\x06\x04\x01\x04\0\x02\x02\x12\x03\"\x04\x0e\
    \n\x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03\"\x04\t\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x02\x02\x12\x03\"\x0c\r\n\r\n\x06\x04\x01\x04\0\x02\x03\
    \x12\x03#\x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03#\x04\t\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03#\x0c\r\n\x0c\n\x04\x04\x01\
    \x03\x02\x12\x04&\x02/\x03\n\x0c\n\x05\x04\x01\x03\x02\x01\x12\x03&\n\
    \x0f\n\r\n\x06\x04\x01\x03\x02\x02\0\x12\x03'\x04\x14\n\x0e\n\x07\x04\
    \x01\x03\x02\x02\0\x05\x12\x03'\x04\n\n\x0e\n\x07\x04\x01\x03\x02\x02\0\
    \x01\x12\x03'\x0b\x0f\n\x0e\n\x07\x04\x01\x03\x02\x02\0\x03\x12\x03'\x12\
    \x13\n\r\n\x06\x04\x01\x03\x02\x02\x01\x12\x03(\x04\x1d\n\x0e\n\x07\x04\
    \x01\x03\x02\x02\x01\x05\x12\x03(\x04\n\n\x0e\n\x07\x04\x01\x03\x02\x02\
    \x01\x01\x12\x03(\x0b\x18\n\x0e\n\x07\x04\x01\x03\x02\x02\x01\x03\x12\
    \x03(\x1b\x1c\n\r\n\x06\x04\x01\x03\x02\x02\x02\x12\x03)\x04\x1c\n\x0e\n\
    \x07\x04\x01\x03\x02\x02\x02\x05\x12\x03)\x04\n\n\x0e\n\x07\x04\x01\x03\
    \x02\x02\x02\x01\x12\x03)\x0b\x17\n\x0e\n\x07\x04\x01\x03\x02\x02\x02\
    \x03\x12\x03)\x1a\x1b\n\r\n\x06\x04\x01\x03\x02\x02\x03\x12\x03*\x04\x1e\
    \n\x0e\n\x07\x04\x01\x03\x02\x02\x03\x05\x12\x03*\x04\t\n\x0e\n\x07\x04\
    \x01\x03\x02\x02\x03\x01\x12\x03*\n\x19\n\x0e\n\x07\x04\x01\x03\x02\x02\
    \x03\x03\x12\x03*\x1c\x1d\n\r\n\x06\x04\x01\x03\x02\x02\x04\x12\x03+\x04\
    \x1a\n\x0e\n\x07\x04\x01\x03\x02\x02\x04\x05\x12\x03+\x04\n\n\x0e\n\x07\
    \x04\x01\x03\x02\x02\x04\x01\x12\x03+\x0b\x15\n\x0e\n\x07\x04\x01\x03\
    \x02\x02\x04\x03\x12\x03+\x18\x19\n\r\n\x06\x04\x01\x03\x02\x02\x05\x12\
    \x03,\x04\x19\n\x0e\n\x07\x04\x01\x03\x02\x02\x05\x05\x12\x03,\x04\t\n\
    \x0e\n\x07\x04\x01\x03\x02\x02\x05\x01\x12\x03,\n\x14\n\x0e\n\x07\x04\
    \x01\x03\x02\x02\x05\x03\x12\x03,\x17\x18\n\r\n\x06\x04\x01\x03\x02\x02\
    \x06\x12\x03-\x04\x17\n\x0e\n\x07\x04\x01\x03\x02\x02\x06\x05\x12\x03-\
    \x04\x08\n\x0e\n\x07\x04\x01\x03\x02\x02\x06\x01\x12\x03-\t\x12\n\x0e\n\
    \x07\x04\x01\x03\x02\x02\x06\x03\x12\x03-\x15\x16\n\r\n\x06\x04\x01\x03\
    \x02\x02\x07\x12\x03.\x04\x1d\n\x0e\n\x07\x04\x01\x03\x02\x02\x07\x05\
    \x12\x03.\x04\n\n\x0e\n\x07\x04\x01\x03\x02\x02\x07\x01\x12\x03.\x0b\x18\
    \n\x0e\n\x07\x04\x01\x03\x02\x02\x07\x03\x12\x03.\x1b\x1c\n\x0c\n\x04\
    \x04\x01\x03\x03\x12\x041\x02B\x03\n\x0c\n\x05\x04\x01\x03\x03\x01\x12\
    \x031\n\x14\n\x0e\n\x06\x04\x01\x03\x03\x04\0\x12\x042\x04;\x05\n\x0e\n\
    \x07\x04\x01\x03\x03\x04\0\x01\x12\x032\t\x0f\n\x0f\n\x08\x04\x01\x03\
    \x03\x04\0\x02\0\x12\x033\x06\x12\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\0\
    \x01\x12\x033\x06\r\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\0\x02\x12\x033\
    \x10\x11\n\x0f\n\x08\x04\x01\x03\x03\x04\0\x02\x01\x12\x034\x06\x1c\n\
    \x10\n\t\x04\x01\x03\x03\x04\0\x02\x01\x01\x12\x034\x06\x17\n\x10\n\t\
    \x04\x01\x03\x03\x04\0\x02\x01\x02\x12\x034\x1a\x1b\n\x0f\n\x08\x04\x01\
    \x03\x03\x04\0\x02\x02\x12\x035\x06\x16\n\x10\n\t\x04\x01\x03\x03\x04\0\
    \x02\x02\x01\x12\x035\x06\x11\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x02\
    \x02\x12\x035\x14\x15\n\x0f\n\x08\x04\x01\x03\x03\x04\0\x02\x03\x12\x036\
    \x06\x12\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x03\x01\x12\x036\x06\r\n\
    \x10\n\t\x04\x01\x03\x03\x04\0\x02\x03\x02\x12\x036\x10\x11\n\x0f\n\x08\
    \x04\x01\x03\x03\x04\0\x02\x04\x12\x037\x06\x1f\n\x10\n\t\x04\x01\x03\
    \x03\x04\0\x02\x04\x01\x12\x037\x06\x1a\n\x10\n\t\x04\x01\x03\x03\x04\0\
    \x02\x04\x02\x12\x037\x1d\x1e\n\x0f\n\x08\x04\x01\x03\x03\x04\0\x02\x05\
    \x12\x038\x06\x1b\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x05\x01\x12\x038\
    \x06\x16\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x05\x02\x12\x038\x19\x1a\n\
    \x0f\n\x08\x04\x01\x03\x03\x04\0\x02\x06\x12\x039\x06\x10\n\x10\n\t\x04\
    \x01\x03\x03\x04\0\x02\x06\x01\x12\x039\x06\x0b\n\x10\n\t\x04\x01\x03\
    \x03\x04\0\x02\x06\x02\x12\x039\x0e\x0f\n\x0f\n\x08\x04\x01\x03\x03\x04\
    \0\x02\x07\x12\x03:\x06\x10\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x07\x01\
    \x12\x03:\x06\x0b\n\x10\n\t\x04\x01\x03\x03\x04\0\x02\x07\x02\x12\x03:\
    \x0e\x0f\n\r\n\x06\x04\x01\x03\x03\x02\0\x12\x03=\x04\x16\n\x0e\n\x07\
    \x04\x01\x03\x03\x02\0\x06\x12\x03=\x04\n\n\x0e\n\x07\x04\x01\x03\x03\
    \x02\0\x01\x12\x03=\x0b\x11\n\x0e\n\x07\x04\x01\x03\x03\x02\0\x03\x12\
    \x03=\x14\x15\n\r\n\x06\x04\x01\x03\x03\x02\x01\x12\x03>\x04\x1a\n\x0e\n\
    \x07\x04\x01\x03\x03\x02\x01\x05\x12\x03>\x04\t\n\x0e\n\x07\x04\x01\x03\
    \x03\x02\x01\x01\x12\x03>\n\x15\n\x0e\n\x07\x04\x01\x03\x03\x02\x01\x03\
    \x12\x03>\x18\x19\n\r\n\x06\x04\x01\x03\x03\x02\x02\x12\x03?\x04\x1c\n\
    \x0e\n\x07\x04\x01\x03\x03\x02\x02\x05\x12\x03?\x04\n\n\x0e\n\x07\x04\
    \x01\x03\x03\x02\x02\x01\x12\x03?\x0b\x17\n\x0e\n\x07\x04\x01\x03\x03\
    \x02\x02\x03\x12\x03?\x1a\x1b\n\r\n\x06\x04\x01\x03\x03\x02\x03\x12\x03@\
    \x04\x17\n\x0e\n\x07\x04\x01\x03\x03\x02\x03\x05\x12\x03@\x04\x08\n\x0e\
    \n\x07\x04\x01\x03\x03\x02\x03\x01\x12\x03@\t\x12\n\x0e\n\x07\x04\x01\
    \x03\x03\x02\x03\x03\x12\x03@\x15\x16\n\r\n\x06\x04\x01\x03\x03\x02\x04\
    \x12\x03A\x04\x1d\n\x0e\n\x07\x04\x01\x03\x03\x02\x04\x05\x12\x03A\x04\n\
    \n\x0e\n\x07\x04\x01\x03\x03\x02\x04\x01\x12\x03A\x0b\x18\n\x0e\n\x07\
    \x04\x01\x03\x03\x02\x04\x03\x12\x03A\x1b\x1c\n\x0c\n\x04\x04\x01\x03\
    \x04\x12\x04D\x02G\x03\n\x0c\n\x05\x04\x01\x03\x04\x01\x12\x03D\n\x14\n\
    \r\n\x06\x04\x01\x03\x04\x02\0\x12\x03E\x04\x15\n\x0e\n\x07\x04\x01\x03\
    \x04\x02\0\x05\x12\x03E\x04\n\n\x0e\n\x07\x04\x01\x03\x04\x02\0\x01\x12\
    \x03E\x0b\x10\n\x0e\n\x07\x04\x01\x03\x04\x02\0\x03\x12\x03E\x13\x14\n\r\
    \n\x06\x04\x01\x03\x04\x02\x01\x12\x03F\x04\x1b\n\x0e\n\x07\x04\x01\x03\
    \x04\x02\x01\x05\x12\x03F\x04\n\n\x0e\n\x07\x04\x01\x03\x04\x02\x01\x01\
    \x12\x03F\x0b\x16\n\x0e\n\x07\x04\x01\x03\x04\x02\x01\x03\x12\x03F\x19\
    \x1a\n\x0c\n\x04\x04\x01\x03\x05\x12\x04I\x02L\x03\n\x0c\n\x05\x04\x01\
    \x03\x05\x01\x12\x03I\n\x11\n\r\n\x06\x04\x01\x03\x05\x02\0\x12\x03J\x04\
    \x1b\n\x0e\n\x07\x04\x01\x03\x05\x02\0\x05\x12\x03J\x04\n\n\x0e\n\x07\
    \x04\x01\x03\x05\x02\0\x01\x12\x03J\x0b\x16\n\x0e\n\x07\x04\x01\x03\x05\
    \x02\0\x03\x12\x03J\x19\x1a\n\r\n\x06\x04\x01\x03\x05\x02\x01\x12\x03K\
    \x04\x17\n\x0e\n\x07\x04\x01\x03\x05\x02\x01\x06\x12\x03K\x04\x0e\n\x0e\
    \n\x07\x04\x01\x03\x05\x02\x01\x01\x12\x03K\x0f\x12\n\x0e\n\x07\x04\x01\
    \x03\x05\x02\x01\x03\x12\x03K\x15\x16\n\x0b\n\x04\x04\x01\x02\0\x12\x03N\
    \x02\x16\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03N\x02\t\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03N\n\x11\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03N\x14\
    \x15\n\x0b\n\x04\x04\x01\x02\x01\x12\x03O\x02\x10\n\x0c\n\x05\x04\x01\
    \x02\x01\x06\x12\x03O\x02\x06\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03O\
    \x07\x0b\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03O\x0e\x0f\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x03P\x02\x14\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\
    \x03P\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03P\t\x0f\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03P\x12\x13\n\x0b\n\x04\x04\x01\x02\x03\x12\
    \x03Q\x02\x1b\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03Q\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\x03\x01\x12\x03Q\t\x16\n\x0c\n\x05\x04\x01\x02\x03\x03\
    \x12\x03Q\x19\x1a\n\x0b\n\x04\x04\x01\x02\x04\x12\x03R\x02\x12\n\x0c\n\
    \x05\x04\x01\x02\x04\x06\x12\x03R\x02\x07\n\x0c\n\x05\x04\x01\x02\x04\
    \x01\x12\x03R\x08\r\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03R\x10\x11\n\
    \x0b\n\x04\x04\x01\x02\x05\x12\x03S\x02\x1c\n\x0c\n\x05\x04\x01\x02\x05\
    \x06\x12\x03S\x02\x0c\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03S\r\x17\n\
    \x0c\n\x05\x04\x01\x02\x05\x03\x12\x03S\x1a\x1b\n\x0b\n\x04\x04\x01\x02\
    \x06\x12\x03T\x02\x16\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03T\x02\t\n\
    \x0c\n\x05\x04\x01\x02\x06\x01\x12\x03T\n\x11\n\x0c\n\x05\x04\x01\x02\
    \x06\x03\x12\x03T\x14\x15\n\n\n\x02\x04\x02\x12\x04W\0\\\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03W\x08\x17\n\x0c\n\x04\x04\x02\x08\0\x12\x04X\x02[\
    \x03\n\x0c\n\x05\x04\x02\x08\0\x01\x12\x03X\x08\r\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03Y\x04\x16\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03Y\x04\n\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03Y\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03Y\x14\x15\n\x0b\n\x04\x04\x02\x02\x01\x12\x03Z\x04\x14\n\x0c\
    \n\x05\x04\x02\x02\x01\x05\x12\x03Z\x04\n\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03Z\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03Z\x12\x13\n\
    \n\n\x02\x04\x03\x12\x04^\0`\x01\n\n\n\x03\x04\x03\x01\x12\x03^\x08\x18\
    \n\x0b\n\x04\x04\x03\x02\0\x12\x03_\x02\x12\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03_\x02\x07\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03_\x08\r\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03_\x10\x11\n\n\n\x02\x04\x04\x12\x04b\0f\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03b\x08#\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03c\x02\x18\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03c\x02\x07\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03c\x08\x13\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03c\x16\x17\n\x0b\n\x04\x04\x04\x02\x01\x12\x03d\x02\x1b\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x03d\x02\x06\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03d\x07\x16\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03d\x19\x1a\n\x0b\
    \n\x04\x04\x04\x02\x02\x12\x03e\x02\x19\n\x0c\n\x05\x04\x04\x02\x02\x05\
    \x12\x03e\x02\x06\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03e\x07\x14\n\x0c\
    \n\x05\x04\x04\x02\x02\x03\x12\x03e\x17\x18\n\n\n\x02\x04\x05\x12\x04h\0\
    j\x01\n\n\n\x03\x04\x05\x01\x12\x03h\x08$\n\x0b\n\x04\x04\x05\x02\0\x12\
    \x03i\x02\x1c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03i\x02\x08\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03i\t\x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03i\
    \x1a\x1b\n\n\n\x02\x04\x06\x12\x04l\0n\x01\n\n\n\x03\x04\x06\x01\x12\x03\
    l\x08\x1d\n\x0b\n\x04\x04\x06\x02\0\x12\x03m\x02\x10\n\x0c\n\x05\x04\x06\
    \x02\0\x05\x12\x03m\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03m\t\x0b\
    \n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03m\x0e\x0f\n\n\n\x02\x04\x07\x12\
    \x04p\0w\x01\n\n\n\x03\x04\x07\x01\x12\x03p\x08\x1e\n\x0b\n\x04\x04\x07\
    \x02\0\x12\x03q\x02\x18\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03q\x02\x07\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03q\x08\x13\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03q\x16\x17\n\x0b\n\x04\x04\x07\x02\x01\x12\x03r\x02\x17\n\x0c\
    \n\x05\x04\x07\x02\x01\x05\x12\x03r\x02\x07\n\x0c\n\x05\x04\x07\x02\x01\
    \x01\x12\x03r\x08\x12\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03r\x15\x16\n\
    \x0b\n\x04\x04\x07\x02\x02\x12\x03s\x02\x14\n\x0c\n\x05\x04\x07\x02\x02\
    \x05\x12\x03s\x02\x08\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03s\t\x0f\n\
    \x0c\n\x05\x04\x07\x02\x02\x03\x12\x03s\x12\x13\n\x0b\n\x04\x04\x07\x02\
    \x03\x12\x03t\x02\x1b\n\x0c\n\x05\x04\x07\x02\x03\x05\x12\x03t\x02\x08\n\
    \x0c\n\x05\x04\x07\x02\x03\x01\x12\x03t\t\x16\n\x0c\n\x05\x04\x07\x02\
    \x03\x03\x12\x03t\x19\x1a\n\x0b\n\x04\x04\x07\x02\x04\x12\x03u\x02\x1d\n\
    \x0c\n\x05\x04\x07\x02\x04\x05\x12\x03u\x02\x06\n\x0c\n\x05\x04\x07\x02\
    \x04\x01\x12\x03u\x07\x18\n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03u\x1b\
    \x1c\n\x0b\n\x04\x04\x07\x02\x05\x12\x03v\x02\x1b\n\x0c\n\x05\x04\x07\
    \x02\x05\x05\x12\x03v\x02\x06\n\x0c\n\x05\x04\x07\x02\x05\x01\x12\x03v\
    \x07\x16\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\x03v\x19\x1a\n\x0b\n\x02\
    \x04\x08\x12\x05y\0\x80\x01\x01\n\n\n\x03\x04\x08\x01\x12\x03y\x08)\n\
    \x0c\n\x04\x04\x08\x08\0\x12\x04z\x02}\x03\n\x0c\n\x05\x04\x08\x08\0\x01\
    \x12\x03z\x08\x12\n\x0b\n\x04\x04\x08\x02\0\x12\x03{\x04\x1e\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03{\x04\t\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03{\
    \n\x19\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03{\x1c\x1d\n\x0b\n\x04\x04\
    \x08\x02\x01\x12\x03|\x04!\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03|\x04\
    \n\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03|\x0b\x1c\n\x0c\n\x05\x04\x08\
    \x02\x01\x03\x12\x03|\x1f\x20\n\x0b\n\x04\x04\x08\x02\x02\x12\x03\x7f\
    \x02\x13\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\
    \x04\x08\x02\x02\x01\x12\x03\x7f\t\x0e\n\x0c\n\x05\x04\x08\x02\x02\x03\
    \x12\x03\x7f\x11\x12\n\x0c\n\x02\x04\t\x12\x06\x82\x01\0\x87\x01\x01\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x82\x01\x08*\n\x0e\n\x04\x04\t\x08\0\x12\
    \x06\x83\x01\x02\x86\x01\x03\n\r\n\x05\x04\t\x08\0\x01\x12\x04\x83\x01\
    \x08\x11\n\x0c\n\x04\x04\t\x02\0\x12\x04\x84\x01\x04#\n\r\n\x05\x04\t\
    \x02\0\x06\x12\x04\x84\x01\x04\x10\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x84\
    \x01\x11\x1e\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x84\x01!\"\n\x0c\n\x04\
    \x04\t\x02\x01\x12\x04\x85\x01\x04\x19\n\r\n\x05\x04\t\x02\x01\x05\x12\
    \x04\x85\x01\x04\t\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x85\x01\n\x14\n\r\
    \n\x05\x04\t\x02\x01\x03\x12\x04\x85\x01\x17\x18\n\x0c\n\x02\x04\n\x12\
    \x06\x89\x01\0\x8b\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x89\x01\x08\x14\
    \n\x0c\n\x04\x04\n\x02\0\x12\x04\x8a\x01\x02\x1d\n\r\n\x05\x04\n\x02\0\
    \x04\x12\x04\x8a\x01\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x8a\x01\x0b\
    \x10\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8a\x01\x11\x18\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x8a\x01\x1b\x1c\n\x0c\n\x02\x04\x0b\x12\x06\x8d\x01\0\
    \x8f\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8d\x01\x08)\n\x0c\n\x04\
    \x04\x0b\x02\0\x12\x04\x8e\x01\x02\x14\n\r\n\x05\x04\x0b\x02\0\x05\x12\
    \x04\x8e\x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x8e\x01\t\x0f\n\
    \r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8e\x01\x12\x13\n\x0c\n\x02\x04\x0c\
    \x12\x06\x91\x01\0\x93\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x91\x01\
    \x08*\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x92\x01\x02\x11\n\r\n\x05\x04\
    \x0c\x02\0\x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\x92\x01\t\x0c\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x92\x01\x0f\x10\n\
    \x0c\n\x02\x04\r\x12\x06\x95\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\r\x01\x12\
    \x04\x95\x01\x08%\n\x0c\n\x04\x04\r\x02\0\x12\x04\x96\x01\x02\x1f\n\r\n\
    \x05\x04\r\x02\0\x06\x12\x04\x96\x01\x02\r\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\x96\x01\x0e\x1a\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x96\x01\x1d\x1e\n\
    \x0e\n\x04\x04\r\x08\0\x12\x06\x98\x01\x02\x9b\x01\x03\n\r\n\x05\x04\r\
    \x08\0\x01\x12\x04\x98\x01\x08\x12\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x99\
    \x01\x04\x1e\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x99\x01\x04\t\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\x99\x01\n\x19\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\x99\x01\x1c\x1d\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x9a\x01\x04!\n\r\
    \n\x05\x04\r\x02\x02\x05\x12\x04\x9a\x01\x04\n\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\x9a\x01\x0b\x1c\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x9a\x01\
    \x1f\x20\n\x0c\n\x04\x04\r\x02\x03\x12\x04\x9d\x01\x02\x13\n\r\n\x05\x04\
    \r\x02\x03\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\r\x02\x03\x01\x12\
    \x04\x9d\x01\t\x0e\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x9d\x01\x11\x12\n\
    \x0c\n\x04\x04\r\x02\x04\x12\x04\x9f\x01\x02#\n\r\n\x05\x04\r\x02\x04\
    \x05\x12\x04\x9f\x01\x02\x06\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x9f\x01\
    \x07\x1e\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\x9f\x01!\"\n\x0c\n\x02\x04\
    \x0e\x12\x06\xa2\x01\0\xa7\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa2\
    \x01\x08\x13\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xa3\x01\x02\x13\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xa3\x01\x02\x07\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xa3\x01\x08\x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xa3\x01\x11\
    \x12\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xa4\x01\x02\x1a\n\r\n\x05\x04\
    \x0e\x02\x01\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\
    \x12\x04\xa4\x01\t\x15\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xa4\x01\x18\
    \x19\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa5\x01\x02\x15\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xa5\x01\t\x10\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa5\x01\x13\
    \x14\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xa6\x01\x02\x15\n\r\n\x05\x04\
    \x0e\x02\x03\x05\x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\x0e\x02\x03\x01\
    \x12\x04\xa6\x01\t\x10\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xa6\x01\x13\
    \x14\n\x0c\n\x02\x04\x0f\x12\x06\xa9\x01\0\xaf\x01\x01\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xa9\x01\x08&\n\x0e\n\x04\x04\x0f\x08\0\x12\x06\xaa\x01\
    \x02\xae\x01\x03\n\r\n\x05\x04\x0f\x08\0\x01\x12\x04\xaa\x01\x08\x11\n\
    \x0c\n\x04\x04\x0f\x02\0\x12\x04\xab\x01\x04)\n\r\n\x05\x04\x0f\x02\0\
    \x06\x12\x04\xab\x01\x04\x13\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xab\x01\
    \x14$\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xab\x01'(\n\x0c\n\x04\x04\x0f\
    \x02\x01\x12\x04\xac\x01\x04;\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xac\
    \x01\x04\x1b\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xac\x01\x1c6\n\r\n\
    \x05\x04\x0f\x02\x01\x03\x12\x04\xac\x019:\n\x0c\n\x04\x04\x0f\x02\x02\
    \x12\x04\xad\x01\x04\x1f\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xad\x01\
    \x04\t\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xad\x01\n\x1a\n\r\n\x05\x04\
    \x0f\x02\x02\x03\x12\x04\xad\x01\x1d\x1e\n\x0c\n\x02\x04\x10\x12\x06\xb1\
    \x01\0\xb3\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xb1\x01\x08\x17\n\x0c\
    \n\x04\x04\x10\x02\0\x12\x04\xb2\x01\x02\"\n\r\n\x05\x04\x10\x02\0\x04\
    \x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xb2\x01\x0b\
    \x10\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb2\x01\x11\x1d\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\xb2\x01\x20!\n\x0c\n\x02\x04\x11\x12\x06\xb5\x01\
    \0\xb7\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb5\x01\x08\x1f\n\x0c\n\
    \x04\x04\x11\x02\0\x12\x04\xb6\x01\x02\x1e\n\r\n\x05\x04\x11\x02\0\x04\
    \x12\x04\xb6\x01\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xb6\x01\x0b\
    \x10\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb6\x01\x11\x19\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xb6\x01\x1c\x1db\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(24);
            messages.push(GetStatusRequest::generated_message_descriptor_data());
            messages.push(GetStatusResponse::generated_message_descriptor_data());
            messages.push(GetBlockRequest::generated_message_descriptor_data());
            messages.push(GetBlockResponse::generated_message_descriptor_data());
            messages.push(BroadcastTransactionRequest::generated_message_descriptor_data());
            messages.push(BroadcastTransactionResponse::generated_message_descriptor_data());
            messages.push(GetTransactionRequest::generated_message_descriptor_data());
            messages.push(GetTransactionResponse::generated_message_descriptor_data());
            messages.push(BlockHeadersWithChainLocksRequest::generated_message_descriptor_data());
            messages.push(BlockHeadersWithChainLocksResponse::generated_message_descriptor_data());
            messages.push(BlockHeaders::generated_message_descriptor_data());
            messages.push(GetEstimatedTransactionFeeRequest::generated_message_descriptor_data());
            messages.push(GetEstimatedTransactionFeeResponse::generated_message_descriptor_data());
            messages.push(TransactionsWithProofsRequest::generated_message_descriptor_data());
            messages.push(BloomFilter::generated_message_descriptor_data());
            messages.push(TransactionsWithProofsResponse::generated_message_descriptor_data());
            messages.push(RawTransactions::generated_message_descriptor_data());
            messages.push(InstantSendLockMessages::generated_message_descriptor_data());
            messages.push(get_status_response::Version::generated_message_descriptor_data());
            messages.push(get_status_response::Time::generated_message_descriptor_data());
            messages.push(get_status_response::Chain::generated_message_descriptor_data());
            messages.push(get_status_response::Masternode::generated_message_descriptor_data());
            messages.push(get_status_response::NetworkFee::generated_message_descriptor_data());
            messages.push(get_status_response::Network::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(get_status_response::Status::generated_enum_descriptor_data());
            enums.push(get_status_response::masternode::Status::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
