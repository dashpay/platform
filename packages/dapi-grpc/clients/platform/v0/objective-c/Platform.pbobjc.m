// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: platform.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Platform.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AllKeys);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBUInt32Value);
GPBObjCClassDeclaration(GetConsensusParamsRequest);
GPBObjCClassDeclaration(GetConsensusParamsRequest_GetConsensusParamsRequestV0);
GPBObjCClassDeclaration(GetConsensusParamsResponse);
GPBObjCClassDeclaration(GetConsensusParamsResponse_ConsensusParamsBlock);
GPBObjCClassDeclaration(GetConsensusParamsResponse_ConsensusParamsEvidence);
GPBObjCClassDeclaration(GetConsensusParamsResponse_GetConsensusParamsResponseV0);
GPBObjCClassDeclaration(GetDataContractHistoryRequest);
GPBObjCClassDeclaration(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0);
GPBObjCClassDeclaration(GetDataContractHistoryResponse);
GPBObjCClassDeclaration(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0);
GPBObjCClassDeclaration(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory);
GPBObjCClassDeclaration(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry);
GPBObjCClassDeclaration(GetDataContractRequest);
GPBObjCClassDeclaration(GetDataContractRequest_GetDataContractRequestV0);
GPBObjCClassDeclaration(GetDataContractResponse);
GPBObjCClassDeclaration(GetDataContractResponse_GetDataContractResponseV0);
GPBObjCClassDeclaration(GetDataContractsRequest);
GPBObjCClassDeclaration(GetDataContractsRequest_GetDataContractsRequestV0);
GPBObjCClassDeclaration(GetDataContractsResponse);
GPBObjCClassDeclaration(GetDataContractsResponse_DataContractEntry);
GPBObjCClassDeclaration(GetDataContractsResponse_DataContracts);
GPBObjCClassDeclaration(GetDataContractsResponse_GetDataContractsResponseV0);
GPBObjCClassDeclaration(GetDocumentsRequest);
GPBObjCClassDeclaration(GetDocumentsRequest_GetDocumentsRequestV0);
GPBObjCClassDeclaration(GetDocumentsResponse);
GPBObjCClassDeclaration(GetDocumentsResponse_GetDocumentsResponseV0);
GPBObjCClassDeclaration(GetDocumentsResponse_GetDocumentsResponseV0_Documents);
GPBObjCClassDeclaration(GetEpochsInfoRequest);
GPBObjCClassDeclaration(GetEpochsInfoRequest_GetEpochsInfoRequestV0);
GPBObjCClassDeclaration(GetEpochsInfoResponse);
GPBObjCClassDeclaration(GetEpochsInfoResponse_GetEpochsInfoResponseV0);
GPBObjCClassDeclaration(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo);
GPBObjCClassDeclaration(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesRequest);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry);
GPBObjCClassDeclaration(GetIdentitiesRequest);
GPBObjCClassDeclaration(GetIdentitiesRequest_GetIdentitiesRequestV0);
GPBObjCClassDeclaration(GetIdentitiesResponse);
GPBObjCClassDeclaration(GetIdentitiesResponse_GetIdentitiesResponseV0);
GPBObjCClassDeclaration(GetIdentitiesResponse_Identities);
GPBObjCClassDeclaration(GetIdentitiesResponse_IdentityEntry);
GPBObjCClassDeclaration(GetIdentitiesResponse_IdentityValue);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionRequest);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionResponse);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision);
GPBObjCClassDeclaration(GetIdentityBalanceRequest);
GPBObjCClassDeclaration(GetIdentityBalanceRequest_GetIdentityBalanceRequestV0);
GPBObjCClassDeclaration(GetIdentityBalanceResponse);
GPBObjCClassDeclaration(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0);
GPBObjCClassDeclaration(GetIdentityByPublicKeyHashRequest);
GPBObjCClassDeclaration(GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0);
GPBObjCClassDeclaration(GetIdentityByPublicKeyHashResponse);
GPBObjCClassDeclaration(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0);
GPBObjCClassDeclaration(GetIdentityKeysRequest);
GPBObjCClassDeclaration(GetIdentityKeysRequest_GetIdentityKeysRequestV0);
GPBObjCClassDeclaration(GetIdentityKeysResponse);
GPBObjCClassDeclaration(GetIdentityKeysResponse_GetIdentityKeysResponseV0);
GPBObjCClassDeclaration(GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys);
GPBObjCClassDeclaration(GetIdentityRequest);
GPBObjCClassDeclaration(GetIdentityRequest_GetIdentityRequestV0);
GPBObjCClassDeclaration(GetIdentityResponse);
GPBObjCClassDeclaration(GetIdentityResponse_GetIdentityResponseV0);
GPBObjCClassDeclaration(GetProofsRequest);
GPBObjCClassDeclaration(GetProofsRequest_GetProofsRequestV0);
GPBObjCClassDeclaration(GetProofsRequest_GetProofsRequestV0_ContractRequest);
GPBObjCClassDeclaration(GetProofsRequest_GetProofsRequestV0_DocumentRequest);
GPBObjCClassDeclaration(GetProofsRequest_GetProofsRequestV0_IdentityRequest);
GPBObjCClassDeclaration(GetProofsResponse);
GPBObjCClassDeclaration(GetProofsResponse_GetProofsResponseV0);
GPBObjCClassDeclaration(GetVersionUpgradeStateRequest);
GPBObjCClassDeclaration(GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0);
GPBObjCClassDeclaration(GetVersionUpgradeStateResponse);
GPBObjCClassDeclaration(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0);
GPBObjCClassDeclaration(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry);
GPBObjCClassDeclaration(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusRequest);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusResponse);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal);
GPBObjCClassDeclaration(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals);
GPBObjCClassDeclaration(KeyRequestType);
GPBObjCClassDeclaration(Proof);
GPBObjCClassDeclaration(ResponseMetadata);
GPBObjCClassDeclaration(SearchKey);
GPBObjCClassDeclaration(SecurityLevelMap);
GPBObjCClassDeclaration(SpecificKeys);
GPBObjCClassDeclaration(StateTransitionBroadcastError);
GPBObjCClassDeclaration(WaitForStateTransitionResultRequest);
GPBObjCClassDeclaration(WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0);
GPBObjCClassDeclaration(WaitForStateTransitionResultResponse);
GPBObjCClassDeclaration(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0);

#pragma mark - PlatformRoot

@implementation PlatformRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PlatformRoot_FileDescriptor

static GPBFileDescriptor *PlatformRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"org.dash.platform.dapi.v0"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Proof

@implementation Proof

@dynamic grovedbProof;
@dynamic quorumHash;
@dynamic signature;
@dynamic round;
@dynamic blockIdHash;
@dynamic quorumType;

typedef struct Proof__storage_ {
  uint32_t _has_storage_[1];
  uint32_t round;
  uint32_t quorumType;
  NSData *grovedbProof;
  NSData *quorumHash;
  NSData *signature;
  NSData *blockIdHash;
} Proof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "grovedbProof",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_GrovedbProof,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Proof__storage_, grovedbProof),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "quorumHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_QuorumHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Proof__storage_, quorumHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_Signature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Proof__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_Round,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Proof__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockIdHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_BlockIdHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Proof__storage_, blockIdHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "quorumType",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_QuorumType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Proof__storage_, quorumType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Proof class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMetadata

@implementation ResponseMetadata

@dynamic height;
@dynamic coreChainLockedHeight;
@dynamic epoch;
@dynamic timeMs;
@dynamic protocolVersion;
@dynamic chainId;

typedef struct ResponseMetadata__storage_ {
  uint32_t _has_storage_[1];
  uint32_t coreChainLockedHeight;
  uint32_t epoch;
  uint32_t protocolVersion;
  NSString *chainId;
  uint64_t height;
  uint64_t timeMs;
} ResponseMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coreChainLockedHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_CoreChainLockedHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, coreChainLockedHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "epoch",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_Epoch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, epoch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeMs",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_TimeMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, timeMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "protocolVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_ProtocolVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, protocolVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_ChainId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMetadata class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMetadata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StateTransitionBroadcastError

@implementation StateTransitionBroadcastError

@dynamic code;
@dynamic message;
@dynamic data_p;

typedef struct StateTransitionBroadcastError__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *message;
  NSData *data_p;
} StateTransitionBroadcastError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StateTransitionBroadcastError class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StateTransitionBroadcastError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastStateTransitionRequest

@implementation BroadcastStateTransitionRequest

@dynamic stateTransition;

typedef struct BroadcastStateTransitionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *stateTransition;
} BroadcastStateTransitionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateTransition",
        .dataTypeSpecific.clazz = Nil,
        .number = BroadcastStateTransitionRequest_FieldNumber_StateTransition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastStateTransitionRequest__storage_, stateTransition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastStateTransitionRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastStateTransitionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastStateTransitionResponse

@implementation BroadcastStateTransitionResponse


typedef struct BroadcastStateTransitionResponse__storage_ {
  uint32_t _has_storage_[1];
} BroadcastStateTransitionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastStateTransitionResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BroadcastStateTransitionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityRequest

@implementation GetIdentityRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityRequest_GetIdentityRequestV0 *v0;
} GetIdentityRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityRequest_GetIdentityRequestV0),
        .number = GetIdentityRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityRequest_ClearVersionOneOfCase(GetIdentityRequest *message) {
  GPBDescriptor *descriptor = [GetIdentityRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityRequest_GetIdentityRequestV0

@implementation GetIdentityRequest_GetIdentityRequestV0

@dynamic id_p;
@dynamic prove;

typedef struct GetIdentityRequest_GetIdentityRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetIdentityRequest_GetIdentityRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityRequest_GetIdentityRequestV0_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityRequest_GetIdentityRequestV0__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityRequest_GetIdentityRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityRequest_GetIdentityRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityRequest_GetIdentityRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityBalanceRequest

@implementation GetIdentityBalanceRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityBalanceRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceRequest_GetIdentityBalanceRequestV0 *v0;
} GetIdentityBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceRequest_GetIdentityBalanceRequestV0),
        .number = GetIdentityBalanceRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceRequest_ClearVersionOneOfCase(GetIdentityBalanceRequest *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceRequest_GetIdentityBalanceRequestV0

@implementation GetIdentityBalanceRequest_GetIdentityBalanceRequestV0

@dynamic id_p;
@dynamic prove;

typedef struct GetIdentityBalanceRequest_GetIdentityBalanceRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetIdentityBalanceRequest_GetIdentityBalanceRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceRequest_GetIdentityBalanceRequestV0_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceRequest_GetIdentityBalanceRequestV0__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceRequest_GetIdentityBalanceRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceRequest_GetIdentityBalanceRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceRequest_GetIdentityBalanceRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityBalanceAndRevisionRequest

@implementation GetIdentityBalanceAndRevisionRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityBalanceAndRevisionRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0 *v0;
} GetIdentityBalanceAndRevisionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0),
        .number = GetIdentityBalanceAndRevisionRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceAndRevisionRequest_ClearVersionOneOfCase(GetIdentityBalanceAndRevisionRequest *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceAndRevisionRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0

@implementation GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0

@dynamic id_p;
@dynamic prove;

typedef struct GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionRequest_GetIdentityBalanceAndRevisionRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceAndRevisionRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityResponse

@implementation GetIdentityResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityResponse_GetIdentityResponseV0 *v0;
} GetIdentityResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityResponse_GetIdentityResponseV0),
        .number = GetIdentityResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityResponse_ClearVersionOneOfCase(GetIdentityResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityResponse_GetIdentityResponseV0

@implementation GetIdentityResponse_GetIdentityResponseV0

@dynamic resultOneOfCase;
@dynamic identity;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityResponse_GetIdentityResponseV0__storage_ {
  uint32_t _has_storage_[2];
  NSData *identity;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityResponse_GetIdentityResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityResponse_GetIdentityResponseV0_FieldNumber_Identity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityResponse_GetIdentityResponseV0__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityResponse_GetIdentityResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityResponse_GetIdentityResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityResponse_GetIdentityResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityResponse_GetIdentityResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityResponse_GetIdentityResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityResponse_GetIdentityResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityResponse_GetIdentityResponseV0_ClearResultOneOfCase(GetIdentityResponse_GetIdentityResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentityResponse_GetIdentityResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesRequest

@implementation GetIdentitiesRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentitiesRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesRequest_GetIdentitiesRequestV0 *v0;
} GetIdentitiesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesRequest_GetIdentitiesRequestV0),
        .number = GetIdentitiesRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesRequest_ClearVersionOneOfCase(GetIdentitiesRequest *message) {
  GPBDescriptor *descriptor = [GetIdentitiesRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesRequest_GetIdentitiesRequestV0

@implementation GetIdentitiesRequest_GetIdentitiesRequestV0

@dynamic idsArray, idsArray_Count;
@dynamic prove;

typedef struct GetIdentitiesRequest_GetIdentitiesRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
} GetIdentitiesRequest_GetIdentitiesRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesRequest_GetIdentitiesRequestV0_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesRequest_GetIdentitiesRequestV0__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesRequest_GetIdentitiesRequestV0_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesRequest_GetIdentitiesRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesRequest_GetIdentitiesRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse

@implementation GetIdentitiesResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentitiesResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesResponse_GetIdentitiesResponseV0 *v0;
} GetIdentitiesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_GetIdentitiesResponseV0),
        .number = GetIdentitiesResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesResponse_ClearVersionOneOfCase(GetIdentitiesResponse *message) {
  GPBDescriptor *descriptor = [GetIdentitiesResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesResponse_IdentityValue

@implementation GetIdentitiesResponse_IdentityValue

@dynamic value;

typedef struct GetIdentitiesResponse_IdentityValue__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} GetIdentitiesResponse_IdentityValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesResponse_IdentityValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityValue__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_IdentityValue class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_IdentityValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse_IdentityEntry

@implementation GetIdentitiesResponse_IdentityEntry

@dynamic key;
@dynamic hasValue, value;

typedef struct GetIdentitiesResponse_IdentityEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  GetIdentitiesResponse_IdentityValue *value;
} GetIdentitiesResponse_IdentityEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesResponse_IdentityEntry_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityEntry__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_IdentityValue),
        .number = GetIdentitiesResponse_IdentityEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityEntry__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_IdentityEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_IdentityEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse_Identities

@implementation GetIdentitiesResponse_Identities

@dynamic identityEntriesArray, identityEntriesArray_Count;

typedef struct GetIdentitiesResponse_Identities__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identityEntriesArray;
} GetIdentitiesResponse_Identities__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_IdentityEntry),
        .number = GetIdentitiesResponse_Identities_FieldNumber_IdentityEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_Identities__storage_, identityEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_Identities class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_Identities__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse_GetIdentitiesResponseV0

@implementation GetIdentitiesResponse_GetIdentitiesResponseV0

@dynamic resultOneOfCase;
@dynamic identities;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentitiesResponse_GetIdentitiesResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesResponse_Identities *identities;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentitiesResponse_GetIdentitiesResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identities",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_Identities),
        .number = GetIdentitiesResponse_GetIdentitiesResponseV0_FieldNumber_Identities,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_GetIdentitiesResponseV0__storage_, identities),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentitiesResponse_GetIdentitiesResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_GetIdentitiesResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentitiesResponse_GetIdentitiesResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_GetIdentitiesResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_GetIdentitiesResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_GetIdentitiesResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesResponse_GetIdentitiesResponseV0_ClearResultOneOfCase(GetIdentitiesResponse_GetIdentitiesResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentitiesResponse_GetIdentitiesResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceResponse

@implementation GetIdentityBalanceResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityBalanceResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceResponse_GetIdentityBalanceResponseV0 *v0;
} GetIdentityBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0),
        .number = GetIdentityBalanceResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceResponse_ClearVersionOneOfCase(GetIdentityBalanceResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceResponse_GetIdentityBalanceResponseV0

@implementation GetIdentityBalanceResponse_GetIdentityBalanceResponseV0

@dynamic resultOneOfCase;
@dynamic balance;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_ {
  uint32_t _has_storage_[2];
  Proof *proof;
  ResponseMetadata *metadata;
  uint64_t balance;
} GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceResponse_GetIdentityBalanceResponseV0_FieldNumber_Balance,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityBalanceResponse_GetIdentityBalanceResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityBalanceResponse_GetIdentityBalanceResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceResponse_GetIdentityBalanceResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceResponse_GetIdentityBalanceResponseV0_ClearResultOneOfCase(GetIdentityBalanceResponse_GetIdentityBalanceResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceResponse_GetIdentityBalanceResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionResponse

@implementation GetIdentityBalanceAndRevisionResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityBalanceAndRevisionResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0 *v0;
} GetIdentityBalanceAndRevisionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0),
        .number = GetIdentityBalanceAndRevisionResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceAndRevisionResponse_ClearVersionOneOfCase(GetIdentityBalanceAndRevisionResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceAndRevisionResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0

@implementation GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0

@dynamic resultOneOfCase;
@dynamic balanceAndRevision;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision *balanceAndRevision;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balanceAndRevision",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision),
        .number = GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_FieldNumber_BalanceAndRevision,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_, balanceAndRevision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceAndRevisionResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_ClearResultOneOfCase(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision

@implementation GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision

@dynamic balance;
@dynamic revision;

typedef struct GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision__storage_ {
  uint32_t _has_storage_[1];
  uint64_t balance;
  uint64_t revision;
} GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision_FieldNumber_Revision,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision__storage_, revision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0_BalanceAndRevision__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceAndRevisionResponse_GetIdentityBalanceAndRevisionResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyRequestType

@implementation KeyRequestType

@dynamic requestOneOfCase;
@dynamic allKeys;
@dynamic specificKeys;
@dynamic searchKey;

typedef struct KeyRequestType__storage_ {
  uint32_t _has_storage_[2];
  AllKeys *allKeys;
  SpecificKeys *specificKeys;
  SearchKey *searchKey;
} KeyRequestType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allKeys",
        .dataTypeSpecific.clazz = GPBObjCClass(AllKeys),
        .number = KeyRequestType_FieldNumber_AllKeys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, allKeys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "specificKeys",
        .dataTypeSpecific.clazz = GPBObjCClass(SpecificKeys),
        .number = KeyRequestType_FieldNumber_SpecificKeys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, specificKeys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchKey",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchKey),
        .number = KeyRequestType_FieldNumber_SearchKey,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, searchKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyRequestType class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyRequestType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "request",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void KeyRequestType_ClearRequestOneOfCase(KeyRequestType *message) {
  GPBDescriptor *descriptor = [KeyRequestType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - AllKeys

@implementation AllKeys


typedef struct AllKeys__storage_ {
  uint32_t _has_storage_[1];
} AllKeys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllKeys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AllKeys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpecificKeys

@implementation SpecificKeys

@dynamic keyIdsArray, keyIdsArray_Count;

typedef struct SpecificKeys__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *keyIdsArray;
} SpecificKeys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SpecificKeys_FieldNumber_KeyIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SpecificKeys__storage_, keyIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpecificKeys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpecificKeys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchKey

@implementation SearchKey

@dynamic purposeMap, purposeMap_Count;

typedef struct SearchKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32ObjectDictionary *purposeMap;
} SearchKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "purposeMap",
        .dataTypeSpecific.clazz = GPBObjCClass(SecurityLevelMap),
        .number = SearchKey_FieldNumber_PurposeMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchKey__storage_, purposeMap),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchKey class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SecurityLevelMap

@implementation SecurityLevelMap

@dynamic securityLevelMap, securityLevelMap_Count;

typedef struct SecurityLevelMap__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32EnumDictionary *securityLevelMap;
} SecurityLevelMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "securityLevelMap",
        .dataTypeSpecific.enumDescFunc = SecurityLevelMap_KeyKindRequestType_EnumDescriptor,
        .number = SecurityLevelMap_FieldNumber_SecurityLevelMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SecurityLevelMap__storage_, securityLevelMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyUInt32 | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SecurityLevelMap class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SecurityLevelMap__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SecurityLevelMap_KeyKindRequestType

GPBEnumDescriptor *SecurityLevelMap_KeyKindRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CurrentKeyOfKindRequest\000AllKeysOfKindReq"
        "uest\000";
    static const int32_t values[] = {
        SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest,
        SecurityLevelMap_KeyKindRequestType_AllKeysOfKindRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SecurityLevelMap_KeyKindRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SecurityLevelMap_KeyKindRequestType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SecurityLevelMap_KeyKindRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest:
    case SecurityLevelMap_KeyKindRequestType_AllKeysOfKindRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetIdentityKeysRequest

@implementation GetIdentityKeysRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityKeysRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityKeysRequest_GetIdentityKeysRequestV0 *v0;
} GetIdentityKeysRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityKeysRequest_GetIdentityKeysRequestV0),
        .number = GetIdentityKeysRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityKeysRequest_ClearVersionOneOfCase(GetIdentityKeysRequest *message) {
  GPBDescriptor *descriptor = [GetIdentityKeysRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityKeysRequest_GetIdentityKeysRequestV0

@implementation GetIdentityKeysRequest_GetIdentityKeysRequestV0

@dynamic identityId;
@dynamic hasRequestType, requestType;
@dynamic hasLimit, limit;
@dynamic hasOffset, offset;
@dynamic prove;

typedef struct GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *identityId;
  KeyRequestType *requestType;
  GPBUInt32Value *limit;
  GPBUInt32Value *offset;
} GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysRequest_GetIdentityKeysRequestV0_FieldNumber_IdentityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_, identityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "requestType",
        .dataTypeSpecific.clazz = GPBObjCClass(KeyRequestType),
        .number = GetIdentityKeysRequest_GetIdentityKeysRequestV0_FieldNumber_RequestType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_, requestType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentityKeysRequest_GetIdentityKeysRequestV0_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentityKeysRequest_GetIdentityKeysRequestV0_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysRequest_GetIdentityKeysRequestV0_FieldNumber_Prove,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysRequest_GetIdentityKeysRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysRequest_GetIdentityKeysRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityKeysRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityKeysResponse

@implementation GetIdentityKeysResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityKeysResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityKeysResponse_GetIdentityKeysResponseV0 *v0;
} GetIdentityKeysResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityKeysResponse_GetIdentityKeysResponseV0),
        .number = GetIdentityKeysResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityKeysResponse_ClearVersionOneOfCase(GetIdentityKeysResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityKeysResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityKeysResponse_GetIdentityKeysResponseV0

@implementation GetIdentityKeysResponse_GetIdentityKeysResponseV0

@dynamic resultOneOfCase;
@dynamic keys;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys *keys;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keys",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys),
        .number = GetIdentityKeysResponse_GetIdentityKeysResponseV0_FieldNumber_Keys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_, keys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityKeysResponse_GetIdentityKeysResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityKeysResponse_GetIdentityKeysResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysResponse_GetIdentityKeysResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysResponse_GetIdentityKeysResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityKeysResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityKeysResponse_GetIdentityKeysResponseV0_ClearResultOneOfCase(GetIdentityKeysResponse_GetIdentityKeysResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentityKeysResponse_GetIdentityKeysResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys

@implementation GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys

@dynamic keysBytesArray, keysBytesArray_Count;

typedef struct GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysBytesArray;
} GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysBytesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys_FieldNumber_KeysBytesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys__storage_, keysBytesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysResponse_GetIdentityKeysResponseV0_Keys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityKeysResponse_GetIdentityKeysResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest

@implementation GetProofsRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetProofsRequest__storage_ {
  uint32_t _has_storage_[2];
  GetProofsRequest_GetProofsRequestV0 *v0;
} GetProofsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_GetProofsRequestV0),
        .number = GetProofsRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetProofsRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetProofsRequest_ClearVersionOneOfCase(GetProofsRequest *message) {
  GPBDescriptor *descriptor = [GetProofsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetProofsRequest_GetProofsRequestV0

@implementation GetProofsRequest_GetProofsRequestV0

@dynamic identitiesArray, identitiesArray_Count;
@dynamic contractsArray, contractsArray_Count;
@dynamic documentsArray, documentsArray_Count;

typedef struct GetProofsRequest_GetProofsRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identitiesArray;
  NSMutableArray *contractsArray;
  NSMutableArray *documentsArray;
} GetProofsRequest_GetProofsRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identitiesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_GetProofsRequestV0_IdentityRequest),
        .number = GetProofsRequest_GetProofsRequestV0_FieldNumber_IdentitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0__storage_, identitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_GetProofsRequestV0_ContractRequest),
        .number = GetProofsRequest_GetProofsRequestV0_FieldNumber_ContractsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0__storage_, contractsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_GetProofsRequestV0_DocumentRequest),
        .number = GetProofsRequest_GetProofsRequestV0_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_GetProofsRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_GetProofsRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest_GetProofsRequestV0_DocumentRequest

@implementation GetProofsRequest_GetProofsRequestV0_DocumentRequest

@dynamic contractId;
@dynamic documentType;
@dynamic documentTypeKeepsHistory;
@dynamic documentId;

typedef struct GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *contractId;
  NSString *documentType;
  NSData *documentId;
} GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_DocumentRequest_FieldNumber_ContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_, contractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "documentType",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_DocumentRequest_FieldNumber_DocumentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_, documentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentTypeKeepsHistory",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_DocumentRequest_FieldNumber_DocumentTypeKeepsHistory,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "documentId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_DocumentRequest_FieldNumber_DocumentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_, documentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_GetProofsRequestV0_DocumentRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_GetProofsRequestV0_DocumentRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest_GetProofsRequestV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest_GetProofsRequestV0_IdentityRequest

@implementation GetProofsRequest_GetProofsRequestV0_IdentityRequest

@dynamic identityId;
@dynamic requestType;

typedef struct GetProofsRequest_GetProofsRequestV0_IdentityRequest__storage_ {
  uint32_t _has_storage_[1];
  GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type requestType;
  NSData *identityId;
} GetProofsRequest_GetProofsRequestV0_IdentityRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_IdentityRequest_FieldNumber_IdentityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_IdentityRequest__storage_, identityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "requestType",
        .dataTypeSpecific.enumDescFunc = GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_EnumDescriptor,
        .number = GetProofsRequest_GetProofsRequestV0_IdentityRequest_FieldNumber_RequestType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_IdentityRequest__storage_, requestType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_GetProofsRequestV0_IdentityRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_GetProofsRequestV0_IdentityRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest_GetProofsRequestV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetProofsRequest_GetProofsRequestV0_IdentityRequest_RequestType_RawValue(GetProofsRequest_GetProofsRequestV0_IdentityRequest *message) {
  GPBDescriptor *descriptor = [GetProofsRequest_GetProofsRequestV0_IdentityRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetProofsRequest_GetProofsRequestV0_IdentityRequest_FieldNumber_RequestType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGetProofsRequest_GetProofsRequestV0_IdentityRequest_RequestType_RawValue(GetProofsRequest_GetProofsRequestV0_IdentityRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GetProofsRequest_GetProofsRequestV0_IdentityRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetProofsRequest_GetProofsRequestV0_IdentityRequest_FieldNumber_RequestType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type

GPBEnumDescriptor *GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FullIdentity\000Balance\000Keys\000";
    static const int32_t values[] = {
        GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_FullIdentity,
        GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_Balance,
        GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_Keys,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_FullIdentity:
    case GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_Balance:
    case GetProofsRequest_GetProofsRequestV0_IdentityRequest_Type_Keys:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetProofsRequest_GetProofsRequestV0_ContractRequest

@implementation GetProofsRequest_GetProofsRequestV0_ContractRequest

@dynamic contractId;

typedef struct GetProofsRequest_GetProofsRequestV0_ContractRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *contractId;
} GetProofsRequest_GetProofsRequestV0_ContractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_GetProofsRequestV0_ContractRequest_FieldNumber_ContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_GetProofsRequestV0_ContractRequest__storage_, contractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_GetProofsRequestV0_ContractRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_GetProofsRequestV0_ContractRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest_GetProofsRequestV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsResponse

@implementation GetProofsResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetProofsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetProofsResponse_GetProofsResponseV0 *v0;
} GetProofsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsResponse_GetProofsResponseV0),
        .number = GetProofsResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetProofsResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetProofsResponse_ClearVersionOneOfCase(GetProofsResponse *message) {
  GPBDescriptor *descriptor = [GetProofsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetProofsResponse_GetProofsResponseV0

@implementation GetProofsResponse_GetProofsResponseV0

@dynamic hasProof, proof;
@dynamic hasMetadata, metadata;

typedef struct GetProofsResponse_GetProofsResponseV0__storage_ {
  uint32_t _has_storage_[1];
  Proof *proof;
  ResponseMetadata *metadata;
} GetProofsResponse_GetProofsResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetProofsResponse_GetProofsResponseV0_FieldNumber_Proof,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsResponse_GetProofsResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetProofsResponse_GetProofsResponseV0_FieldNumber_Metadata,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsResponse_GetProofsResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsResponse_GetProofsResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsResponse_GetProofsResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractRequest

@implementation GetDataContractRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractRequest__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractRequest_GetDataContractRequestV0 *v0;
} GetDataContractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractRequest_GetDataContractRequestV0),
        .number = GetDataContractRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractRequest_ClearVersionOneOfCase(GetDataContractRequest *message) {
  GPBDescriptor *descriptor = [GetDataContractRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractRequest_GetDataContractRequestV0

@implementation GetDataContractRequest_GetDataContractRequestV0

@dynamic id_p;
@dynamic prove;

typedef struct GetDataContractRequest_GetDataContractRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetDataContractRequest_GetDataContractRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractRequest_GetDataContractRequestV0_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractRequest_GetDataContractRequestV0__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractRequest_GetDataContractRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractRequest_GetDataContractRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractRequest_GetDataContractRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractResponse

@implementation GetDataContractResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractResponse_GetDataContractResponseV0 *v0;
} GetDataContractResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractResponse_GetDataContractResponseV0),
        .number = GetDataContractResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractResponse_ClearVersionOneOfCase(GetDataContractResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractResponse_GetDataContractResponseV0

@implementation GetDataContractResponse_GetDataContractResponseV0

@dynamic resultOneOfCase;
@dynamic dataContract;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractResponse_GetDataContractResponseV0__storage_ {
  uint32_t _has_storage_[2];
  NSData *dataContract;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractResponse_GetDataContractResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContract",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractResponse_GetDataContractResponseV0_FieldNumber_DataContract,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractResponse_GetDataContractResponseV0__storage_, dataContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractResponse_GetDataContractResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractResponse_GetDataContractResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractResponse_GetDataContractResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractResponse_GetDataContractResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractResponse_GetDataContractResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractResponse_GetDataContractResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractResponse_GetDataContractResponseV0_ClearResultOneOfCase(GetDataContractResponse_GetDataContractResponseV0 *message) {
  GPBDescriptor *descriptor = [GetDataContractResponse_GetDataContractResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractsRequest

@implementation GetDataContractsRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractsRequest__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractsRequest_GetDataContractsRequestV0 *v0;
} GetDataContractsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsRequest_GetDataContractsRequestV0),
        .number = GetDataContractsRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractsRequest_ClearVersionOneOfCase(GetDataContractsRequest *message) {
  GPBDescriptor *descriptor = [GetDataContractsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractsRequest_GetDataContractsRequestV0

@implementation GetDataContractsRequest_GetDataContractsRequestV0

@dynamic idsArray, idsArray_Count;
@dynamic prove;

typedef struct GetDataContractsRequest_GetDataContractsRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
} GetDataContractsRequest_GetDataContractsRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsRequest_GetDataContractsRequestV0_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractsRequest_GetDataContractsRequestV0__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsRequest_GetDataContractsRequestV0_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsRequest_GetDataContractsRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsRequest_GetDataContractsRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse

@implementation GetDataContractsResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractsResponse_GetDataContractsResponseV0 *v0;
} GetDataContractsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_GetDataContractsResponseV0),
        .number = GetDataContractsResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractsResponse_ClearVersionOneOfCase(GetDataContractsResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractsResponse_DataContractEntry

@implementation GetDataContractsResponse_DataContractEntry

@dynamic identifier;
@dynamic hasDataContract, dataContract;

typedef struct GetDataContractsResponse_DataContractEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *identifier;
  GPBBytesValue *dataContract;
} GetDataContractsResponse_DataContractEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsResponse_DataContractEntry_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContractEntry__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataContract",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = GetDataContractsResponse_DataContractEntry_FieldNumber_DataContract,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContractEntry__storage_, dataContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_DataContractEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_DataContractEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse_DataContracts

@implementation GetDataContractsResponse_DataContracts

@dynamic dataContractEntriesArray, dataContractEntriesArray_Count;

typedef struct GetDataContractsResponse_DataContracts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataContractEntriesArray;
} GetDataContractsResponse_DataContracts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_DataContractEntry),
        .number = GetDataContractsResponse_DataContracts_FieldNumber_DataContractEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContracts__storage_, dataContractEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_DataContracts class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_DataContracts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse_GetDataContractsResponseV0

@implementation GetDataContractsResponse_GetDataContractsResponseV0

@dynamic resultOneOfCase;
@dynamic dataContracts;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractsResponse_GetDataContractsResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractsResponse_DataContracts *dataContracts;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractsResponse_GetDataContractsResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContracts",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_DataContracts),
        .number = GetDataContractsResponse_GetDataContractsResponseV0_FieldNumber_DataContracts,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_GetDataContractsResponseV0__storage_, dataContracts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractsResponse_GetDataContractsResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_GetDataContractsResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractsResponse_GetDataContractsResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_GetDataContractsResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_GetDataContractsResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_GetDataContractsResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractsResponse_GetDataContractsResponseV0_ClearResultOneOfCase(GetDataContractsResponse_GetDataContractsResponseV0 *message) {
  GPBDescriptor *descriptor = [GetDataContractsResponse_GetDataContractsResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractHistoryRequest

@implementation GetDataContractHistoryRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractHistoryRequest__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractHistoryRequest_GetDataContractHistoryRequestV0 *v0;
} GetDataContractHistoryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0),
        .number = GetDataContractHistoryRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractHistoryRequest_ClearVersionOneOfCase(GetDataContractHistoryRequest *message) {
  GPBDescriptor *descriptor = [GetDataContractHistoryRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractHistoryRequest_GetDataContractHistoryRequestV0

@implementation GetDataContractHistoryRequest_GetDataContractHistoryRequestV0

@dynamic id_p;
@dynamic hasLimit, limit;
@dynamic hasOffset, offset;
@dynamic startAtMs;
@dynamic prove;

typedef struct GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
  GPBUInt32Value *limit;
  GPBUInt32Value *offset;
  uint64_t startAtMs;
} GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_GetDataContractHistoryRequestV0_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetDataContractHistoryRequest_GetDataContractHistoryRequestV0_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetDataContractHistoryRequest_GetDataContractHistoryRequestV0_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startAtMs",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_GetDataContractHistoryRequestV0_FieldNumber_StartAtMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_, startAtMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_GetDataContractHistoryRequestV0_FieldNumber_Prove,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryRequest_GetDataContractHistoryRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryRequest_GetDataContractHistoryRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractHistoryResponse

@implementation GetDataContractHistoryResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDataContractHistoryResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractHistoryResponse_GetDataContractHistoryResponseV0 *v0;
} GetDataContractHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0),
        .number = GetDataContractHistoryResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractHistoryResponse_ClearVersionOneOfCase(GetDataContractHistoryResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractHistoryResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractHistoryResponse_GetDataContractHistoryResponseV0

@implementation GetDataContractHistoryResponse_GetDataContractHistoryResponseV0

@dynamic resultOneOfCase;
@dynamic dataContractHistory;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory *dataContractHistory;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractHistory",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory),
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_FieldNumber_DataContractHistory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_, dataContractHistory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse_GetDataContractHistoryResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_ClearResultOneOfCase(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0 *message) {
  GPBDescriptor *descriptor = [GetDataContractHistoryResponse_GetDataContractHistoryResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry

@implementation GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry

@dynamic date;
@dynamic value;

typedef struct GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
  uint64_t date;
} GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory

@implementation GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory

@dynamic dataContractEntriesArray, dataContractEntriesArray_Count;

typedef struct GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataContractEntriesArray;
} GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistoryEntry),
        .number = GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory_FieldNumber_DataContractEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory__storage_, dataContractEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0_DataContractHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryResponse_GetDataContractHistoryResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDocumentsRequest

@implementation GetDocumentsRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDocumentsRequest__storage_ {
  uint32_t _has_storage_[2];
  GetDocumentsRequest_GetDocumentsRequestV0 *v0;
} GetDocumentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDocumentsRequest_GetDocumentsRequestV0),
        .number = GetDocumentsRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsRequest_ClearVersionOneOfCase(GetDocumentsRequest *message) {
  GPBDescriptor *descriptor = [GetDocumentsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsRequest_GetDocumentsRequestV0

@implementation GetDocumentsRequest_GetDocumentsRequestV0

@dynamic startOneOfCase;
@dynamic dataContractId;
@dynamic documentType;
@dynamic where;
@dynamic orderBy;
@dynamic limit;
@dynamic startAfter;
@dynamic startAt;
@dynamic prove;

typedef struct GetDocumentsRequest_GetDocumentsRequestV0__storage_ {
  uint32_t _has_storage_[2];
  uint32_t limit;
  NSData *dataContractId;
  NSString *documentType;
  NSData *where;
  NSData *orderBy;
  NSData *startAfter;
  NSData *startAt;
} GetDocumentsRequest_GetDocumentsRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_DataContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, dataContractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "documentType",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_DocumentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, documentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "where",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_Where,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, where),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "orderBy",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_OrderBy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, orderBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_Limit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startAfter",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_StartAfter,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, startAfter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_StartAt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest_GetDocumentsRequestV0__storage_, startAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_GetDocumentsRequestV0_FieldNumber_Prove,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsRequest_GetDocumentsRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsRequest_GetDocumentsRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "start",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDocumentsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsRequest_GetDocumentsRequestV0_ClearStartOneOfCase(GetDocumentsRequest_GetDocumentsRequestV0 *message) {
  GPBDescriptor *descriptor = [GetDocumentsRequest_GetDocumentsRequestV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsResponse

@implementation GetDocumentsResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetDocumentsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDocumentsResponse_GetDocumentsResponseV0 *v0;
} GetDocumentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDocumentsResponse_GetDocumentsResponseV0),
        .number = GetDocumentsResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsResponse_ClearVersionOneOfCase(GetDocumentsResponse *message) {
  GPBDescriptor *descriptor = [GetDocumentsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsResponse_GetDocumentsResponseV0

@implementation GetDocumentsResponse_GetDocumentsResponseV0

@dynamic resultOneOfCase;
@dynamic documents;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDocumentsResponse_GetDocumentsResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetDocumentsResponse_GetDocumentsResponseV0_Documents *documents;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDocumentsResponse_GetDocumentsResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documents",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDocumentsResponse_GetDocumentsResponseV0_Documents),
        .number = GetDocumentsResponse_GetDocumentsResponseV0_FieldNumber_Documents,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsResponse_GetDocumentsResponseV0__storage_, documents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDocumentsResponse_GetDocumentsResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsResponse_GetDocumentsResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDocumentsResponse_GetDocumentsResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDocumentsResponse_GetDocumentsResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsResponse_GetDocumentsResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsResponse_GetDocumentsResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDocumentsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsResponse_GetDocumentsResponseV0_ClearResultOneOfCase(GetDocumentsResponse_GetDocumentsResponseV0 *message) {
  GPBDescriptor *descriptor = [GetDocumentsResponse_GetDocumentsResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsResponse_GetDocumentsResponseV0_Documents

@implementation GetDocumentsResponse_GetDocumentsResponseV0_Documents

@dynamic documentsArray, documentsArray_Count;

typedef struct GetDocumentsResponse_GetDocumentsResponseV0_Documents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *documentsArray;
} GetDocumentsResponse_GetDocumentsResponseV0_Documents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documentsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsResponse_GetDocumentsResponseV0_Documents_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDocumentsResponse_GetDocumentsResponseV0_Documents__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsResponse_GetDocumentsResponseV0_Documents class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsResponse_GetDocumentsResponseV0_Documents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDocumentsResponse_GetDocumentsResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesRequest

@implementation GetIdentitiesByPublicKeyHashesRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentitiesByPublicKeyHashesRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0 *v0;
} GetIdentitiesByPublicKeyHashesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0),
        .number = GetIdentitiesByPublicKeyHashesRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesByPublicKeyHashesRequest_ClearVersionOneOfCase(GetIdentitiesByPublicKeyHashesRequest *message) {
  GPBDescriptor *descriptor = [GetIdentitiesByPublicKeyHashesRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0

@implementation GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0

@dynamic publicKeyHashesArray, publicKeyHashesArray_Count;
@dynamic prove;

typedef struct GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *publicKeyHashesArray;
} GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyHashesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0_FieldNumber_PublicKeyHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0__storage_, publicKeyHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesRequest_GetIdentitiesByPublicKeyHashesRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesByPublicKeyHashesRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesResponse

@implementation GetIdentitiesByPublicKeyHashesResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentitiesByPublicKeyHashesResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0 *v0;
} GetIdentitiesByPublicKeyHashesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0),
        .number = GetIdentitiesByPublicKeyHashesResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesByPublicKeyHashesResponse_ClearVersionOneOfCase(GetIdentitiesByPublicKeyHashesResponse *message) {
  GPBDescriptor *descriptor = [GetIdentitiesByPublicKeyHashesResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry

@implementation GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry

@dynamic publicKeyHash;
@dynamic hasValue, value;

typedef struct GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKeyHash;
  GPBBytesValue *value;
} GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry_FieldNumber_PublicKeyHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry__storage_, publicKeyHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes

@implementation GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes

@dynamic identityEntriesArray, identityEntriesArray_Count;

typedef struct GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identityEntriesArray;
} GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse_PublicKeyHashIdentityEntry),
        .number = GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes_FieldNumber_IdentityEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes__storage_, identityEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0

@implementation GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0

@dynamic resultOneOfCase;
@dynamic identities;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes *identities;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identities",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse_IdentitiesByPublicKeyHashes),
        .number = GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0_FieldNumber_Identities,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_, identities),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0_ClearResultOneOfCase(GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentitiesByPublicKeyHashesResponse_GetIdentitiesByPublicKeyHashesResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityByPublicKeyHashRequest

@implementation GetIdentityByPublicKeyHashRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityByPublicKeyHashRequest__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0 *v0;
} GetIdentityByPublicKeyHashRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0),
        .number = GetIdentityByPublicKeyHashRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityByPublicKeyHashRequest_ClearVersionOneOfCase(GetIdentityByPublicKeyHashRequest *message) {
  GPBDescriptor *descriptor = [GetIdentityByPublicKeyHashRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0

@implementation GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0

@dynamic publicKeyHash;
@dynamic prove;

typedef struct GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKeyHash;
} GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0_FieldNumber_PublicKeyHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0__storage_, publicKeyHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashRequest_GetIdentityByPublicKeyHashRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityByPublicKeyHashRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityByPublicKeyHashResponse

@implementation GetIdentityByPublicKeyHashResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetIdentityByPublicKeyHashResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0 *v0;
} GetIdentityByPublicKeyHashResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0),
        .number = GetIdentityByPublicKeyHashResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityByPublicKeyHashResponse_ClearVersionOneOfCase(GetIdentityByPublicKeyHashResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityByPublicKeyHashResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0

@implementation GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0

@dynamic resultOneOfCase;
@dynamic identity;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_ {
  uint32_t _has_storage_[2];
  NSData *identity;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0_FieldNumber_Identity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityByPublicKeyHashResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0_ClearResultOneOfCase(GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0 *message) {
  GPBDescriptor *descriptor = [GetIdentityByPublicKeyHashResponse_GetIdentityByPublicKeyHashResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - WaitForStateTransitionResultRequest

@implementation WaitForStateTransitionResultRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct WaitForStateTransitionResultRequest__storage_ {
  uint32_t _has_storage_[2];
  WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0 *v0;
} WaitForStateTransitionResultRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0),
        .number = WaitForStateTransitionResultRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void WaitForStateTransitionResultRequest_ClearVersionOneOfCase(WaitForStateTransitionResultRequest *message) {
  GPBDescriptor *descriptor = [WaitForStateTransitionResultRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0

@implementation WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0

@dynamic stateTransitionHash;
@dynamic prove;

typedef struct WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0__storage_ {
  uint32_t _has_storage_[1];
  NSData *stateTransitionHash;
} WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateTransitionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0_FieldNumber_StateTransitionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0__storage_, stateTransitionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultRequest_WaitForStateTransitionResultRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(WaitForStateTransitionResultRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WaitForStateTransitionResultResponse

@implementation WaitForStateTransitionResultResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct WaitForStateTransitionResultResponse__storage_ {
  uint32_t _has_storage_[2];
  WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0 *v0;
} WaitForStateTransitionResultResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0),
        .number = WaitForStateTransitionResultResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void WaitForStateTransitionResultResponse_ClearVersionOneOfCase(WaitForStateTransitionResultResponse *message) {
  GPBDescriptor *descriptor = [WaitForStateTransitionResultResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0

@implementation WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0

@dynamic resultOneOfCase;
@dynamic error;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_ {
  uint32_t _has_storage_[2];
  StateTransitionBroadcastError *error;
  Proof *proof;
  ResponseMetadata *metadata;
} WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.clazz = GPBObjCClass(StateTransitionBroadcastError),
        .number = WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(WaitForStateTransitionResultResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0_ClearResultOneOfCase(WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0 *message) {
  GPBDescriptor *descriptor = [WaitForStateTransitionResultResponse_WaitForStateTransitionResultResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetConsensusParamsRequest

@implementation GetConsensusParamsRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetConsensusParamsRequest__storage_ {
  uint32_t _has_storage_[2];
  GetConsensusParamsRequest_GetConsensusParamsRequestV0 *v0;
} GetConsensusParamsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetConsensusParamsRequest_GetConsensusParamsRequestV0),
        .number = GetConsensusParamsRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetConsensusParamsRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetConsensusParamsRequest_ClearVersionOneOfCase(GetConsensusParamsRequest *message) {
  GPBDescriptor *descriptor = [GetConsensusParamsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetConsensusParamsRequest_GetConsensusParamsRequestV0

@implementation GetConsensusParamsRequest_GetConsensusParamsRequestV0

@dynamic height;
@dynamic prove;

typedef struct GetConsensusParamsRequest_GetConsensusParamsRequestV0__storage_ {
  uint32_t _has_storage_[1];
  int32_t height;
} GetConsensusParamsRequest_GetConsensusParamsRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsRequest_GetConsensusParamsRequestV0_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsRequest_GetConsensusParamsRequestV0__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsRequest_GetConsensusParamsRequestV0_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsRequest_GetConsensusParamsRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsRequest_GetConsensusParamsRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetConsensusParamsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConsensusParamsResponse

@implementation GetConsensusParamsResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetConsensusParamsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetConsensusParamsResponse_GetConsensusParamsResponseV0 *v0;
} GetConsensusParamsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetConsensusParamsResponse_GetConsensusParamsResponseV0),
        .number = GetConsensusParamsResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetConsensusParamsResponse_ClearVersionOneOfCase(GetConsensusParamsResponse *message) {
  GPBDescriptor *descriptor = [GetConsensusParamsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetConsensusParamsResponse_ConsensusParamsBlock

@implementation GetConsensusParamsResponse_ConsensusParamsBlock

@dynamic maxBytes;
@dynamic maxGas;
@dynamic timeIotaMs;

typedef struct GetConsensusParamsResponse_ConsensusParamsBlock__storage_ {
  uint32_t _has_storage_[1];
  NSString *maxBytes;
  NSString *maxGas;
  NSString *timeIotaMs;
} GetConsensusParamsResponse_ConsensusParamsBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsBlock_FieldNumber_MaxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsBlock__storage_, maxBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxGas",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsBlock_FieldNumber_MaxGas,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsBlock__storage_, maxGas),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeIotaMs",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsBlock_FieldNumber_TimeIotaMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsBlock__storage_, timeIotaMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsResponse_ConsensusParamsBlock class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsResponse_ConsensusParamsBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetConsensusParamsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConsensusParamsResponse_ConsensusParamsEvidence

@implementation GetConsensusParamsResponse_ConsensusParamsEvidence

@dynamic maxAgeNumBlocks;
@dynamic maxAgeDuration;
@dynamic maxBytes;

typedef struct GetConsensusParamsResponse_ConsensusParamsEvidence__storage_ {
  uint32_t _has_storage_[1];
  NSString *maxAgeNumBlocks;
  NSString *maxAgeDuration;
  NSString *maxBytes;
} GetConsensusParamsResponse_ConsensusParamsEvidence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxAgeNumBlocks",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsEvidence_FieldNumber_MaxAgeNumBlocks,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsEvidence__storage_, maxAgeNumBlocks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxAgeDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsEvidence_FieldNumber_MaxAgeDuration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsEvidence__storage_, maxAgeDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsResponse_ConsensusParamsEvidence_FieldNumber_MaxBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_ConsensusParamsEvidence__storage_, maxBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsResponse_ConsensusParamsEvidence class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsResponse_ConsensusParamsEvidence__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetConsensusParamsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConsensusParamsResponse_GetConsensusParamsResponseV0

@implementation GetConsensusParamsResponse_GetConsensusParamsResponseV0

@dynamic hasBlock, block;
@dynamic hasEvidence, evidence;

typedef struct GetConsensusParamsResponse_GetConsensusParamsResponseV0__storage_ {
  uint32_t _has_storage_[1];
  GetConsensusParamsResponse_ConsensusParamsBlock *block;
  GetConsensusParamsResponse_ConsensusParamsEvidence *evidence;
} GetConsensusParamsResponse_GetConsensusParamsResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(GetConsensusParamsResponse_ConsensusParamsBlock),
        .number = GetConsensusParamsResponse_GetConsensusParamsResponseV0_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_GetConsensusParamsResponseV0__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "evidence",
        .dataTypeSpecific.clazz = GPBObjCClass(GetConsensusParamsResponse_ConsensusParamsEvidence),
        .number = GetConsensusParamsResponse_GetConsensusParamsResponseV0_FieldNumber_Evidence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse_GetConsensusParamsResponseV0__storage_, evidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsResponse_GetConsensusParamsResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsResponse_GetConsensusParamsResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetConsensusParamsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeStateRequest

@implementation GetVersionUpgradeStateRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetVersionUpgradeStateRequest__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0 *v0;
} GetVersionUpgradeStateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0),
        .number = GetVersionUpgradeStateRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeStateRequest_ClearVersionOneOfCase(GetVersionUpgradeStateRequest *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeStateRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0

@implementation GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0

@dynamic prove;

typedef struct GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0__storage_ {
  uint32_t _has_storage_[1];
} GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateRequest_GetVersionUpgradeStateRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeStateRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeStateResponse

@implementation GetVersionUpgradeStateResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetVersionUpgradeStateResponse__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0 *v0;
} GetVersionUpgradeStateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0),
        .number = GetVersionUpgradeStateResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeStateResponse_ClearVersionOneOfCase(GetVersionUpgradeStateResponse *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeStateResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0

@implementation GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0

@dynamic resultOneOfCase;
@dynamic versions;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions *versions;
  Proof *proof;
  ResponseMetadata *metadata;
} GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions),
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_FieldNumber_Versions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_, versions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeStateResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_ClearResultOneOfCase(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0 *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions

@implementation GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions

@dynamic versionsArray, versionsArray_Count;

typedef struct GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *versionsArray;
} GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry),
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions_FieldNumber_VersionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions__storage_, versionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_Versions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry

@implementation GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry

@dynamic versionNumber;
@dynamic voteCount;

typedef struct GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry__storage_ {
  uint32_t _has_storage_[1];
  uint32_t versionNumber;
  uint32_t voteCount;
} GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versionNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry_FieldNumber_VersionNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry__storage_, versionNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry__storage_, voteCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0_VersionEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeStateResponse_GetVersionUpgradeStateResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeVoteStatusRequest

@implementation GetVersionUpgradeVoteStatusRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetVersionUpgradeVoteStatusRequest__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0 *v0;
} GetVersionUpgradeVoteStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0),
        .number = GetVersionUpgradeVoteStatusRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeVoteStatusRequest_ClearVersionOneOfCase(GetVersionUpgradeVoteStatusRequest *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeVoteStatusRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0

@implementation GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0

@dynamic startProTxHash;
@dynamic count;
@dynamic prove;

typedef struct GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSData *startProTxHash;
} GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startProTxHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0_FieldNumber_StartProTxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0__storage_, startProTxHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0_FieldNumber_Prove,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusRequest_GetVersionUpgradeVoteStatusRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeVoteStatusRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeVoteStatusResponse

@implementation GetVersionUpgradeVoteStatusResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetVersionUpgradeVoteStatusResponse__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0 *v0;
} GetVersionUpgradeVoteStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0),
        .number = GetVersionUpgradeVoteStatusResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeVoteStatusResponse_ClearVersionOneOfCase(GetVersionUpgradeVoteStatusResponse *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeVoteStatusResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0

@implementation GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0

@dynamic resultOneOfCase;
@dynamic versions;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals *versions;
  Proof *proof;
  ResponseMetadata *metadata;
} GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals),
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_FieldNumber_Versions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_, versions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeVoteStatusResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_ClearResultOneOfCase(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0 *message) {
  GPBDescriptor *descriptor = [GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals

@implementation GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals

@dynamic versionSignalsArray, versionSignalsArray_Count;

typedef struct GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *versionSignalsArray;
} GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versionSignalsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal),
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals_FieldNumber_VersionSignalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals__storage_, versionSignalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignals__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal

@implementation GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal

@dynamic proTxHash;
@dynamic version;

typedef struct GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
  NSData *proTxHash;
} GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proTxHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal_FieldNumber_ProTxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal__storage_, proTxHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0_VersionSignal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetVersionUpgradeVoteStatusResponse_GetVersionUpgradeVoteStatusResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEpochsInfoRequest

@implementation GetEpochsInfoRequest

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetEpochsInfoRequest__storage_ {
  uint32_t _has_storage_[2];
  GetEpochsInfoRequest_GetEpochsInfoRequestV0 *v0;
} GetEpochsInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetEpochsInfoRequest_GetEpochsInfoRequestV0),
        .number = GetEpochsInfoRequest_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetEpochsInfoRequest__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetEpochsInfoRequest_ClearVersionOneOfCase(GetEpochsInfoRequest *message) {
  GPBDescriptor *descriptor = [GetEpochsInfoRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetEpochsInfoRequest_GetEpochsInfoRequestV0

@implementation GetEpochsInfoRequest_GetEpochsInfoRequestV0

@dynamic hasStartEpoch, startEpoch;
@dynamic count;
@dynamic ascending;
@dynamic prove;

typedef struct GetEpochsInfoRequest_GetEpochsInfoRequestV0__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  GPBUInt32Value *startEpoch;
} GetEpochsInfoRequest_GetEpochsInfoRequestV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startEpoch",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetEpochsInfoRequest_GetEpochsInfoRequestV0_FieldNumber_StartEpoch,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEpochsInfoRequest_GetEpochsInfoRequestV0__storage_, startEpoch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoRequest_GetEpochsInfoRequestV0_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEpochsInfoRequest_GetEpochsInfoRequestV0__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ascending",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoRequest_GetEpochsInfoRequestV0_FieldNumber_Ascending,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoRequest_GetEpochsInfoRequestV0_FieldNumber_Prove,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoRequest_GetEpochsInfoRequestV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoRequest_GetEpochsInfoRequestV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetEpochsInfoRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEpochsInfoResponse

@implementation GetEpochsInfoResponse

@dynamic versionOneOfCase;
@dynamic v0;

typedef struct GetEpochsInfoResponse__storage_ {
  uint32_t _has_storage_[2];
  GetEpochsInfoResponse_GetEpochsInfoResponseV0 *v0;
} GetEpochsInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "v0",
        .dataTypeSpecific.clazz = GPBObjCClass(GetEpochsInfoResponse_GetEpochsInfoResponseV0),
        .number = GetEpochsInfoResponse_FieldNumber_V0,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse__storage_, v0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "version",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetEpochsInfoResponse_ClearVersionOneOfCase(GetEpochsInfoResponse *message) {
  GPBDescriptor *descriptor = [GetEpochsInfoResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetEpochsInfoResponse_GetEpochsInfoResponseV0

@implementation GetEpochsInfoResponse_GetEpochsInfoResponseV0

@dynamic resultOneOfCase;
@dynamic epochs;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_ {
  uint32_t _has_storage_[2];
  GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos *epochs;
  Proof *proof;
  ResponseMetadata *metadata;
} GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "epochs",
        .dataTypeSpecific.clazz = GPBObjCClass(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos),
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_FieldNumber_Epochs,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_, epochs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoResponse_GetEpochsInfoResponseV0 class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoResponse_GetEpochsInfoResponseV0__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetEpochsInfoResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetEpochsInfoResponse_GetEpochsInfoResponseV0_ClearResultOneOfCase(GetEpochsInfoResponse_GetEpochsInfoResponseV0 *message) {
  GPBDescriptor *descriptor = [GetEpochsInfoResponse_GetEpochsInfoResponseV0 descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos

@implementation GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos

@dynamic epochInfosArray, epochInfosArray_Count;

typedef struct GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *epochInfosArray;
} GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "epochInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo),
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos_FieldNumber_EpochInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos__storage_, epochInfosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfos__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetEpochsInfoResponse_GetEpochsInfoResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo

@implementation GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo

@dynamic number;
@dynamic firstBlockHeight;
@dynamic firstCoreBlockHeight;
@dynamic startTime;
@dynamic feeMultiplier;

typedef struct GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t number;
  uint32_t firstCoreBlockHeight;
  uint64_t firstBlockHeight;
  uint64_t startTime;
  double feeMultiplier;
} GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo_FieldNumber_Number,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "firstBlockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo_FieldNumber_FirstBlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_, firstBlockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "firstCoreBlockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo_FieldNumber_FirstCoreBlockHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_, firstCoreBlockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "feeMultiplier",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo_FieldNumber_FeeMultiplier,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_, feeMultiplier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEpochsInfoResponse_GetEpochsInfoResponseV0_EpochInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetEpochsInfoResponse_GetEpochsInfoResponseV0)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
