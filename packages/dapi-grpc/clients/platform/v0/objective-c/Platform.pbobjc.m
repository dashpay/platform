// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: platform.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Platform.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AllKeys);
GPBObjCClassDeclaration(ConsensusParamsBlock);
GPBObjCClassDeclaration(ConsensusParamsEvidence);
GPBObjCClassDeclaration(GPBUInt32Value);
GPBObjCClassDeclaration(GPBUInt64Value);
GPBObjCClassDeclaration(GetDataContractHistoryResponse);
GPBObjCClassDeclaration(GetDataContractHistoryResponse_DataContractHistory);
GPBObjCClassDeclaration(GetDataContractHistoryResponse_DataContractHistoryEntry);
GPBObjCClassDeclaration(GetDataContractsResponse);
GPBObjCClassDeclaration(GetDataContractsResponse_DataContractEntry);
GPBObjCClassDeclaration(GetDataContractsResponse_DataContractValue);
GPBObjCClassDeclaration(GetDataContractsResponse_DataContracts);
GPBObjCClassDeclaration(GetDocumentsResponse);
GPBObjCClassDeclaration(GetDocumentsResponse_Documents);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse);
GPBObjCClassDeclaration(GetIdentitiesByPublicKeyHashesResponse_Identities);
GPBObjCClassDeclaration(GetIdentitiesKeysRequest);
GPBObjCClassDeclaration(GetIdentitiesKeysRequest_SecurityLevelMap);
GPBObjCClassDeclaration(GetIdentitiesKeysResponse);
GPBObjCClassDeclaration(GetIdentitiesKeysResponse_PublicKey);
GPBObjCClassDeclaration(GetIdentitiesKeysResponse_PublicKeyEntries);
GPBObjCClassDeclaration(GetIdentitiesKeysResponse_PublicKeyEntry);
GPBObjCClassDeclaration(GetIdentitiesResponse);
GPBObjCClassDeclaration(GetIdentitiesResponse_Identities);
GPBObjCClassDeclaration(GetIdentitiesResponse_IdentityEntry);
GPBObjCClassDeclaration(GetIdentitiesResponse_IdentityValue);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionResponse);
GPBObjCClassDeclaration(GetIdentityBalanceAndRevisionResponse_BalanceAndRevision);
GPBObjCClassDeclaration(GetIdentityKeysResponse);
GPBObjCClassDeclaration(GetIdentityKeysResponse_Keys);
GPBObjCClassDeclaration(GetProofsRequest);
GPBObjCClassDeclaration(GetProofsRequest_ContractRequest);
GPBObjCClassDeclaration(GetProofsRequest_DocumentRequest);
GPBObjCClassDeclaration(GetProofsRequest_IdentityRequest);
GPBObjCClassDeclaration(KeyRequestType);
GPBObjCClassDeclaration(Proof);
GPBObjCClassDeclaration(ResponseMetadata);
GPBObjCClassDeclaration(SearchKey);
GPBObjCClassDeclaration(SecurityLevelMap);
GPBObjCClassDeclaration(SpecificKeys);
GPBObjCClassDeclaration(StateTransitionBroadcastError);

#pragma mark - PlatformRoot

@implementation PlatformRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - PlatformRoot_FileDescriptor

static GPBFileDescriptor *PlatformRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"org.dash.platform.dapi.v0"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Proof

@implementation Proof

@dynamic grovedbProof;
@dynamic quorumHash;
@dynamic signature;
@dynamic round;
@dynamic blockIdHash;
@dynamic quorumType;

typedef struct Proof__storage_ {
  uint32_t _has_storage_[1];
  uint32_t round;
  uint32_t quorumType;
  NSData *grovedbProof;
  NSData *quorumHash;
  NSData *signature;
  NSData *blockIdHash;
} Proof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "grovedbProof",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_GrovedbProof,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Proof__storage_, grovedbProof),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "quorumHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_QuorumHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Proof__storage_, quorumHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_Signature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Proof__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_Round,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Proof__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockIdHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_BlockIdHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Proof__storage_, blockIdHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "quorumType",
        .dataTypeSpecific.clazz = Nil,
        .number = Proof_FieldNumber_QuorumType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Proof__storage_, quorumType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Proof class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMetadata

@implementation ResponseMetadata

@dynamic height;
@dynamic coreChainLockedHeight;
@dynamic timeMs;
@dynamic protocolVersion;
@dynamic chainId;

typedef struct ResponseMetadata__storage_ {
  uint32_t _has_storage_[1];
  uint32_t coreChainLockedHeight;
  uint32_t protocolVersion;
  NSString *chainId;
  uint64_t height;
  uint64_t timeMs;
} ResponseMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coreChainLockedHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_CoreChainLockedHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, coreChainLockedHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeMs",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_TimeMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, timeMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "protocolVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_ProtocolVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, protocolVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMetadata_FieldNumber_ChainId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseMetadata__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMetadata class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMetadata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StateTransitionBroadcastError

@implementation StateTransitionBroadcastError

@dynamic code;
@dynamic message;
@dynamic data_p;

typedef struct StateTransitionBroadcastError__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *message;
  NSData *data_p;
} StateTransitionBroadcastError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = StateTransitionBroadcastError_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StateTransitionBroadcastError__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StateTransitionBroadcastError class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StateTransitionBroadcastError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastStateTransitionRequest

@implementation BroadcastStateTransitionRequest

@dynamic stateTransition;

typedef struct BroadcastStateTransitionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *stateTransition;
} BroadcastStateTransitionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateTransition",
        .dataTypeSpecific.clazz = Nil,
        .number = BroadcastStateTransitionRequest_FieldNumber_StateTransition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastStateTransitionRequest__storage_, stateTransition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastStateTransitionRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastStateTransitionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastStateTransitionResponse

@implementation BroadcastStateTransitionResponse


typedef struct BroadcastStateTransitionResponse__storage_ {
  uint32_t _has_storage_[1];
} BroadcastStateTransitionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastStateTransitionResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BroadcastStateTransitionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityRequest

@implementation GetIdentityRequest

@dynamic id_p;
@dynamic prove;

typedef struct GetIdentityRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetIdentityRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityRequest_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityResponse

@implementation GetIdentityResponse

@dynamic resultOneOfCase;
@dynamic identity;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityResponse__storage_ {
  uint32_t _has_storage_[2];
  NSData *identity;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityResponse_FieldNumber_Identity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityResponse__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityResponse_ClearResultOneOfCase(GetIdentityResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesRequest

@implementation GetIdentitiesRequest

@dynamic idsArray, idsArray_Count;
@dynamic prove;

typedef struct GetIdentitiesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
} GetIdentitiesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesRequest_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesRequest__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesRequest_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse

@implementation GetIdentitiesResponse

@dynamic resultOneOfCase;
@dynamic identities;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentitiesResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesResponse_Identities *identities;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentitiesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identities",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_Identities),
        .number = GetIdentitiesResponse_FieldNumber_Identities,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse__storage_, identities),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentitiesResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentitiesResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesResponse_ClearResultOneOfCase(GetIdentitiesResponse *message) {
  GPBDescriptor *descriptor = [GetIdentitiesResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesResponse_IdentityValue

@implementation GetIdentitiesResponse_IdentityValue

@dynamic value;

typedef struct GetIdentitiesResponse_IdentityValue__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} GetIdentitiesResponse_IdentityValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesResponse_IdentityValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityValue__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_IdentityValue class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_IdentityValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse_IdentityEntry

@implementation GetIdentitiesResponse_IdentityEntry

@dynamic key;
@dynamic hasValue, value;

typedef struct GetIdentitiesResponse_IdentityEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  GetIdentitiesResponse_IdentityValue *value;
} GetIdentitiesResponse_IdentityEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesResponse_IdentityEntry_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityEntry__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_IdentityValue),
        .number = GetIdentitiesResponse_IdentityEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_IdentityEntry__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_IdentityEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_IdentityEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesResponse_Identities

@implementation GetIdentitiesResponse_Identities

@dynamic identityEntriesArray, identityEntriesArray_Count;

typedef struct GetIdentitiesResponse_Identities__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identityEntriesArray;
} GetIdentitiesResponse_Identities__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesResponse_IdentityEntry),
        .number = GetIdentitiesResponse_Identities_FieldNumber_IdentityEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesResponse_Identities__storage_, identityEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesResponse_Identities class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesResponse_Identities__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityBalanceResponse

@implementation GetIdentityBalanceResponse

@dynamic resultOneOfCase;
@dynamic balance;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityBalanceResponse__storage_ {
  uint32_t _has_storage_[2];
  GPBUInt64Value *balance;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt64Value),
        .number = GetIdentityBalanceResponse_FieldNumber_Balance,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityBalanceResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityBalanceResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceResponse_ClearResultOneOfCase(GetIdentityBalanceResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionResponse

@implementation GetIdentityBalanceAndRevisionResponse

@dynamic resultOneOfCase;
@dynamic balanceAndRevision;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityBalanceAndRevisionResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityBalanceAndRevisionResponse_BalanceAndRevision *balanceAndRevision;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityBalanceAndRevisionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balanceAndRevision",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityBalanceAndRevisionResponse_BalanceAndRevision),
        .number = GetIdentityBalanceAndRevisionResponse_FieldNumber_BalanceAndRevision,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse__storage_, balanceAndRevision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityBalanceAndRevisionResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityBalanceAndRevisionResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityBalanceAndRevisionResponse_ClearResultOneOfCase(GetIdentityBalanceAndRevisionResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityBalanceAndRevisionResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityBalanceAndRevisionResponse_BalanceAndRevision

@implementation GetIdentityBalanceAndRevisionResponse_BalanceAndRevision

@dynamic hasBalance, balance;
@dynamic hasRevision, revision;

typedef struct GetIdentityBalanceAndRevisionResponse_BalanceAndRevision__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Value *balance;
  GPBUInt64Value *revision;
} GetIdentityBalanceAndRevisionResponse_BalanceAndRevision__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt64Value),
        .number = GetIdentityBalanceAndRevisionResponse_BalanceAndRevision_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_BalanceAndRevision__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt64Value),
        .number = GetIdentityBalanceAndRevisionResponse_BalanceAndRevision_FieldNumber_Revision,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentityBalanceAndRevisionResponse_BalanceAndRevision__storage_, revision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityBalanceAndRevisionResponse_BalanceAndRevision class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityBalanceAndRevisionResponse_BalanceAndRevision__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityBalanceAndRevisionResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyRequestType

@implementation KeyRequestType

@dynamic requestOneOfCase;
@dynamic allKeys;
@dynamic specificKeys;
@dynamic searchKey;

typedef struct KeyRequestType__storage_ {
  uint32_t _has_storage_[2];
  AllKeys *allKeys;
  SpecificKeys *specificKeys;
  SearchKey *searchKey;
} KeyRequestType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allKeys",
        .dataTypeSpecific.clazz = GPBObjCClass(AllKeys),
        .number = KeyRequestType_FieldNumber_AllKeys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, allKeys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "specificKeys",
        .dataTypeSpecific.clazz = GPBObjCClass(SpecificKeys),
        .number = KeyRequestType_FieldNumber_SpecificKeys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, specificKeys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchKey",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchKey),
        .number = KeyRequestType_FieldNumber_SearchKey,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(KeyRequestType__storage_, searchKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyRequestType class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyRequestType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "request",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void KeyRequestType_ClearRequestOneOfCase(KeyRequestType *message) {
  GPBDescriptor *descriptor = [KeyRequestType descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - AllKeys

@implementation AllKeys


typedef struct AllKeys__storage_ {
  uint32_t _has_storage_[1];
} AllKeys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllKeys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AllKeys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpecificKeys

@implementation SpecificKeys

@dynamic keyIdsArray, keyIdsArray_Count;

typedef struct SpecificKeys__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *keyIdsArray;
} SpecificKeys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SpecificKeys_FieldNumber_KeyIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SpecificKeys__storage_, keyIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpecificKeys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpecificKeys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchKey

@implementation SearchKey

@dynamic purposeMap, purposeMap_Count;

typedef struct SearchKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32ObjectDictionary *purposeMap;
} SearchKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "purposeMap",
        .dataTypeSpecific.clazz = GPBObjCClass(SecurityLevelMap),
        .number = SearchKey_FieldNumber_PurposeMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchKey__storage_, purposeMap),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchKey class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SecurityLevelMap

@implementation SecurityLevelMap

@dynamic securityLevelMap, securityLevelMap_Count;

typedef struct SecurityLevelMap__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32EnumDictionary *securityLevelMap;
} SecurityLevelMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "securityLevelMap",
        .dataTypeSpecific.enumDescFunc = SecurityLevelMap_KeyKindRequestType_EnumDescriptor,
        .number = SecurityLevelMap_FieldNumber_SecurityLevelMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SecurityLevelMap__storage_, securityLevelMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyUInt32 | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SecurityLevelMap class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SecurityLevelMap__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SecurityLevelMap_KeyKindRequestType

GPBEnumDescriptor *SecurityLevelMap_KeyKindRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CurrentKeyOfKindRequest\000AllKeysOfKindReq"
        "uest\000";
    static const int32_t values[] = {
        SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest,
        SecurityLevelMap_KeyKindRequestType_AllKeysOfKindRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SecurityLevelMap_KeyKindRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SecurityLevelMap_KeyKindRequestType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SecurityLevelMap_KeyKindRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest:
    case SecurityLevelMap_KeyKindRequestType_AllKeysOfKindRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetIdentityKeysRequest

@implementation GetIdentityKeysRequest

@dynamic identityId;
@dynamic hasRequestType, requestType;
@dynamic hasLimit, limit;
@dynamic hasOffset, offset;
@dynamic prove;

typedef struct GetIdentityKeysRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *identityId;
  KeyRequestType *requestType;
  GPBUInt32Value *limit;
  GPBUInt32Value *offset;
} GetIdentityKeysRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysRequest_FieldNumber_IdentityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest__storage_, identityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "requestType",
        .dataTypeSpecific.clazz = GPBObjCClass(KeyRequestType),
        .number = GetIdentityKeysRequest_FieldNumber_RequestType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest__storage_, requestType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentityKeysRequest_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentityKeysRequest_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetIdentityKeysRequest__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysRequest_FieldNumber_Prove,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityKeysResponse

@implementation GetIdentityKeysResponse

@dynamic resultOneOfCase;
@dynamic keys;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityKeysResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentityKeysResponse_Keys *keys;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityKeysResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keys",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentityKeysResponse_Keys),
        .number = GetIdentityKeysResponse_FieldNumber_Keys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse__storage_, keys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityKeysResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityKeysResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityKeysResponse_ClearResultOneOfCase(GetIdentityKeysResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityKeysResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentityKeysResponse_Keys

@implementation GetIdentityKeysResponse_Keys

@dynamic keysBytesArray, keysBytesArray_Count;

typedef struct GetIdentityKeysResponse_Keys__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysBytesArray;
} GetIdentityKeysResponse_Keys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysBytesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityKeysResponse_Keys_FieldNumber_KeysBytesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentityKeysResponse_Keys__storage_, keysBytesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityKeysResponse_Keys class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityKeysResponse_Keys__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentityKeysResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesKeysRequest

@implementation GetIdentitiesKeysRequest

@dynamic identityIdsArray, identityIdsArray_Count;
@dynamic hasRequestType, requestType;
@dynamic hasLimit, limit;
@dynamic hasOffset, offset;
@dynamic prove;

typedef struct GetIdentitiesKeysRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identityIdsArray;
  KeyRequestType *requestType;
  GPBUInt32Value *limit;
  GPBUInt32Value *offset;
} GetIdentitiesKeysRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesKeysRequest_FieldNumber_IdentityIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysRequest__storage_, identityIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "requestType",
        .dataTypeSpecific.clazz = GPBObjCClass(KeyRequestType),
        .number = GetIdentitiesKeysRequest_FieldNumber_RequestType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysRequest__storage_, requestType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentitiesKeysRequest_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetIdentitiesKeysRequest_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysRequest__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesKeysRequest_FieldNumber_Prove,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesKeysRequest_SecurityLevelMap

@implementation GetIdentitiesKeysRequest_SecurityLevelMap

@dynamic securityLevelMap, securityLevelMap_Count;

typedef struct GetIdentitiesKeysRequest_SecurityLevelMap__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32EnumDictionary *securityLevelMap;
} GetIdentitiesKeysRequest_SecurityLevelMap__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "securityLevelMap",
        .dataTypeSpecific.enumDescFunc = GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_EnumDescriptor,
        .number = GetIdentitiesKeysRequest_SecurityLevelMap_FieldNumber_SecurityLevelMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysRequest_SecurityLevelMap__storage_, securityLevelMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyUInt32 | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysRequest_SecurityLevelMap class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysRequest_SecurityLevelMap__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesKeysRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType

GPBEnumDescriptor *GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CurrentKeyOfKindRequest\000";
    static const int32_t values[] = {
        GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetIdentitiesKeysRequest_SecurityLevelMap_KeyKindRequestType_CurrentKeyOfKindRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetIdentitiesKeysResponse

@implementation GetIdentitiesKeysResponse

@dynamic resultOneOfCase;
@dynamic publicKeys;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentitiesKeysResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesKeysResponse_PublicKeyEntries *publicKeys;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentitiesKeysResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeys",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesKeysResponse_PublicKeyEntries),
        .number = GetIdentitiesKeysResponse_FieldNumber_PublicKeys,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse__storage_, publicKeys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentitiesKeysResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentitiesKeysResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesKeysResponse_ClearResultOneOfCase(GetIdentitiesKeysResponse *message) {
  GPBDescriptor *descriptor = [GetIdentitiesKeysResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesKeysResponse_PublicKey

@implementation GetIdentitiesKeysResponse_PublicKey

@dynamic value;

typedef struct GetIdentitiesKeysResponse_PublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} GetIdentitiesKeysResponse_PublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesKeysResponse_PublicKey_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse_PublicKey__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysResponse_PublicKey class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysResponse_PublicKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesKeysResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesKeysResponse_PublicKeyEntry

@implementation GetIdentitiesKeysResponse_PublicKeyEntry

@dynamic key;
@dynamic hasValue, value;

typedef struct GetIdentitiesKeysResponse_PublicKeyEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  GetIdentitiesKeysResponse_PublicKey *value;
} GetIdentitiesKeysResponse_PublicKeyEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesKeysResponse_PublicKeyEntry_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse_PublicKeyEntry__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesKeysResponse_PublicKey),
        .number = GetIdentitiesKeysResponse_PublicKeyEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse_PublicKeyEntry__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysResponse_PublicKeyEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysResponse_PublicKeyEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesKeysResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesKeysResponse_PublicKeyEntries

@implementation GetIdentitiesKeysResponse_PublicKeyEntries

@dynamic publicKeyEntriesArray, publicKeyEntriesArray_Count;

typedef struct GetIdentitiesKeysResponse_PublicKeyEntries__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *publicKeyEntriesArray;
} GetIdentitiesKeysResponse_PublicKeyEntries__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesKeysResponse_PublicKeyEntry),
        .number = GetIdentitiesKeysResponse_PublicKeyEntries_FieldNumber_PublicKeyEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesKeysResponse_PublicKeyEntries__storage_, publicKeyEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesKeysResponse_PublicKeyEntries class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesKeysResponse_PublicKeyEntries__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesKeysResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest

@implementation GetProofsRequest

@dynamic identitiesArray, identitiesArray_Count;
@dynamic contractsArray, contractsArray_Count;
@dynamic documentsArray, documentsArray_Count;

typedef struct GetProofsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identitiesArray;
  NSMutableArray *contractsArray;
  NSMutableArray *documentsArray;
} GetProofsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identitiesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_IdentityRequest),
        .number = GetProofsRequest_FieldNumber_IdentitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest__storage_, identitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_ContractRequest),
        .number = GetProofsRequest_FieldNumber_ContractsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest__storage_, contractsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "documentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetProofsRequest_DocumentRequest),
        .number = GetProofsRequest_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetProofsRequest__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest_DocumentRequest

@implementation GetProofsRequest_DocumentRequest

@dynamic contractId;
@dynamic documentType;
@dynamic documentTypeKeepsHistory;
@dynamic documentId;

typedef struct GetProofsRequest_DocumentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *contractId;
  NSString *documentType;
  NSData *documentId;
} GetProofsRequest_DocumentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_DocumentRequest_FieldNumber_ContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_DocumentRequest__storage_, contractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "documentType",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_DocumentRequest_FieldNumber_DocumentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsRequest_DocumentRequest__storage_, documentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "documentTypeKeepsHistory",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_DocumentRequest_FieldNumber_DocumentTypeKeepsHistory,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "documentId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_DocumentRequest_FieldNumber_DocumentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetProofsRequest_DocumentRequest__storage_, documentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_DocumentRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_DocumentRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsRequest_IdentityRequest

@implementation GetProofsRequest_IdentityRequest

@dynamic identityId;
@dynamic requestType;

typedef struct GetProofsRequest_IdentityRequest__storage_ {
  uint32_t _has_storage_[1];
  GetProofsRequest_IdentityRequest_Type requestType;
  NSData *identityId;
} GetProofsRequest_IdentityRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_IdentityRequest_FieldNumber_IdentityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_IdentityRequest__storage_, identityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "requestType",
        .dataTypeSpecific.enumDescFunc = GetProofsRequest_IdentityRequest_Type_EnumDescriptor,
        .number = GetProofsRequest_IdentityRequest_FieldNumber_RequestType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsRequest_IdentityRequest__storage_, requestType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_IdentityRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_IdentityRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetProofsRequest_IdentityRequest_RequestType_RawValue(GetProofsRequest_IdentityRequest *message) {
  GPBDescriptor *descriptor = [GetProofsRequest_IdentityRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetProofsRequest_IdentityRequest_FieldNumber_RequestType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGetProofsRequest_IdentityRequest_RequestType_RawValue(GetProofsRequest_IdentityRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GetProofsRequest_IdentityRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetProofsRequest_IdentityRequest_FieldNumber_RequestType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum GetProofsRequest_IdentityRequest_Type

GPBEnumDescriptor *GetProofsRequest_IdentityRequest_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FullIdentity\000Balance\000Keys\000";
    static const int32_t values[] = {
        GetProofsRequest_IdentityRequest_Type_FullIdentity,
        GetProofsRequest_IdentityRequest_Type_Balance,
        GetProofsRequest_IdentityRequest_Type_Keys,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetProofsRequest_IdentityRequest_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetProofsRequest_IdentityRequest_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetProofsRequest_IdentityRequest_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetProofsRequest_IdentityRequest_Type_FullIdentity:
    case GetProofsRequest_IdentityRequest_Type_Balance:
    case GetProofsRequest_IdentityRequest_Type_Keys:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetProofsRequest_ContractRequest

@implementation GetProofsRequest_ContractRequest

@dynamic contractId;

typedef struct GetProofsRequest_ContractRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *contractId;
} GetProofsRequest_ContractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetProofsRequest_ContractRequest_FieldNumber_ContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsRequest_ContractRequest__storage_, contractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsRequest_ContractRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsRequest_ContractRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetProofsRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProofsResponse

@implementation GetProofsResponse

@dynamic hasProof, proof;
@dynamic hasMetadata, metadata;

typedef struct GetProofsResponse__storage_ {
  uint32_t _has_storage_[1];
  Proof *proof;
  ResponseMetadata *metadata;
} GetProofsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetProofsResponse_FieldNumber_Proof,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProofsResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetProofsResponse_FieldNumber_Metadata,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProofsResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProofsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProofsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractRequest

@implementation GetDataContractRequest

@dynamic id_p;
@dynamic prove;

typedef struct GetDataContractRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
} GetDataContractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractRequest_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractResponse

@implementation GetDataContractResponse

@dynamic resultOneOfCase;
@dynamic dataContract;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractResponse__storage_ {
  uint32_t _has_storage_[2];
  NSData *dataContract;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContract",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractResponse_FieldNumber_DataContract,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractResponse__storage_, dataContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractResponse_ClearResultOneOfCase(GetDataContractResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractsRequest

@implementation GetDataContractsRequest

@dynamic idsArray, idsArray_Count;
@dynamic prove;

typedef struct GetDataContractsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
} GetDataContractsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsRequest_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractsRequest__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsRequest_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse

@implementation GetDataContractsResponse

@dynamic resultOneOfCase;
@dynamic dataContracts;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractsResponse_DataContracts *dataContracts;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContracts",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_DataContracts),
        .number = GetDataContractsResponse_FieldNumber_DataContracts,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse__storage_, dataContracts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractsResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractsResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractsResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractsResponse_ClearResultOneOfCase(GetDataContractsResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractsResponse_DataContractValue

@implementation GetDataContractsResponse_DataContractValue

@dynamic value;

typedef struct GetDataContractsResponse_DataContractValue__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} GetDataContractsResponse_DataContractValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsResponse_DataContractValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContractValue__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_DataContractValue class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_DataContractValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse_DataContractEntry

@implementation GetDataContractsResponse_DataContractEntry

@dynamic key;
@dynamic hasValue, value;

typedef struct GetDataContractsResponse_DataContractEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  GetDataContractsResponse_DataContractValue *value;
} GetDataContractsResponse_DataContractEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractsResponse_DataContractEntry_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContractEntry__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_DataContractValue),
        .number = GetDataContractsResponse_DataContractEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContractEntry__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_DataContractEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_DataContractEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractsResponse_DataContracts

@implementation GetDataContractsResponse_DataContracts

@dynamic dataContractEntriesArray, dataContractEntriesArray_Count;

typedef struct GetDataContractsResponse_DataContracts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataContractEntriesArray;
} GetDataContractsResponse_DataContracts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractsResponse_DataContractEntry),
        .number = GetDataContractsResponse_DataContracts_FieldNumber_DataContractEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractsResponse_DataContracts__storage_, dataContractEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractsResponse_DataContracts class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractsResponse_DataContracts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractHistoryRequest

@implementation GetDataContractHistoryRequest

@dynamic id_p;
@dynamic hasLimit, limit;
@dynamic hasOffset, offset;
@dynamic startAtMs;
@dynamic prove;

typedef struct GetDataContractHistoryRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
  GPBUInt32Value *limit;
  GPBUInt32Value *offset;
  uint64_t startAtMs;
} GetDataContractHistoryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetDataContractHistoryRequest_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBUInt32Value),
        .number = GetDataContractHistoryRequest_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startAtMs",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_FieldNumber_StartAtMs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetDataContractHistoryRequest__storage_, startAtMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryRequest_FieldNumber_Prove,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractHistoryResponse

@implementation GetDataContractHistoryResponse

@dynamic resultOneOfCase;
@dynamic dataContractHistory;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDataContractHistoryResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDataContractHistoryResponse_DataContractHistory *dataContractHistory;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDataContractHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractHistory",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryResponse_DataContractHistory),
        .number = GetDataContractHistoryResponse_FieldNumber_DataContractHistory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse__storage_, dataContractHistory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDataContractHistoryResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDataContractHistoryResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDataContractHistoryResponse_ClearResultOneOfCase(GetDataContractHistoryResponse *message) {
  GPBDescriptor *descriptor = [GetDataContractHistoryResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDataContractHistoryResponse_DataContractHistoryEntry

@implementation GetDataContractHistoryResponse_DataContractHistoryEntry

@dynamic date;
@dynamic value;

typedef struct GetDataContractHistoryResponse_DataContractHistoryEntry__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
  uint64_t date;
} GetDataContractHistoryResponse_DataContractHistoryEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryResponse_DataContractHistoryEntry_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_DataContractHistoryEntry__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDataContractHistoryResponse_DataContractHistoryEntry_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_DataContractHistoryEntry__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse_DataContractHistoryEntry class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse_DataContractHistoryEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDataContractHistoryResponse_DataContractHistory

@implementation GetDataContractHistoryResponse_DataContractHistory

@dynamic dataContractEntriesArray, dataContractEntriesArray_Count;

typedef struct GetDataContractHistoryResponse_DataContractHistory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataContractEntriesArray;
} GetDataContractHistoryResponse_DataContractHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractEntriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDataContractHistoryResponse_DataContractHistoryEntry),
        .number = GetDataContractHistoryResponse_DataContractHistory_FieldNumber_DataContractEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDataContractHistoryResponse_DataContractHistory__storage_, dataContractEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDataContractHistoryResponse_DataContractHistory class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDataContractHistoryResponse_DataContractHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDataContractHistoryResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDocumentsRequest

@implementation GetDocumentsRequest

@dynamic startOneOfCase;
@dynamic dataContractId;
@dynamic documentType;
@dynamic where;
@dynamic orderBy;
@dynamic limit;
@dynamic startAfter;
@dynamic startAt;
@dynamic prove;

typedef struct GetDocumentsRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t limit;
  NSData *dataContractId;
  NSString *documentType;
  NSData *where;
  NSData *orderBy;
  NSData *startAfter;
  NSData *startAt;
} GetDocumentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataContractId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_DataContractId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, dataContractId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "documentType",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_DocumentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, documentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "where",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_Where,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, where),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "orderBy",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_OrderBy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, orderBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_Limit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startAfter",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_StartAfter,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, startAfter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "startAt",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_StartAt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsRequest__storage_, startAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsRequest_FieldNumber_Prove,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "start",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsRequest_ClearStartOneOfCase(GetDocumentsRequest *message) {
  GPBDescriptor *descriptor = [GetDocumentsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsResponse

@implementation GetDocumentsResponse

@dynamic resultOneOfCase;
@dynamic documents;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetDocumentsResponse__storage_ {
  uint32_t _has_storage_[2];
  GetDocumentsResponse_Documents *documents;
  Proof *proof;
  ResponseMetadata *metadata;
} GetDocumentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documents",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDocumentsResponse_Documents),
        .number = GetDocumentsResponse_FieldNumber_Documents,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsResponse__storage_, documents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetDocumentsResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDocumentsResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetDocumentsResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDocumentsResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDocumentsResponse_ClearResultOneOfCase(GetDocumentsResponse *message) {
  GPBDescriptor *descriptor = [GetDocumentsResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetDocumentsResponse_Documents

@implementation GetDocumentsResponse_Documents

@dynamic documentsArray, documentsArray_Count;

typedef struct GetDocumentsResponse_Documents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *documentsArray;
} GetDocumentsResponse_Documents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "documentsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetDocumentsResponse_Documents_FieldNumber_DocumentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDocumentsResponse_Documents__storage_, documentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDocumentsResponse_Documents class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDocumentsResponse_Documents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetDocumentsResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesRequest

@implementation GetIdentitiesByPublicKeyHashesRequest

@dynamic publicKeyHashesArray, publicKeyHashesArray_Count;
@dynamic prove;

typedef struct GetIdentitiesByPublicKeyHashesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *publicKeyHashesArray;
} GetIdentitiesByPublicKeyHashesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyHashesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesRequest_FieldNumber_PublicKeyHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesRequest__storage_, publicKeyHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesRequest_FieldNumber_Prove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentitiesByPublicKeyHashesResponse

@implementation GetIdentitiesByPublicKeyHashesResponse

@dynamic resultOneOfCase;
@dynamic identities;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentitiesByPublicKeyHashesResponse__storage_ {
  uint32_t _has_storage_[2];
  GetIdentitiesByPublicKeyHashesResponse_Identities *identities;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentitiesByPublicKeyHashesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identities",
        .dataTypeSpecific.clazz = GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse_Identities),
        .number = GetIdentitiesByPublicKeyHashesResponse_FieldNumber_Identities,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse__storage_, identities),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentitiesByPublicKeyHashesResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentitiesByPublicKeyHashesResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentitiesByPublicKeyHashesResponse_ClearResultOneOfCase(GetIdentitiesByPublicKeyHashesResponse *message) {
  GPBDescriptor *descriptor = [GetIdentitiesByPublicKeyHashesResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetIdentitiesByPublicKeyHashesResponse_Identities

@implementation GetIdentitiesByPublicKeyHashesResponse_Identities

@dynamic identitiesArray, identitiesArray_Count;

typedef struct GetIdentitiesByPublicKeyHashesResponse_Identities__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identitiesArray;
} GetIdentitiesByPublicKeyHashesResponse_Identities__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identitiesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentitiesByPublicKeyHashesResponse_Identities_FieldNumber_IdentitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetIdentitiesByPublicKeyHashesResponse_Identities__storage_, identitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentitiesByPublicKeyHashesResponse_Identities class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentitiesByPublicKeyHashesResponse_Identities__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetIdentitiesByPublicKeyHashesResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityByPublicKeyHashesRequest

@implementation GetIdentityByPublicKeyHashesRequest

@dynamic publicKeyHash;
@dynamic prove;

typedef struct GetIdentityByPublicKeyHashesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKeyHash;
} GetIdentityByPublicKeyHashesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKeyHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashesRequest_FieldNumber_PublicKeyHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashesRequest__storage_, publicKeyHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashesRequest_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashesRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashesRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIdentityByPublicKeyHashesResponse

@implementation GetIdentityByPublicKeyHashesResponse

@dynamic resultOneOfCase;
@dynamic identity;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct GetIdentityByPublicKeyHashesResponse__storage_ {
  uint32_t _has_storage_[2];
  NSData *identity;
  Proof *proof;
  ResponseMetadata *metadata;
} GetIdentityByPublicKeyHashesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.clazz = Nil,
        .number = GetIdentityByPublicKeyHashesResponse_FieldNumber_Identity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashesResponse__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = GetIdentityByPublicKeyHashesResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashesResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = GetIdentityByPublicKeyHashesResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIdentityByPublicKeyHashesResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIdentityByPublicKeyHashesResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIdentityByPublicKeyHashesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetIdentityByPublicKeyHashesResponse_ClearResultOneOfCase(GetIdentityByPublicKeyHashesResponse *message) {
  GPBDescriptor *descriptor = [GetIdentityByPublicKeyHashesResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - WaitForStateTransitionResultRequest

@implementation WaitForStateTransitionResultRequest

@dynamic stateTransitionHash;
@dynamic prove;

typedef struct WaitForStateTransitionResultRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *stateTransitionHash;
} WaitForStateTransitionResultRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateTransitionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = WaitForStateTransitionResultRequest_FieldNumber_StateTransitionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultRequest__storage_, stateTransitionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = WaitForStateTransitionResultRequest_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WaitForStateTransitionResultResponse

@implementation WaitForStateTransitionResultResponse

@dynamic resultOneOfCase;
@dynamic error;
@dynamic proof;
@dynamic hasMetadata, metadata;

typedef struct WaitForStateTransitionResultResponse__storage_ {
  uint32_t _has_storage_[2];
  StateTransitionBroadcastError *error;
  Proof *proof;
  ResponseMetadata *metadata;
} WaitForStateTransitionResultResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.clazz = GPBObjCClass(StateTransitionBroadcastError),
        .number = WaitForStateTransitionResultResponse_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = WaitForStateTransitionResultResponse_FieldNumber_Proof,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseMetadata),
        .number = WaitForStateTransitionResultResponse_FieldNumber_Metadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WaitForStateTransitionResultResponse__storage_, metadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitForStateTransitionResultResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitForStateTransitionResultResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void WaitForStateTransitionResultResponse_ClearResultOneOfCase(WaitForStateTransitionResultResponse *message) {
  GPBDescriptor *descriptor = [WaitForStateTransitionResultResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ConsensusParamsBlock

@implementation ConsensusParamsBlock

@dynamic maxBytes;
@dynamic maxGas;
@dynamic timeIotaMs;

typedef struct ConsensusParamsBlock__storage_ {
  uint32_t _has_storage_[1];
  NSString *maxBytes;
  NSString *maxGas;
  NSString *timeIotaMs;
} ConsensusParamsBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsBlock_FieldNumber_MaxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConsensusParamsBlock__storage_, maxBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxGas",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsBlock_FieldNumber_MaxGas,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConsensusParamsBlock__storage_, maxGas),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeIotaMs",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsBlock_FieldNumber_TimeIotaMs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConsensusParamsBlock__storage_, timeIotaMs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsensusParamsBlock class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsensusParamsBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConsensusParamsEvidence

@implementation ConsensusParamsEvidence

@dynamic maxAgeNumBlocks;
@dynamic maxAgeDuration;
@dynamic maxBytes;

typedef struct ConsensusParamsEvidence__storage_ {
  uint32_t _has_storage_[1];
  NSString *maxAgeNumBlocks;
  NSString *maxAgeDuration;
  NSString *maxBytes;
} ConsensusParamsEvidence__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxAgeNumBlocks",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsEvidence_FieldNumber_MaxAgeNumBlocks,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConsensusParamsEvidence__storage_, maxAgeNumBlocks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxAgeDuration",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsEvidence_FieldNumber_MaxAgeDuration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConsensusParamsEvidence__storage_, maxAgeDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsensusParamsEvidence_FieldNumber_MaxBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConsensusParamsEvidence__storage_, maxBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsensusParamsEvidence class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsensusParamsEvidence__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConsensusParamsRequest

@implementation GetConsensusParamsRequest

@dynamic height;
@dynamic prove;

typedef struct GetConsensusParamsRequest__storage_ {
  uint32_t _has_storage_[1];
  int64_t height;
} GetConsensusParamsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsRequest_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsRequest__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = GetConsensusParamsRequest_FieldNumber_Prove,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsRequest class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConsensusParamsResponse

@implementation GetConsensusParamsResponse

@dynamic hasBlock, block;
@dynamic hasEvidence, evidence;

typedef struct GetConsensusParamsResponse__storage_ {
  uint32_t _has_storage_[1];
  ConsensusParamsBlock *block;
  ConsensusParamsEvidence *evidence;
} GetConsensusParamsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsensusParamsBlock),
        .number = GetConsensusParamsResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "evidence",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsensusParamsEvidence),
        .number = GetConsensusParamsResponse_FieldNumber_Evidence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConsensusParamsResponse__storage_, evidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConsensusParamsResponse class]
                                     rootClass:[PlatformRoot class]
                                          file:PlatformRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConsensusParamsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
