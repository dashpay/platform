syntax = "proto3";
import "google/protobuf/wrappers.proto";
import "google/protobuf/struct.proto";

package org.dash.platform.dapi.v0;

import "google/protobuf/timestamp.proto";

service Platform {
  rpc broadcastStateTransition(BroadcastStateTransitionRequest)
      returns (BroadcastStateTransitionResponse);
  rpc getIdentity(GetIdentityRequest) returns (GetIdentityResponse);
  rpc getIdentityKeys(GetIdentityKeysRequest) returns (GetIdentityKeysResponse);
  rpc getIdentitiesContractKeys(GetIdentitiesContractKeysRequest)
      returns (GetIdentitiesContractKeysResponse);
  rpc getIdentityNonce(GetIdentityNonceRequest)
      returns (GetIdentityNonceResponse);
  rpc getIdentityContractNonce(GetIdentityContractNonceRequest)
      returns (GetIdentityContractNonceResponse);
  rpc getIdentityBalance(GetIdentityBalanceRequest)
      returns (GetIdentityBalanceResponse);
  rpc getIdentitiesBalances(GetIdentitiesBalancesRequest)
      returns (GetIdentitiesBalancesResponse);
  rpc getIdentityBalanceAndRevision(GetIdentityBalanceAndRevisionRequest)
      returns (GetIdentityBalanceAndRevisionResponse);
  rpc getEvonodesProposedEpochBlocksByIds(
      GetEvonodesProposedEpochBlocksByIdsRequest)
      returns (GetEvonodesProposedEpochBlocksResponse);
  rpc getEvonodesProposedEpochBlocksByRange(
      GetEvonodesProposedEpochBlocksByRangeRequest)
      returns (GetEvonodesProposedEpochBlocksResponse);
  rpc getDataContract(GetDataContractRequest) returns (GetDataContractResponse);
  rpc getDataContractHistory(GetDataContractHistoryRequest)
      returns (GetDataContractHistoryResponse);
  rpc getDataContracts(GetDataContractsRequest)
      returns (GetDataContractsResponse);
  rpc getDocuments(GetDocumentsRequest) returns (GetDocumentsResponse);
  rpc getIdentityByPublicKeyHash(GetIdentityByPublicKeyHashRequest)
      returns (GetIdentityByPublicKeyHashResponse);
  rpc getIdentityByNonUniquePublicKeyHash(GetIdentityByNonUniquePublicKeyHashRequest)
      returns (GetIdentityByNonUniquePublicKeyHashResponse);
  rpc waitForStateTransitionResult(WaitForStateTransitionResultRequest)
      returns (WaitForStateTransitionResultResponse);
  rpc getConsensusParams(GetConsensusParamsRequest)
      returns (GetConsensusParamsResponse);
  rpc getProtocolVersionUpgradeState(GetProtocolVersionUpgradeStateRequest)
      returns (GetProtocolVersionUpgradeStateResponse);
  rpc getProtocolVersionUpgradeVoteStatus(
      GetProtocolVersionUpgradeVoteStatusRequest)
      returns (GetProtocolVersionUpgradeVoteStatusResponse);
  rpc getEpochsInfo(GetEpochsInfoRequest) returns (GetEpochsInfoResponse);
  rpc getFinalizedEpochInfos(GetFinalizedEpochInfosRequest) returns (GetFinalizedEpochInfosResponse);
  // What votes are currently happening for a specific contested index
  rpc getContestedResources(GetContestedResourcesRequest)
      returns (GetContestedResourcesResponse);
  // What's the state of a contested resource vote? (ie who is winning?)
  rpc getContestedResourceVoteState(GetContestedResourceVoteStateRequest)
      returns (GetContestedResourceVoteStateResponse);
  // Who voted for a contested resource to go to a specific identity?
  rpc getContestedResourceVotersForIdentity(
      GetContestedResourceVotersForIdentityRequest)
      returns (GetContestedResourceVotersForIdentityResponse);
  // How did an identity vote?
  rpc getContestedResourceIdentityVotes(
      GetContestedResourceIdentityVotesRequest)
      returns (GetContestedResourceIdentityVotesResponse);
  // What vote polls will end soon?
  rpc getVotePollsByEndDate(GetVotePollsByEndDateRequest)
      returns (GetVotePollsByEndDateResponse);
  rpc getPrefundedSpecializedBalance(GetPrefundedSpecializedBalanceRequest)
      returns (GetPrefundedSpecializedBalanceResponse);
  rpc getTotalCreditsInPlatform(GetTotalCreditsInPlatformRequest)
      returns (GetTotalCreditsInPlatformResponse);
  rpc getPathElements(GetPathElementsRequest) returns (GetPathElementsResponse);
  rpc getStatus(GetStatusRequest) returns (GetStatusResponse);
  rpc getCurrentQuorumsInfo(GetCurrentQuorumsInfoRequest)
      returns (GetCurrentQuorumsInfoResponse);
  rpc getIdentityTokenBalances(GetIdentityTokenBalancesRequest)
      returns (GetIdentityTokenBalancesResponse);
  rpc getIdentitiesTokenBalances(GetIdentitiesTokenBalancesRequest)
      returns (GetIdentitiesTokenBalancesResponse);
  rpc getIdentityTokenInfos(GetIdentityTokenInfosRequest)
      returns (GetIdentityTokenInfosResponse);
  rpc getIdentitiesTokenInfos(GetIdentitiesTokenInfosRequest)
      returns (GetIdentitiesTokenInfosResponse);
  rpc getTokenStatuses(GetTokenStatusesRequest)
      returns (GetTokenStatusesResponse);
  rpc getTokenDirectPurchasePrices(GetTokenDirectPurchasePricesRequest)
      returns (GetTokenDirectPurchasePricesResponse);
  rpc getTokenContractInfo(GetTokenContractInfoRequest)
      returns (GetTokenContractInfoResponse);
  rpc getTokenPreProgrammedDistributions(
      GetTokenPreProgrammedDistributionsRequest)
      returns (GetTokenPreProgrammedDistributionsResponse);
  rpc getTokenPerpetualDistributionLastClaim(
      GetTokenPerpetualDistributionLastClaimRequest)
      returns (GetTokenPerpetualDistributionLastClaimResponse);
  rpc getTokenTotalSupply(GetTokenTotalSupplyRequest)
      returns (GetTokenTotalSupplyResponse);
  rpc getGroupInfo(GetGroupInfoRequest) returns (GetGroupInfoResponse);
  rpc getGroupInfos(GetGroupInfosRequest) returns (GetGroupInfosResponse);
  rpc getGroupActions(GetGroupActionsRequest) returns (GetGroupActionsResponse);
  rpc getGroupActionSigners(GetGroupActionSignersRequest)
      returns (GetGroupActionSignersResponse);
}

// Proof message includes cryptographic proofs for validating responses
message Proof {
  bytes grovedb_proof = 1; // GroveDB proof for the data
  bytes quorum_hash = 2;   // Hash of the quorum validating the data
  bytes signature = 3;     // Signature proving data authenticity
  uint32 round = 4;        // Consensus round number
  bytes block_id_hash = 5; // Hash of the block ID
  uint32 quorum_type = 6;  // Type of the quorum
}

// ResponseMetadata provides metadata about the blockchain state at the time of
// response
message ResponseMetadata {
  uint64 height = 1 [ jstype = JS_STRING ]; // Current blockchain height
  uint32 core_chain_locked_height = 2; // Latest known core height in consensus
  uint32 epoch = 3;                    // Current epoch number
  uint64 time_ms = 4 [ jstype = JS_STRING ]; // Timestamp in milliseconds
  uint32 protocol_version = 5;               // Protocol version
  string chain_id = 6;                       // Identifier of the blockchain
}

message StateTransitionBroadcastError {
  uint32 code = 1;
  string message = 2;
  bytes data = 3;
}

enum KeyPurpose {
  AUTHENTICATION = 0;
  ENCRYPTION = 1;
  DECRYPTION = 2;
  TRANSFER = 3;
  VOTING = 5;
}

message BroadcastStateTransitionRequest { bytes state_transition = 1; }

message BroadcastStateTransitionResponse {}

message GetIdentityRequest {

  message GetIdentityRequestV0 {
    bytes id = 1;   // The ID of the identity being requested
    bool prove = 2; // Flag to request a proof as the response
  }

  oneof version { GetIdentityRequestV0 v0 = 1; }
}

message GetIdentityNonceRequest {

  message GetIdentityNonceRequestV0 {
    bytes identity_id = 1;
    bool prove = 2;
  }

  oneof version { GetIdentityNonceRequestV0 v0 = 1; }
}

message GetIdentityContractNonceRequest {

  message GetIdentityContractNonceRequestV0 {
    bytes identity_id = 1;
    bytes contract_id = 2;
    bool prove = 3;
  }

  oneof version { GetIdentityContractNonceRequestV0 v0 = 1; }
}

message GetIdentityBalanceRequest {

  message GetIdentityBalanceRequestV0 {
    bytes id = 1;   // ID of the identity whose balance is requested
    bool prove = 2; // Flag to request a proof as the response
  }

  oneof version { GetIdentityBalanceRequestV0 v0 = 1; }
}

message GetIdentityBalanceAndRevisionRequest {

  message GetIdentityBalanceAndRevisionRequestV0 {
    bytes id = 1;   // ID of the identity for balance and revision
    bool prove = 2; // Flag to request a proof as the response
  }

  oneof version { GetIdentityBalanceAndRevisionRequestV0 v0 = 1; }
}

message GetIdentityResponse {

  message GetIdentityResponseV0 {
    oneof result {
      bytes identity = 1; // The requested identity data
      Proof proof = 2;    // Proof of the identity data, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetIdentityResponseV0 v0 = 1; }
}

message GetIdentityNonceResponse {

  message GetIdentityNonceResponseV0 {
    oneof result {
      uint64 identity_nonce = 1 [ jstype = JS_STRING ];
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetIdentityNonceResponseV0 v0 = 1; }
}

message GetIdentityContractNonceResponse {

  message GetIdentityContractNonceResponseV0 {
    oneof result {
      uint64 identity_contract_nonce = 1 [ jstype = JS_STRING ];
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetIdentityContractNonceResponseV0 v0 = 1; }
}

message GetIdentityBalanceResponse {

  message GetIdentityBalanceResponseV0 {
    oneof result {
      uint64 balance = 1
          [ jstype = JS_STRING ]; // The balance of the requested identity
      Proof proof = 2;            // Proof of the balance, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetIdentityBalanceResponseV0 v0 = 1; }
}

message GetIdentityBalanceAndRevisionResponse {

  message GetIdentityBalanceAndRevisionResponseV0 {
    message BalanceAndRevision {
      uint64 balance = 1 [ jstype = JS_STRING ]; // Balance of the identity
      uint64 revision = 2
          [ jstype = JS_STRING ]; // Revision number of the identity
    }

    oneof result {
      BalanceAndRevision balance_and_revision =
          1;           // The balance and revision data
      Proof proof = 2; // Proof of the data, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetIdentityBalanceAndRevisionResponseV0 v0 = 1; }
}

message KeyRequestType {
  oneof request {
    AllKeys all_keys = 1;           // Request for all keys
    SpecificKeys specific_keys = 2; // Request for specific keys by their IDs
    SearchKey search_key = 3; // Request for keys based on a search criteria
  }
}

// AllKeys is an empty message used to signify a request for all keys
message AllKeys {}

// SpecificKeys is used to request specific keys by their IDs
message SpecificKeys {
  repeated uint32 key_ids = 1; // List of key IDs
}

// SearchKey represents a request to search for keys based on specific criteria
message SearchKey {
  map<uint32, SecurityLevelMap> purpose_map =
      1; // Map of purposes to their security level maps
}

// SecurityLevelMap maps security levels to a request type for key retrieval
message SecurityLevelMap {
  enum KeyKindRequestType {
    CURRENT_KEY_OF_KIND_REQUEST =
        0; // Request the current key of a particular kind
    ALL_KEYS_OF_KIND_REQUEST = 1; // Request all keys of a particular kind
  }
  map<uint32, KeyKindRequestType> security_level_map =
      1; // Maps security levels to key request types
}

message GetIdentityKeysRequest {

  message GetIdentityKeysRequestV0 {
    bytes identity_id = 1; // ID of the identity for key retrieval
    KeyRequestType request_type =
        2; // Type of key request: all, specific, or search
    google.protobuf.UInt32Value limit =
        3; // Limit on the number of keys to be returned
    google.protobuf.UInt32Value offset =
        4;          // Offset for pagination through the keys
    bool prove = 5; // Flag to request a proof as the response
  }

  oneof version { GetIdentityKeysRequestV0 v0 = 1; }
}

message GetIdentityKeysResponse {

  message GetIdentityKeysResponseV0 {
    message Keys {
      repeated bytes keys_bytes = 1;
    } // Collection of keys as byte sequences

    oneof result {
      Keys keys = 1;   // The actual key data
      Proof proof = 2; // Proof of the keys data, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetIdentityKeysResponseV0 v0 = 1; }
}

message GetIdentitiesContractKeysRequest {
  message GetIdentitiesContractKeysRequestV0 {
    repeated bytes identities_ids = 1;
    bytes contract_id = 2;
    optional string document_type_name = 3;
    repeated KeyPurpose purposes = 4;
    bool prove = 5;
  }

  oneof version { GetIdentitiesContractKeysRequestV0 v0 = 1; }
}

message GetIdentitiesContractKeysResponse {
  message GetIdentitiesContractKeysResponseV0 {
    message PurposeKeys {
      KeyPurpose purpose = 1;
      repeated bytes keys_bytes = 2;
    }

    message IdentityKeys {
      bytes identity_id = 1;
      repeated PurposeKeys keys = 2;
    }

    message IdentitiesKeys { repeated IdentityKeys entries = 1; };

    oneof result {
      IdentitiesKeys identities_keys = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetIdentitiesContractKeysResponseV0 v0 = 1; }
}

message GetEvonodesProposedEpochBlocksByIdsRequest {

  message GetEvonodesProposedEpochBlocksByIdsRequestV0 {
    optional uint32 epoch =
        1; // The epoch we are querying for, if none is set, get current epoch
    repeated bytes ids =
        2; // IDs of the evonodes for which we want to get their proposed blocks
    bool prove = 3; // Flag to request a proof as the response
  }

  oneof version { GetEvonodesProposedEpochBlocksByIdsRequestV0 v0 = 1; }
}

message GetEvonodesProposedEpochBlocksResponse {

  message GetEvonodesProposedEpochBlocksResponseV0 {
    message EvonodeProposedBlocks {
      bytes pro_tx_hash = 1;
      uint64 count = 2 [ jstype = JS_STRING ];
    }

    message EvonodesProposedBlocks {
      repeated EvonodeProposedBlocks evonodes_proposed_block_counts = 1;
    }

    oneof result {
      EvonodesProposedBlocks evonodes_proposed_block_counts_info =
          1;           // The actual result
      Proof proof = 2; // Proof of the keys data, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetEvonodesProposedEpochBlocksResponseV0 v0 = 1; }
}

message GetEvonodesProposedEpochBlocksByRangeRequest {

  message GetEvonodesProposedEpochBlocksByRangeRequestV0 {
    optional uint32 epoch =
        1; // The epoch we are querying for, if none is set, get current epoch
    optional uint32 limit =
        2; // Maximum number of evonodes proposed epoch blocks to return
    oneof start {
      bytes start_after = 3; // Start retrieval after this document
      bytes start_at = 4;    // Start retrieval at this document
    }
    bool prove = 5; // Flag to request a proof as the response
  }

  oneof version { GetEvonodesProposedEpochBlocksByRangeRequestV0 v0 = 1; }
}

message GetIdentitiesBalancesRequest {
  message GetIdentitiesBalancesRequestV0 {
    repeated bytes ids = 1;
    bool prove = 2;
  }

  oneof version { GetIdentitiesBalancesRequestV0 v0 = 1; }
}

message GetIdentitiesBalancesResponse {
  message GetIdentitiesBalancesResponseV0 {
    message IdentityBalance {
      bytes identity_id = 1;
      optional uint64 balance = 2 [ jstype = JS_STRING ];
    }

    message IdentitiesBalances { repeated IdentityBalance entries = 1; };

    oneof result {
      IdentitiesBalances identities_balances = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetIdentitiesBalancesResponseV0 v0 = 1; }
}

message GetDataContractRequest {
  message GetDataContractRequestV0 {
    bytes id = 1;   // The ID of the data contract being requested
    bool prove = 2; // Flag to request a proof as the response
  }
  oneof version { GetDataContractRequestV0 v0 = 1; }
}

message GetDataContractResponse {
  message GetDataContractResponseV0 {
    oneof result {
      bytes data_contract = 1; // The actual data contract in binary form
      Proof proof = 2; // Cryptographic proof of the data contract, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetDataContractResponseV0 v0 = 1; }
}

message GetDataContractsRequest {
  message GetDataContractsRequestV0 {
    repeated bytes ids =
        1; // A list of unique IDs for the data contracts being requested
    bool prove = 2; // Flag to request a proof as the response
  }
  oneof version { GetDataContractsRequestV0 v0 = 1; }
}

message GetDataContractsResponse {
  message DataContractEntry {
    bytes identifier = 1; // The unique identifier of the data contract
    google.protobuf.BytesValue data_contract =
        2; // The actual data contract content
  }

  // DataContracts is a collection of data contract entries.
  message DataContracts {
    repeated DataContractEntry data_contract_entries =
        1; // A list of data contract entries
  }

  message GetDataContractsResponseV0 {
    oneof result {
      DataContracts data_contracts = 1; // The actual data contracts requested
      Proof proof =
          2; // Cryptographic proof for the data contracts, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetDataContractsResponseV0 v0 = 1; }
}

message GetDataContractHistoryRequest {
  message GetDataContractHistoryRequestV0 {
    bytes id = 1; // The unique ID of the data contract
    google.protobuf.UInt32Value limit =
        2; // The maximum number of history entries to return
    google.protobuf.UInt32Value offset =
        3; // The offset for pagination through the contract history
    uint64 start_at_ms = 4 [
      jstype = JS_STRING
    ];              // Only return results starting at this time in milliseconds
    bool prove = 5; // Flag to request a proof as the response
  }
  oneof version { GetDataContractHistoryRequestV0 v0 = 1; }
}

message GetDataContractHistoryResponse {
  message GetDataContractHistoryResponseV0 {
    // Represents a single entry in the data contract's history
    message DataContractHistoryEntry {
      uint64 date = 1 [ jstype = JS_STRING ]; // The date of the history entry
      bytes value =
          2; // The value of the data contract at this point in history
    }

    // Collection of data contract history entries
    message DataContractHistory {
      repeated DataContractHistoryEntry data_contract_entries =
          1; // List of history entries
    }

    oneof result {
      DataContractHistory data_contract_history =
          1; // The actual history of the data contract
      Proof proof =
          2; // Cryptographic proof of the data contract history, if requested
    }

    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetDataContractHistoryResponseV0 v0 = 1; }
}

message GetDocumentsRequest {
  message GetDocumentsRequestV0 {
    bytes data_contract_id =
        1; // The ID of the data contract containing the documents
    string document_type = 2; // The type of document being requested
    bytes where = 3;          // Conditions to be met by the requested documents
    bytes order_by = 4;       // Ordering criteria for the documents
    uint32 limit = 5;         // Maximum number of documents to return

    // Specifies the starting point for the document retrieval
    oneof start {
      bytes start_after = 6; // Start retrieval after this document
      bytes start_at = 7;    // Start retrieval at this document
    }
    bool prove = 8; // Flag to request a proof as the response
  }
  oneof version { GetDocumentsRequestV0 v0 = 1; }
}

message GetDocumentsResponse {
  message GetDocumentsResponseV0 {
    // Represents a collection of documents
    message Documents {
      repeated bytes documents = 1; // The actual documents in binary form
    }

    oneof result {
      Documents documents = 1; // The actual documents requested
      Proof proof = 2; // Cryptographic proof of the documents, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetDocumentsResponseV0 v0 = 1; }
}

message GetIdentityByPublicKeyHashRequest {
  message GetIdentityByPublicKeyHashRequestV0 {
    bytes public_key_hash =
        1;          // The public key hash of the identity being requested
    bool prove = 2; // Flag to request a proof as the response
  }
  oneof version { GetIdentityByPublicKeyHashRequestV0 v0 = 1; }
}

message GetIdentityByPublicKeyHashResponse {
  message GetIdentityByPublicKeyHashResponseV0 {
    oneof result {
      bytes identity = 1; // The actual identity data corresponding to the
                          // requested public key hash
      Proof proof =
          2; // Cryptographic proof for the identity data, if requested
    }

    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetIdentityByPublicKeyHashResponseV0 v0 = 1; }
}

message GetIdentityByNonUniquePublicKeyHashRequest {
  message GetIdentityByNonUniquePublicKeyHashRequestV0 {
    bytes public_key_hash = 1;
    optional bytes start_after = 2; // Give one result after a previous result
    bool prove = 3;
  }
  oneof version { GetIdentityByNonUniquePublicKeyHashRequestV0 v0 = 1; }
}

message GetIdentityByNonUniquePublicKeyHashResponse {
  message GetIdentityByNonUniquePublicKeyHashResponseV0 {
    message IdentityResponse {
      optional bytes identity = 1;
    }

    message IdentityProvedResponse {
      Proof grovedb_identity_public_key_hash_proof = 1;
      optional bytes identity_proof_bytes = 2; // A hack, we return 2 proofs
    }
    oneof result {
      IdentityResponse identity = 1;
      IdentityProvedResponse proof = 2;
    }

    ResponseMetadata metadata = 3;  // Metadata about the blockchain state
  }
  oneof version { GetIdentityByNonUniquePublicKeyHashResponseV0 v0 = 1; }
}

message WaitForStateTransitionResultRequest {
  message WaitForStateTransitionResultRequestV0 {
    bytes state_transition_hash =
        1;          // The hash of the state transition to wait for
    bool prove = 2; // Flag to request a proof as the response
  }
  oneof version { WaitForStateTransitionResultRequestV0 v0 = 1; }
}

message WaitForStateTransitionResultResponse {
  message WaitForStateTransitionResultResponseV0 {
    oneof result {
      StateTransitionBroadcastError error =
          1; // Any error that occurred during the state transition broadcast
      Proof proof =
          2; // Cryptographic proof for the state transition, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { WaitForStateTransitionResultResponseV0 v0 = 1; }
}

message GetConsensusParamsRequest {
  message GetConsensusParamsRequestV0 {
    int32 height =
        1; // The blockchain height at which to get the consensus parameters
    bool prove = 2; // Flag to request a proof as the response
  }
  oneof version { GetConsensusParamsRequestV0 v0 = 1; }
}

message GetConsensusParamsResponse {
  message ConsensusParamsBlock {
    string max_bytes = 1;    // The maximum size of a block in bytes
    string max_gas = 2;      // The maximum gas allowed in a block
    string time_iota_ms = 3; // The minimum time increment between consecutive
                             // blocks, in milliseconds
  }

  message ConsensusParamsEvidence {
    string max_age_num_blocks =
        1; // The maximum age of evidence, in number of blocks
    string max_age_duration = 2; // The maximum age of evidence, as a duration
    string max_bytes = 3;        // The maximum size of evidence in bytes
  }

  message GetConsensusParamsResponseV0 {
    ConsensusParamsBlock block =
        1; // Consensus parameters related to block creation and validation
    ConsensusParamsEvidence evidence =
        2; // Consensus parameters related to evidence
  }
  oneof version { GetConsensusParamsResponseV0 v0 = 1; }
}

message GetProtocolVersionUpgradeStateRequest {
  message GetProtocolVersionUpgradeStateRequestV0 {
    bool prove = 1; // Flag to request a proof as the response
  }

  oneof version { GetProtocolVersionUpgradeStateRequestV0 v0 = 1; }
}

message GetProtocolVersionUpgradeStateResponse {
  message GetProtocolVersionUpgradeStateResponseV0 {
    // Versions holds a collection of version entries
    message Versions {
      repeated VersionEntry versions = 1; // List of protocol version entries
    }

    // VersionEntry represents a single entry of a protocol version
    message VersionEntry {
      uint32 version_number = 1; // The protocol version number
      uint32 vote_count = 2;     // The vote count for this protocol version
    }

    oneof result {
      Versions versions = 1; // The actual protocol version information
      Proof proof = 2;       // Cryptographic proof of the protocol version
                             // information, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetProtocolVersionUpgradeStateResponseV0 v0 = 1; }
}

message GetProtocolVersionUpgradeVoteStatusRequest {
  message GetProtocolVersionUpgradeVoteStatusRequestV0 {
    bytes start_pro_tx_hash = 1; // The starting masternode provider transaction
                                 // hash to filter the votes by
    uint32 count = 2;            // The number of vote entries to retrieve
    bool prove = 3;              // Flag to request a proof as the response
  }

  oneof version { GetProtocolVersionUpgradeVoteStatusRequestV0 v0 = 1; }
}

message GetProtocolVersionUpgradeVoteStatusResponse {
  message GetProtocolVersionUpgradeVoteStatusResponseV0 {
    // VersionSignals holds a collection of version signal entries
    message VersionSignals {
      repeated VersionSignal version_signals =
          1; // List of version signal entries
    }

    // VersionSignal represents a single voting signal for a protocol version
    message VersionSignal {
      bytes pro_tx_hash = 1; // The masternode provider transaction hash
                             // associated with the vote
      uint32 version = 2; // The protocol version number that is being voted on
    }

    oneof result {
      VersionSignals versions = 1; // The actual version signal information
      Proof proof = 2; // Cryptographic proof of the version signal information,
                       // if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetProtocolVersionUpgradeVoteStatusResponseV0 v0 = 1; }
}

message GetEpochsInfoRequest {
  message GetEpochsInfoRequestV0 {
    google.protobuf.UInt32Value start_epoch =
        1;            // The starting epoch for the request
    uint32 count = 2; // The number of epochs to retrieve information for
    bool ascending =
        3; // Flag indicating if the epochs should be listed in ascending order
    bool prove = 4; // Flag to request a proof as the response
  }

  oneof version { GetEpochsInfoRequestV0 v0 = 1; }
}

message GetEpochsInfoResponse {
  message GetEpochsInfoResponseV0 {
    // EpochInfos holds a collection of epoch information entries
    message EpochInfos {
      repeated EpochInfo epoch_infos =
          1; // List of information for each requested epoch
    }

    // EpochInfo represents information about a single epoch
    message EpochInfo {
      uint32 number = 1; // The number of the epoch
      uint64 first_block_height = 2
          [ jstype = JS_STRING ]; // The height of the first block in this epoch
      uint32 first_core_block_height =
          3; // The height of the first Core block in this epoch
      uint64 start_time = 4
          [ jstype = JS_STRING ]; // The start time of the epoch
      double fee_multiplier = 5;  // The fee multiplier applicable in this epoch
      uint32 protocol_version = 6;
    }

    oneof result {
      EpochInfos epochs =
          1; // The actual information about the requested epochs
      Proof proof =
          2; // Cryptographic proof of the epoch information, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetEpochsInfoResponseV0 v0 = 1; }
}

message GetFinalizedEpochInfosRequest {
  message GetFinalizedEpochInfosRequestV0 {
    uint32 start_epoch_index = 1;          // The starting epoch index
    bool start_epoch_index_included = 2;   // Whether to include the start epoch
    uint32 end_epoch_index = 3;            // The ending epoch index  
    bool end_epoch_index_included = 4;     // Whether to include the end epoch
    bool prove = 5;                        // Flag to request a proof as the response
  }

  oneof version { GetFinalizedEpochInfosRequestV0 v0 = 1; }
}

message GetFinalizedEpochInfosResponse {
  message GetFinalizedEpochInfosResponseV0 {
    // FinalizedEpochInfos holds a collection of finalized epoch information entries
    message FinalizedEpochInfos {
      repeated FinalizedEpochInfo finalized_epoch_infos = 
          1; // List of finalized information for each requested epoch
    }

    // FinalizedEpochInfo represents finalized information about a single epoch
    message FinalizedEpochInfo {
      uint32 number = 1; // The number of the epoch
      uint64 first_block_height = 2
          [ jstype = JS_STRING ]; // The height of the first block in this epoch
      uint32 first_core_block_height = 
          3; // The height of the first Core block in this epoch
      uint64 first_block_time = 4
          [ jstype = JS_STRING ]; // The timestamp of the first block (milliseconds)
      double fee_multiplier = 5;  // The fee multiplier (converted from permille)
      uint32 protocol_version = 6; // The protocol version for this epoch
      uint64 total_blocks_in_epoch = 7
          [ jstype = JS_STRING ]; // Total number of blocks in the epoch
      uint32 next_epoch_start_core_block_height = 8; // Core block height where next epoch starts
      uint64 total_processing_fees = 9
          [ jstype = JS_STRING ]; // Total processing fees collected
      uint64 total_distributed_storage_fees = 10
          [ jstype = JS_STRING ]; // Total storage fees distributed
      uint64 total_created_storage_fees = 11
          [ jstype = JS_STRING ]; // Total storage fees created
      uint64 core_block_rewards = 12
          [ jstype = JS_STRING ]; // Rewards from core blocks
      repeated BlockProposer block_proposers = 13; // List of block proposers and their counts
    }

    // BlockProposer represents a block proposer and their block count
    message BlockProposer {
      bytes proposer_id = 1; // The proposer's identifier
      uint32 block_count = 2; // Number of blocks proposed
    }

    oneof result {
      FinalizedEpochInfos epochs = 
          1; // The actual finalized information about the requested epochs
      Proof proof = 
          2; // Cryptographic proof of the finalized epoch information, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }

  oneof version { GetFinalizedEpochInfosResponseV0 v0 = 1; }
}

message GetContestedResourcesRequest {
  message GetContestedResourcesRequestV0 {
    message StartAtValueInfo {
      bytes start_value = 1;
      bool start_value_included = 2;
    }

    bytes contract_id = 1;
    string document_type_name = 2;
    string index_name = 3;
    repeated bytes start_index_values = 4;
    repeated bytes end_index_values = 5;
    optional StartAtValueInfo start_at_value_info = 6;
    optional uint32 count = 7;
    bool order_ascending = 8;
    bool prove = 9;
  }

  oneof version { GetContestedResourcesRequestV0 v0 = 1; }
}

message GetContestedResourcesResponse {
  message GetContestedResourcesResponseV0 {
    message ContestedResourceValues {
      repeated bytes contested_resource_values = 1;
    }

    oneof result {
      ContestedResourceValues contested_resource_values = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetContestedResourcesResponseV0 v0 = 1; }
}

message GetVotePollsByEndDateRequest {
  message GetVotePollsByEndDateRequestV0 {
    message StartAtTimeInfo {
      uint64 start_time_ms = 1 [ jstype = JS_STRING ];
      bool start_time_included = 2;
    }
    message EndAtTimeInfo {
      uint64 end_time_ms = 1 [ jstype = JS_STRING ];
      bool end_time_included = 2;
    }
    optional StartAtTimeInfo start_time_info = 1;
    optional EndAtTimeInfo end_time_info = 2;
    optional uint32 limit = 3;
    optional uint32 offset = 4;
    bool ascending = 5;
    bool prove = 6;
  }

  oneof version { GetVotePollsByEndDateRequestV0 v0 = 1; }
}

message GetVotePollsByEndDateResponse {
  message GetVotePollsByEndDateResponseV0 {
    message SerializedVotePollsByTimestamp {
      uint64 timestamp = 1 [ jstype = JS_STRING ];
      repeated bytes serialized_vote_polls = 2;
    }

    message SerializedVotePollsByTimestamps {
      repeated SerializedVotePollsByTimestamp vote_polls_by_timestamps = 1;
      bool finished_results = 2;
    }

    oneof result {
      SerializedVotePollsByTimestamps vote_polls_by_timestamps = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetVotePollsByEndDateResponseV0 v0 = 1; }
}

// What's the state of a contested resource vote? (ie who is winning?)
message GetContestedResourceVoteStateRequest {
  message GetContestedResourceVoteStateRequestV0 {
    message StartAtIdentifierInfo {
      bytes start_identifier = 1;
      bool start_identifier_included = 2;
    }
    enum ResultType {
      DOCUMENTS = 0;
      VOTE_TALLY = 1;
      DOCUMENTS_AND_VOTE_TALLY = 2;
    }

    bytes contract_id = 1;
    string document_type_name = 2;
    string index_name = 3;
    repeated bytes index_values = 4;
    ResultType result_type = 5;
    bool allow_include_locked_and_abstaining_vote_tally = 6;
    optional StartAtIdentifierInfo start_at_identifier_info = 7;
    optional uint32 count = 8;
    bool prove = 9;
  }

  oneof version { GetContestedResourceVoteStateRequestV0 v0 = 1; }
}

message GetContestedResourceVoteStateResponse {
  message GetContestedResourceVoteStateResponseV0 {
    message FinishedVoteInfo {
      enum FinishedVoteOutcome {
        TOWARDS_IDENTITY = 0;
        LOCKED = 1;
        NO_PREVIOUS_WINNER = 2;
      }
      FinishedVoteOutcome finished_vote_outcome = 1;
      optional bytes won_by_identity_id =
          2; // Only used when vote_choice_type is TOWARDS_IDENTITY
      uint64 finished_at_block_height = 3 [ jstype = JS_STRING ];
      uint32 finished_at_core_block_height = 4;
      uint64 finished_at_block_time_ms = 5 [ jstype = JS_STRING ];
      uint32 finished_at_epoch = 6;
    }

    message ContestedResourceContenders {
      repeated Contender contenders = 1;
      optional uint32 abstain_vote_tally = 2;
      optional uint32 lock_vote_tally = 3;
      optional FinishedVoteInfo finished_vote_info = 4;
    }

    message Contender {
      bytes identifier = 1;
      optional uint32 vote_count = 2;
      optional bytes document = 3;
    }

    oneof result {
      ContestedResourceContenders contested_resource_contenders = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetContestedResourceVoteStateResponseV0 v0 = 1; }
}

// Who voted for a contested resource to go to a specific identity?
message GetContestedResourceVotersForIdentityRequest {
  message GetContestedResourceVotersForIdentityRequestV0 {
    message StartAtIdentifierInfo {
      bytes start_identifier = 1;
      bool start_identifier_included = 2;
    }
    bytes contract_id = 1;
    string document_type_name = 2;
    string index_name = 3;
    repeated bytes index_values = 4;
    bytes contestant_id = 5;
    optional StartAtIdentifierInfo start_at_identifier_info = 6;
    optional uint32 count = 7;
    bool order_ascending = 8;
    bool prove = 9;
  }

  oneof version { GetContestedResourceVotersForIdentityRequestV0 v0 = 1; }
}

message GetContestedResourceVotersForIdentityResponse {
  message GetContestedResourceVotersForIdentityResponseV0 {
    message ContestedResourceVoters {
      repeated bytes voters = 1;
      bool finished_results = 2;
    }

    oneof result {
      ContestedResourceVoters contested_resource_voters = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetContestedResourceVotersForIdentityResponseV0 v0 = 1; }
}

// How did an identity vote?
message GetContestedResourceIdentityVotesRequest {
  message GetContestedResourceIdentityVotesRequestV0 {
    message StartAtVotePollIdInfo {
      bytes start_at_poll_identifier = 1;
      bool start_poll_identifier_included = 2;
    }
    bytes identity_id = 1;
    google.protobuf.UInt32Value limit = 2;
    google.protobuf.UInt32Value offset = 3;
    bool order_ascending = 4;
    optional StartAtVotePollIdInfo start_at_vote_poll_id_info = 5;
    bool prove = 6;
  }

  oneof version { GetContestedResourceIdentityVotesRequestV0 v0 = 1; }
}

message GetContestedResourceIdentityVotesResponse {
  message GetContestedResourceIdentityVotesResponseV0 {
    message ContestedResourceIdentityVotes {
      repeated ContestedResourceIdentityVote contested_resource_identity_votes =
          1;
      bool finished_results = 2;
    }

    message ResourceVoteChoice {
      enum VoteChoiceType {
        TOWARDS_IDENTITY = 0;
        ABSTAIN = 1;
        LOCK = 2;
      }
      VoteChoiceType vote_choice_type = 1;
      optional bytes identity_id =
          2; // Only used when vote_choice_type is TOWARDS_IDENTITY
    }

    message ContestedResourceIdentityVote {
      bytes contract_id = 1;
      string document_type_name = 2;
      repeated bytes serialized_index_storage_values = 3;
      ResourceVoteChoice vote_choice = 4;
    }

    oneof result {
      ContestedResourceIdentityVotes votes = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetContestedResourceIdentityVotesResponseV0 v0 = 1; }
}

message GetPrefundedSpecializedBalanceRequest {

  message GetPrefundedSpecializedBalanceRequestV0 {
    bytes id = 1;
    bool prove = 2;
  }

  oneof version { GetPrefundedSpecializedBalanceRequestV0 v0 = 1; }
}

message GetPrefundedSpecializedBalanceResponse {

  message GetPrefundedSpecializedBalanceResponseV0 {
    oneof result {
      uint64 balance = 1 [ jstype = JS_STRING ];
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetPrefundedSpecializedBalanceResponseV0 v0 = 1; }
}

message GetTotalCreditsInPlatformRequest {
  message GetTotalCreditsInPlatformRequestV0 { bool prove = 1; }

  oneof version { GetTotalCreditsInPlatformRequestV0 v0 = 1; }
}

message GetTotalCreditsInPlatformResponse {
  message GetTotalCreditsInPlatformResponseV0 {
    oneof result {
      uint64 credits = 1 [ jstype = JS_STRING ];

      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetTotalCreditsInPlatformResponseV0 v0 = 1; }
}

message GetPathElementsRequest {
  message GetPathElementsRequestV0 {
    repeated bytes path = 1;
    repeated bytes keys = 2;
    bool prove = 3;
  }

  oneof version { GetPathElementsRequestV0 v0 = 1; }
}

message GetPathElementsResponse {
  message GetPathElementsResponseV0 {
    message Elements { repeated bytes elements = 1; }

    oneof result {
      Elements elements = 1;

      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetPathElementsResponseV0 v0 = 1; }
}

message GetStatusRequest {
  message GetStatusRequestV0 {}

  oneof version { GetStatusRequestV0 v0 = 1; }
}

message GetStatusResponse {
  message GetStatusResponseV0 {
    message Version {
      message Software {
        string dapi = 1;
        // It will be missing if Drive is not responding
        optional string drive = 2;
        // It will be missing if Tenderdash is not responding
        optional string tenderdash = 3;
      }

      message Protocol {
        message Tenderdash {
          uint32 p2p = 1;
          uint32 block = 2;
        }

        message Drive {
          uint32 latest = 3;
          uint32 current = 4;
        }

        Tenderdash tenderdash = 1;
        Drive drive = 2;
      }

      Software software = 1;
      Protocol protocol = 2;
    }

    message Time {
      uint64 local = 1 [ jstype = JS_STRING ];
      // It will be missing if Drive is not responding
      optional uint64 block = 2 [ jstype = JS_STRING ];
      // It will be missing if Drive is not responding
      optional uint64 genesis = 3 [ jstype = JS_STRING ];
      // It will be missing if Drive is not responding
      optional uint32 epoch = 4;
    }

    message Node {
      // Platform node ID
      bytes id = 1;
      // Evo masternode pro tx hash. It will be absent if the node is a fullnode
      optional bytes pro_tx_hash = 2;
    }

    message Chain {
      bool catching_up = 1;
      bytes latest_block_hash = 2;
      bytes latest_app_hash = 3;
      uint64 latest_block_height = 4 [ jstype = JS_STRING ];
      bytes earliest_block_hash = 5;
      bytes earliest_app_hash = 6;
      uint64 earliest_block_height = 7 [ jstype = JS_STRING ];
      uint64 max_peer_block_height = 9 [ jstype = JS_STRING ];
      // Latest known core height in consensus.
      // It will be missing if Drive is not responding
      optional uint32 core_chain_locked_height = 10;
    }

    message Network {
      string chain_id = 1;
      uint32 peers_count = 2;
      bool listening = 3;
    }

    message StateSync {
      uint64 total_synced_time = 1 [ jstype = JS_STRING ];
      uint64 remaining_time = 2 [ jstype = JS_STRING ];
      uint32 total_snapshots = 3;
      uint64 chunk_process_avg_time = 4 [ jstype = JS_STRING ];
      uint64 snapshot_height = 5 [ jstype = JS_STRING ];
      uint64 snapshot_chunks_count = 6 [ jstype = JS_STRING ];
      uint64 backfilled_blocks = 7 [ jstype = JS_STRING ];
      uint64 backfill_blocks_total = 8 [ jstype = JS_STRING ];
    }

    Version version = 1;
    Node node = 2;
    Chain chain = 3;
    Network network = 4;
    StateSync state_sync = 5;
    Time time = 6;
  }

  oneof version { GetStatusResponseV0 v0 = 1; }
}

message GetCurrentQuorumsInfoRequest {
  message GetCurrentQuorumsInfoRequestV0 {}

  oneof version { GetCurrentQuorumsInfoRequestV0 v0 = 1; }
}

message GetCurrentQuorumsInfoResponse {
  message ValidatorV0 {
    bytes pro_tx_hash = 1;
    string node_ip = 2;
    bool is_banned = 3;
  }
  message ValidatorSetV0 {
    bytes quorum_hash = 1;
    uint32 core_height = 2;
    repeated ValidatorV0 members = 3;
    bytes threshold_public_key = 4;
  }

  message GetCurrentQuorumsInfoResponseV0 {
    repeated bytes quorum_hashes = 1;
    bytes current_quorum_hash = 2;
    repeated ValidatorSetV0 validator_sets = 3;
    bytes last_block_proposer = 4;
    ResponseMetadata metadata = 5;
  }
  oneof version { GetCurrentQuorumsInfoResponseV0 v0 = 1; }
}

message GetIdentityTokenBalancesRequest {
  message GetIdentityTokenBalancesRequestV0 {
    bytes identity_id = 1;        // ID of the identity
    repeated bytes token_ids = 2; // List of token IDs
    bool prove = 3;               // Flag to request a proof as the response
  }
  oneof version { GetIdentityTokenBalancesRequestV0 v0 = 1; }
}

message GetIdentityTokenBalancesResponse {
  message GetIdentityTokenBalancesResponseV0 {
    message TokenBalanceEntry {
      bytes token_id = 1;          // Token ID
      optional uint64 balance = 2; // Token balance for the contract
    }

    message TokenBalances {
      repeated TokenBalanceEntry token_balances = 1; // List of token balances
    }

    oneof result {
      TokenBalances token_balances = 1; // Actual token balances
      Proof proof = 2; // Proof of the token balances, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetIdentityTokenBalancesResponseV0 v0 = 1; }
}

message GetIdentitiesTokenBalancesRequest {
  message GetIdentitiesTokenBalancesRequestV0 {
    bytes token_id = 1;              // Token ID
    repeated bytes identity_ids = 2; // List of identity IDs
    bool prove = 3;                  // Flag to request a proof as the response
  }
  oneof version { GetIdentitiesTokenBalancesRequestV0 v0 = 1; }
}

message GetIdentitiesTokenBalancesResponse {
  message GetIdentitiesTokenBalancesResponseV0 {
    message IdentityTokenBalanceEntry {
      bytes identity_id = 1;       // Identity ID
      optional uint64 balance = 2; // Token balance for the identity
    }

    message IdentityTokenBalances {
      repeated IdentityTokenBalanceEntry identity_token_balances =
          1; // List of identity token balances
    }

    oneof result {
      IdentityTokenBalances identity_token_balances =
          1;           // Actual identity token balances
      Proof proof = 2; // Proof of the balances, if requested
    }
    ResponseMetadata metadata = 3; // Metadata about the blockchain state
  }
  oneof version { GetIdentitiesTokenBalancesResponseV0 v0 = 1; }
}

message GetIdentityTokenInfosRequest {
  message GetIdentityTokenInfosRequestV0 {
    bytes identity_id = 1;
    repeated bytes token_ids = 2;
    bool prove = 3;
  }
  oneof version { GetIdentityTokenInfosRequestV0 v0 = 1; }
}

message GetIdentityTokenInfosResponse {
  message GetIdentityTokenInfosResponseV0 {
    message TokenIdentityInfoEntry { bool frozen = 1; }

    message TokenInfoEntry {
      bytes token_id = 1;
      optional TokenIdentityInfoEntry info = 2;
    }

    message TokenInfos { repeated TokenInfoEntry token_infos = 1; }

    oneof result {
      TokenInfos token_infos = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetIdentityTokenInfosResponseV0 v0 = 1; }
}

message GetIdentitiesTokenInfosRequest {
  message GetIdentitiesTokenInfosRequestV0 {
    bytes token_id = 1;
    repeated bytes identity_ids = 2;
    bool prove = 3;
  }
  oneof version { GetIdentitiesTokenInfosRequestV0 v0 = 1; }
}

message GetIdentitiesTokenInfosResponse {
  message GetIdentitiesTokenInfosResponseV0 {
    message TokenIdentityInfoEntry { bool frozen = 1; }

    message TokenInfoEntry {
      bytes identity_id = 1;
      optional TokenIdentityInfoEntry info = 2;
    }

    message IdentityTokenInfos { repeated TokenInfoEntry token_infos = 1; }

    oneof result {
      IdentityTokenInfos identity_token_infos = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetIdentitiesTokenInfosResponseV0 v0 = 1; }
}

message GetTokenStatusesRequest {
  message GetTokenStatusesRequestV0 {
    repeated bytes token_ids = 1;
    bool prove = 2;
  }
  oneof version { GetTokenStatusesRequestV0 v0 = 1; }
}

message GetTokenStatusesResponse {
  message GetTokenStatusesResponseV0 {
    message TokenStatusEntry {
      bytes token_id = 1;
      optional bool paused = 2;
    }

    message TokenStatuses { repeated TokenStatusEntry token_statuses = 1; }

    oneof result {
      TokenStatuses token_statuses = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetTokenStatusesResponseV0 v0 = 1; }
}

// Retrieve direct purchase prices defined for one or more tokens.
//
// Some tokens can have a direct purchase price defined using
// `TokenSetPriceForDirectPurchaseTransition` (see `dpp` crate for details).
// This request retrieves the direct purchase prices for those tokens and
// returns [GetTokenDirectPurchasePricesResponse].
message GetTokenDirectPurchasePricesRequest {
  message GetTokenDirectPurchasePricesRequestV0 {
    // List of token IDs to get prices for.
    //
    // The list must not be empty.
    // Token IDs must have 32 bytes and be unique.
    // Results for non-unique token IDs are undefined.
    repeated bytes token_ids = 1;
    // Whether to return proofs for the response, or just direct response.
    bool prove = 2;
  }
  oneof version { GetTokenDirectPurchasePricesRequestV0 v0 = 1; }
}


// Response to GetTokenDirectPurchasePricesRequest, containing information about
// direct purchase prices defined for requested token IDs.
message GetTokenDirectPurchasePricesResponse {
  message GetTokenDirectPurchasePricesResponseV0 {
    // Contains the individual price tier for a specific quantity of tokens.
    message PriceForQuantity {
      // Minimum quantity of tokens to purchase to get this price.
      uint64 quantity = 1;
      // Price for the specified quantity of tokens.
      uint64 price = 2;
    }

    // Contains list of price tiers for a specific token.
    message PricingSchedule {
      repeated PriceForQuantity price_for_quantity = 1;
    }

    message TokenDirectPurchasePriceEntry {
      // 32-byte token identifier
      bytes token_id = 1;

      // Price of the token; optional
      oneof price {
        // Fixed price for the token.
        uint64 fixed_price = 2;
        // Tiered pricing for the token, where the price varies based on the
        // quantity purchased.
        PricingSchedule variable_price = 3;
      }
    }
    // For each requested token, contains list of token IDs and their
    // corresponding direct purchase prices.
    message TokenDirectPurchasePrices {
      repeated TokenDirectPurchasePriceEntry token_direct_purchase_price = 1;
    }

    oneof result {
      // Contains the list of token IDs and their corresponding direct
      TokenDirectPurchasePrices token_direct_purchase_prices = 1;
      // Requested information in a form of cryptographic proof.
      // In Rust, use `FromProof` trait to convert it to the actual data.
      Proof proof = 2;
    }
    // Metadata about the blockchain state.
    ResponseMetadata metadata = 3;
  }
  oneof version { GetTokenDirectPurchasePricesResponseV0 v0 = 1; }
}

// Request to retrieve token contract info for a specific token ID.
message GetTokenContractInfoRequest {
  message GetTokenContractInfoRequestV0 {
    // The token ID to retrieve contract info for.
    // Must be exactly 32 bytes.
    bytes token_id = 1;

    // Whether to return a cryptographic proof.
    bool prove = 2;
  }

  oneof version {
    GetTokenContractInfoRequestV0 v0 = 1;
  }
}

// Response to GetTokenContractInfoRequest.
message GetTokenContractInfoResponse {
  message GetTokenContractInfoResponseV0 {
    // Direct token contract info.
    message TokenContractInfoData {
      // The ID of the contract associated with the token.
      bytes contract_id = 1;

      // The position of the token within the contract.
      uint32 token_contract_position = 2;
    }

    oneof result {
      // Direct token contract data
      TokenContractInfoData data = 1;

      // Cryptographic proof of token contract info
      Proof proof = 2;
    }

    // Metadata about the blockchain state at the time of the query
    ResponseMetadata metadata = 3;
  }

  oneof version {
    GetTokenContractInfoResponseV0 v0 = 1;
  }
}

message GetTokenPreProgrammedDistributionsRequest {
  message GetTokenPreProgrammedDistributionsRequestV0 {
    bytes token_id = 1;
    message StartAtInfo {
      uint64 start_time_ms = 1;
      optional bytes start_recipient = 2;
      optional bool start_recipient_included = 3;
    }
    optional StartAtInfo start_at_info = 2;
    optional uint32 limit = 3;
    bool prove = 4;
  }
  oneof version { GetTokenPreProgrammedDistributionsRequestV0 v0 = 1; }
}

message GetTokenPreProgrammedDistributionsResponse {
  message GetTokenPreProgrammedDistributionsResponseV0 {
    message TokenDistributionEntry {
      bytes recipient_id = 1;
      uint64 amount = 2;
    }

    message TokenTimedDistributionEntry {
      uint64 timestamp = 1;
      repeated TokenDistributionEntry distributions = 2;
    }

    message TokenDistributions {
      repeated TokenTimedDistributionEntry token_distributions = 1;
    }

    oneof result {
      TokenDistributions token_distributions = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetTokenPreProgrammedDistributionsResponseV0 v0 = 1; }
}

// 
//  Get the lastclaim information for a tokens perpetual distribution
// 

message GetTokenPerpetualDistributionLastClaimRequest {

  message ContractTokenInfo {
    bytes contract_id = 1;
    // the token contract position
    uint32 token_contract_position = 2;
  }

  message GetTokenPerpetualDistributionLastClaimRequestV0 {
    // 32byte token identifier
    bytes token_id   = 1;

    // This should be set if you wish to get back the last claim info as a specific type
    optional ContractTokenInfo contract_info = 2;

    // Identity whose lastclaim timestamp is requested
    bytes identity_id = 4;
    // Return GroveDB / signature proof instead of raw value
    bool  prove       = 5;
  }

  oneof version { GetTokenPerpetualDistributionLastClaimRequestV0 v0 = 1; }
}

message GetTokenPerpetualDistributionLastClaimResponse {
  message GetTokenPerpetualDistributionLastClaimResponseV0 {
    message LastClaimInfo {

      oneof paid_at {
        uint64 timestamp_ms = 1 [ jstype = JS_STRING ]; // Unix epoch, ms
        uint64 block_height = 2 [ jstype = JS_STRING ]; // Coreblock height
        uint32 epoch        = 3;                       // Epoch index
        bytes  raw_bytes    = 4;                       // Arbitrary encoding
      }
    }

    oneof result {
      LastClaimInfo last_claim = 1; // Direct answer
      Proof         proof      = 2; // GroveDB / quorum proof
    }

    ResponseMetadata metadata = 3;  // Chain context
  }

  oneof version { GetTokenPerpetualDistributionLastClaimResponseV0 v0 = 1; }
}

message GetTokenTotalSupplyRequest {
  message GetTokenTotalSupplyRequestV0 {
    bytes token_id = 1;
    bool prove = 2;
  }
  oneof version {GetTokenTotalSupplyRequestV0 v0 = 1;}
}

message GetTokenTotalSupplyResponse {
  message GetTokenTotalSupplyResponseV0 {
    message TokenTotalSupplyEntry {
      bytes token_id = 1;
      uint64 total_aggregated_amount_in_user_accounts = 2;
      uint64 total_system_amount = 3;
    }

    oneof result {
      TokenTotalSupplyEntry token_total_supply = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetTokenTotalSupplyResponseV0 v0 = 1; }
}

message GetGroupInfoRequest {
  message GetGroupInfoRequestV0 {
    bytes contract_id = 1;
    uint32 group_contract_position = 2;
    bool prove = 3;
  }
  oneof version { GetGroupInfoRequestV0 v0 = 1; }
}

message GetGroupInfoResponse {
  message GetGroupInfoResponseV0 {
    message GroupMemberEntry {
      bytes member_id = 1;
      uint32 power = 2;
    }

    message GroupInfoEntry {
      repeated GroupMemberEntry members = 1;
      uint32 group_required_power = 2;
    }

    message GroupInfo { optional GroupInfoEntry group_info = 1; }

    oneof result {
      GroupInfo group_info = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 4;
  }
  oneof version { GetGroupInfoResponseV0 v0 = 1; }
}

message GetGroupInfosRequest {
  message StartAtGroupContractPosition {
    uint32 start_group_contract_position = 1;
    bool start_group_contract_position_included = 2;
  }

  message GetGroupInfosRequestV0 {
    bytes contract_id = 1;
    optional StartAtGroupContractPosition start_at_group_contract_position = 2;
    optional uint32 count = 3;
    bool prove = 4;
  }
  oneof version { GetGroupInfosRequestV0 v0 = 1; }
}

message GetGroupInfosResponse {
  message GetGroupInfosResponseV0 {
    message GroupMemberEntry {
      bytes member_id = 1;
      uint32 power = 2;
    }

    message GroupPositionInfoEntry {
      uint32 group_contract_position = 1;
      repeated GroupMemberEntry members = 2;
      uint32 group_required_power = 3;
    }

    message GroupInfos { repeated GroupPositionInfoEntry group_infos = 1; }

    oneof result {
      GroupInfos group_infos = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 4;
  }
  oneof version { GetGroupInfosResponseV0 v0 = 1; }
}

message GetGroupActionsRequest {
  enum ActionStatus {
    ACTIVE = 0; // Request the active actions
    CLOSED = 1; // Request the closed actions
  }

  message StartAtActionId {
    bytes start_action_id = 1;
    bool start_action_id_included = 2;
  }

  message GetGroupActionsRequestV0 {
    bytes contract_id = 1;
    uint32 group_contract_position = 2;
    ActionStatus status = 3;
    optional StartAtActionId start_at_action_id = 4;
    optional uint32 count = 5;
    bool prove = 6;
  }
  oneof version { GetGroupActionsRequestV0 v0 = 1; }
}

message GetGroupActionsResponse {
  message GetGroupActionsResponseV0 {
    // Mint event
    message MintEvent {
      uint64 amount = 1;               // Amount to mint
      bytes recipient_id = 2;          // Recipient identifier
      optional string public_note = 3; // Public note
    }

    // Burn event
    message BurnEvent {
      uint64 amount = 1;               // Amount to burn
      bytes burn_from_id = 2;          // The identifier to burn from
      optional string public_note = 3; // Public note
    }

    // Freeze event
    message FreezeEvent {
      bytes frozen_id = 1;             // Identifier of the frozen entity
      optional string public_note = 2; // Public note
    }

    // Unfreeze event
    message UnfreezeEvent {
      bytes frozen_id = 1;             // Identifier of the unfrozen entity
      optional string public_note = 2; // Public note
    }

    // Destroy frozen funds event
    message DestroyFrozenFundsEvent {
      bytes frozen_id = 1;             // Identifier of the frozen entity
      uint64 amount = 2;               // Amount to destroy
      optional string public_note = 3; // Public note
    }

    // Shared encrypted note
    message SharedEncryptedNote {
      uint32 sender_key_index = 1;    // Sender key index
      uint32 recipient_key_index = 2; // Recipient key index
      bytes encrypted_data = 3;       // Encrypted data
    }

    // Personal encrypted note
    message PersonalEncryptedNote {
      uint32 root_encryption_key_index = 1; // Root encryption key index
      uint32 derivation_encryption_key_index =
          2;                    // Derivation encryption key index
      bytes encrypted_data = 3; // Encrypted data
    }

    // Emergency action event
    message EmergencyActionEvent {
      // Enum for emergency action types
      enum ActionType {
        PAUSE = 0;  // Pause action
        RESUME = 1; // Resume action
      }

      ActionType action_type = 1;      // Emergency action type
      optional string public_note = 2; // Public note
    }

    // Token config update event
    message TokenConfigUpdateEvent {
      bytes token_config_update_item = 1; // Token config update item
      optional string public_note = 2;    // Public note
    }

    // UpdatePrice event
    message UpdateDirectPurchasePriceEvent {
      message PriceForQuantity {
        uint64 quantity = 1;
        uint64 price = 2;
      }

      message PricingSchedule {
        repeated PriceForQuantity price_for_quantity = 1;
      }
      oneof price {
        uint64 fixed_price = 1;
        PricingSchedule variable_price = 2;
      }
      optional string public_note = 3; // Public note
    }

    // Event associated with this action
    message GroupActionEvent {
      oneof event_type {
        TokenEvent token_event = 1; // Token event details
        DocumentEvent document_event = 2;
        ContractEvent contract_event = 3;
      }
    }

    message DocumentEvent {
      oneof type {
        DocumentCreateEvent create = 1; // Create event details
      }
    }

    message DocumentCreateEvent { bytes created_document = 1; }

    message ContractUpdateEvent { bytes updated_contract = 1; }

    message ContractEvent {
      oneof type {
        ContractUpdateEvent update = 1; // Contract update event
      }
    }

    // Details for token events
    message TokenEvent {
      oneof type {
        MintEvent mint = 1;         // Mint event details
        BurnEvent burn = 2;         // Burn event details
        FreezeEvent freeze = 3;     // Freeze event details
        UnfreezeEvent unfreeze = 4; // Unfreeze event details
        DestroyFrozenFundsEvent destroy_frozen_funds =
            5;                                     // Destroy frozen funds
        EmergencyActionEvent emergency_action = 6; // Emergency action details
        TokenConfigUpdateEvent token_config_update =
            7; // Token configuration update details
        UpdateDirectPurchasePriceEvent update_price =
            8; // Updating the token direct selling price
      }
    }

    message GroupActionEntry {
      bytes action_id = 1;        // Unique identifier for the action
      GroupActionEvent event = 2; // The event data
    }

    message GroupActions { repeated GroupActionEntry group_actions = 1; }

    oneof result {
      GroupActions group_actions = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }
  oneof version { GetGroupActionsResponseV0 v0 = 1; }
}

message GetGroupActionSignersRequest {
  enum ActionStatus {
    ACTIVE = 0; // Request the active actions
    CLOSED = 1; // Request the closed actions
  }

  message GetGroupActionSignersRequestV0 {
    bytes contract_id = 1;
    uint32 group_contract_position = 2;
    ActionStatus status = 3;
    bytes action_id = 4;
    bool prove = 5;
  }
  oneof version { GetGroupActionSignersRequestV0 v0 = 1; }
}

message GetGroupActionSignersResponse {
  message GetGroupActionSignersResponseV0 {
    message GroupActionSigner {
      bytes signer_id = 1;
      uint32 power = 2;
    }
    message GroupActionSigners { repeated GroupActionSigner signers = 1; }

    oneof result {
      GroupActionSigners group_action_signers = 1;
      Proof proof = 2;
    }
    ResponseMetadata metadata = 3;
  }

  oneof version { GetGroupActionSignersResponseV0 v0 = 1; }
}
