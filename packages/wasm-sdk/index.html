<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f5f5;
    }

    #preloader {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 5px;
      z-index: 1000;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .sidebar {
      width: 450px;
      background-color: white;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .network-toggle {
      padding: 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
    }

    .network-toggle label {
      margin-right: 15px;
      font-weight: 500;
      color: #333;
    }

    .network-indicator {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 3px;
      margin-left: 10px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .network-indicator.testnet {
      background-color: #ff9800;
      color: white;
    }

    .network-indicator.mainnet {
      background-color: #4caf50;
      color: white;
    }

    .query-container {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
    }

    .query-selector {
      margin-bottom: 20px;
    }

    .query-selector select {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
      margin-bottom: 10px;
    }

    .query-inputs {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .input-group {
      margin-bottom: 15px;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
    }
    
    .input-group input[type="text"],
    .input-group input[type="password"] {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .query-inputs h4 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 1em;
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-size: 0.9em;
    }

    .input-group input,
    .input-group select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }

    .input-group input[type="checkbox"] {
      width: auto;
      margin-right: 5px;
    }

    .input-group input[type="number"] {
      -moz-appearance: textfield;
    }

    .input-group input[type="number"]::-webkit-inner-spin-button,
    .input-group input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .optional-label {
      color: #888;
      font-size: 0.85em;
      font-style: italic;
    }

    .execute-button {
      width: 100%;
      padding: 12px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .execute-button:hover {
      background-color: #1565c0;
    }

    .execute-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .result-container {
      flex: 1;
      background-color: white;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .result-header {
      padding: 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .result-header h2 {
      margin: 0;
      color: #333;
      font-size: 1.3em;
    }

    .result-actions button {
      margin-left: 10px;
      padding: 8px 16px;
      border: 1px solid #ddd;
      background-color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .result-actions button:hover {
      background-color: #f5f5f5;
    }

    .result-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .result-content.empty {
      color: #888;
      font-style: italic;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    .status-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 10px 20px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
      z-index: 999;
      transition: all 0.3s ease;
    }

    .status-banner.success {
      background-color: #4caf50;
      color: white;
    }

    .status-banner.error {
      background-color: #f44336;
      color: white;
    }

    .status-banner.loading {
      background-color: #ff9800;
      color: white;
    }

    .error-result {
      color: #d32f2f;
      background-color: #ffebee;
      border: 1px solid #ffcdd2;
      border-radius: 4px;
      padding: 10px;
    }
    
    .credits-value {
      color: #1976d2;
      cursor: help;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
      position: relative;
    }
    
    .credits-value:hover {
      background-color: #e3f2fd;
      border-radius: 3px;
      padding: 0 2px;
    }
    
    .credits-value::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      margin-bottom: 5px;
      z-index: 1000;
    }
    
    .credits-value:hover::after {
      opacity: 1;
    }
    
    .json-key {
      color: #d73a49;
      font-weight: 500;
    }
    
    .result-content pre {
      margin: 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }

    .mode-selector {
      margin-bottom: 15px;
      display: none;
    }

    .array-input-container {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      background-color: #fafafa;
    }

    .array-item {
      display: flex;
      gap: 10px;
      margin-bottom: 5px;
    }

    .array-item input {
      flex: 1;
    }

    .array-item button {
      padding: 5px 10px;
      background-color: #ff5252;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .add-array-item {
      padding: 5px 15px;
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 5px;
    }

    .query-description {
      font-size: 0.85em;
      color: #666;
      margin-bottom: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 4px;
      line-height: 1.4;
    }

    .action-button {
      padding: 8px 16px;
      background-color: #2196f3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    .action-button:hover {
      background-color: #1976d2;
    }

    .dynamic-fields-container {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fafafa;
    }

    .field-group {
      margin-bottom: 10px;
      padding: 8px;
      background-color: white;
      border-radius: 4px;
    }

    .field-group label {
      display: inline-block;
      width: 150px;
      font-weight: 500;
    }

    .where-field-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .operator-select {
      width: 120px;
    }

    .where-value-input {
      flex: 1;
    }
  </style>
</head>

<body>
  <div id="preloader">Loading...</div>
  
  <div class="app-container">
    <div class="sidebar">
      <div class="network-toggle">
        <label>Network:</label>
        <input type="radio" id="mainnet" name="network" value="mainnet">
        <label for="mainnet">Mainnet</label>
        <input type="radio" id="testnet" name="network" value="testnet">
        <label for="testnet">Testnet</label>
        <span id="networkIndicator" class="network-indicator mainnet">MAINNET</span>
        <br>
        <label style="margin-top: 10px; display: block;">
          <input type="checkbox" id="trustedMode" style="margin-right: 5px;" checked disabled>
          Trusted Quorums Mode
        </label>
      </div>
      
      <div class="query-container">
        <div class="query-selector">
          <select id="operationType">
            <option value="queries">Queries</option>
            <option value="transitions">State Transitions</option>
          </select>
          
          <select id="queryCategory">
            <option value="">Select Query Category</option>
            <option value="identity">Identity Queries</option>
            <option value="dataContract">Data Contract Queries</option>
            <option value="document">Document Queries</option>
            <option value="voting">Voting & Contested Resources</option>
            <option value="protocol">Protocol & Version</option>
            <option value="epoch">Epoch & Block</option>
            <option value="token">Token Queries</option>
            <option value="group">Group Queries</option>
            <option value="system">System & Utility</option>
          </select>
          
          <select id="queryType" style="display: none;">
            <option value="">Select Query Type</option>
          </select>
        </div>
        
        <div id="authenticationInputs" class="query-inputs" style="display: none;">
          <h4>Authentication</h4>
          <div class="input-group">
            <label for="identityId">Identity ID</label>
            <input type="text" id="identityId" placeholder="Enter identity ID">
          </div>
          <div class="input-group">
            <label for="privateKey">Private Key (WIF or hex)</label>
            <input type="password" id="privateKey" placeholder="Enter private key (WIF or 32-byte hex)">
          </div>
        </div>
        
        <div id="queryDescription" class="query-description" style="display: none;"></div>
        
        <div id="queryInputs" class="query-inputs" style="display: none;">
          <h4 id="queryTitle">Query Parameters</h4>
          <div id="dynamicInputs"></div>
        </div>
        
        <button id="executeQuery" class="execute-button" style="display: none;">Execute Query</button>
      </div>
    </div>
    
    <div class="result-container">
      <div class="result-header">
        <h2>Results</h2>
        <div class="result-actions">
          <button id="clearButton" onclick="clearResults()">Clear</button>
          <button id="copyButton" onclick="copyResults()">Copy</button>
          <button id="clearCacheButton" onclick="clearCache()" title="Clear WASM cache and reload">Clear Cache</button>
        </div>
      </div>
      <div id="identityInfo" class="result-content empty">No data fetched yet. Select a query category and type to begin.</div>
    </div>
  </div>

  <div id="statusBanner" class="status-banner loading">Initializing WASM SDK...</div>

  <script>
    // Global functions for button actions
    function clearResults() {
      document.getElementById('identityInfo').textContent = '';
      document.getElementById('identityInfo').classList.add('empty');
      document.getElementById('identityInfo').classList.remove('error');
      if (typeof currentResult !== 'undefined') {
        currentResult = null;
      }
    }
    
    function copyResults() {
      const content = document.getElementById('identityInfo').textContent;
      navigator.clipboard.writeText(content).then(() => {
        const button = document.getElementById('copyButton');
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }
    
    async function clearCache() {
      const button = document.getElementById('clearCacheButton');
      const originalText = button.textContent;
      button.textContent = 'Clearing...';
      button.disabled = true;
      
      try {
        // Clear service worker cache
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          // Use MessageChannel for response
          const channel = new MessageChannel();
          channel.port1.onmessage = (event) => {
            console.log('Cache cleared:', event.data);
          };
          navigator.serviceWorker.controller.postMessage(
            { action: 'clearCache' }, 
            [channel.port2]
          );
        }
        
        // Clear browser caches
        if ('caches' in window) {
          const cacheNames = await caches.keys();
          await Promise.all(
            cacheNames.map(cacheName => caches.delete(cacheName))
          );
        }
        
        button.textContent = 'Cache Cleared!';
        
        // Reload after a short delay
        setTimeout(() => {
          window.location.reload(true);
        }, 1000);
        
      } catch (error) {
        console.error('Failed to clear cache:', error);
        button.textContent = 'Failed';
        setTimeout(() => {
          button.textContent = originalText;
          button.disabled = false;
        }, 2000);
      }
    }
    
    // Register service worker for caching
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker-simple.js')
          .then(registration => {
            console.log('ServiceWorker registration successful:', registration.scope);
            
            // Check for updates periodically
            setInterval(() => {
              registration.update();
            }, 60 * 60 * 1000); // Check every hour
            
            // Listen for updates from service worker
            navigator.serviceWorker.addEventListener('message', event => {
              if (event.data.type === 'cache-updated') {
                console.log('Cache updated:', event.data.oldCache, '->', event.data.newCache);
                
                // Show notification to user
                const banner = document.getElementById('statusBanner');
                if (banner && !banner.querySelector('button')) {
                  banner.textContent = 'New version detected! Refresh to update.';
                  banner.className = 'status-banner warning';
                  
                  // Add refresh button
                  const refreshBtn = document.createElement('button');
                  refreshBtn.textContent = 'Refresh Now';
                  refreshBtn.style.marginLeft = '10px';
                  refreshBtn.onclick = () => window.location.reload(true);
                  banner.appendChild(refreshBtn);
                }
              }
            });
          })
          .catch(err => {
            console.log('ServiceWorker registration failed:', err);
          });
      });
    }
  </script>

  <script type="module">
    // Add performance timing
    const startTime = performance.now();
    console.log('[Performance] Starting WASM module load...');
    
    import init, { 
      WasmSdkBuilder, 
      identity_fetch, 
      data_contract_fetch, 
      prefetch_trusted_quorums_mainnet, 
      prefetch_trusted_quorums_testnet,
      // Identity queries
      get_identity_keys,
      get_identity_nonce,
      get_identity_contract_nonce,
      get_identity_balance,
      get_identities_balances,
      get_identity_balance_and_revision,
      get_identity_by_public_key_hash,
      get_identities_contract_keys,
      get_identity_by_non_unique_public_key_hash,
      get_identity_token_balances,
      // Data contract queries
      get_data_contract_history,
      get_data_contracts,
      // Document queries
      get_documents,
      get_document,
      // Protocol/Version queries
      get_protocol_version_upgrade_state,
      get_protocol_version_upgrade_vote_status,
      // Epoch/Block queries
      get_epochs_info,
      get_finalized_epoch_infos,
      get_current_epoch,
      get_evonodes_proposed_epoch_blocks_by_ids,
      get_evonodes_proposed_epoch_blocks_by_range,
      // System/Utility queries
      get_status,
      get_total_credits_in_platform,
      get_current_quorums_info,
      get_prefunded_specialized_balance,
      get_path_elements,
      wait_for_state_transition_result,
      // Token queries
      get_identities_token_balances,
      get_identity_token_infos,
      get_identities_token_infos,
      get_token_statuses,
      get_token_direct_purchase_prices,
      get_token_contract_info,
      get_token_perpetual_distribution_last_claim,
      get_token_total_supply,
      // Voting/Contested Resource queries
      get_contested_resources,
      get_contested_resource_vote_state,
      get_contested_resource_voters_for_identity,
      get_contested_resource_identity_votes,
      get_vote_polls_by_end_date,
      // Group queries
      get_group_info,
      get_group_infos,
      get_group_actions,
      get_group_action_signers
    } from './pkg/wasm_sdk.js';
    
    // Import all placeholder query functions
    import * as queryFunctions from './pkg/wasm_sdk.js';

    let sdk = null;
    let currentResult = null;
    let initRequestCounter = 0;
    
    // State Transition definitions
    const stateTransitionDefinitions = {
      identity: {
        label: "Identity Transitions",
        transitions: {
          identityCreate: {
            label: "Identity Create",
            description: "Create a new identity with initial credits",
            inputs: [
              { name: "publicKeys", type: "keyArray", label: "Public Keys", required: true },
              { name: "assetLockProof", type: "assetLockProof", label: "Asset Lock Proof", required: true }
            ]
          },
          identityTopUp: {
            label: "Identity Top Up",
            description: "Add credits to an existing identity",
            inputs: [
              { name: "assetLockProof", type: "assetLockProof", label: "Asset Lock Proof", required: true }
            ]
          },
          identityUpdate: {
            label: "Identity Update",
            description: "Update identity keys (add or disable)",
            inputs: [
              { name: "addPublicKeys", type: "textarea", label: "Keys to Add (JSON array)", required: false, 
                placeholder: '[{"keyType":"ECDSA_HASH160","purpose":"AUTHENTICATION","data":"base64_key_data"}]' },
              { name: "disablePublicKeys", type: "text", label: "Key IDs to Disable (comma-separated)", required: false,
                placeholder: "2,3,5" }
            ]
          },
          identityCreditTransfer: {
            label: "Identity Credit Transfer",
            description: "Transfer credits between identities",
            inputs: [
              { name: "recipientId", type: "text", label: "Recipient Identity ID", required: true },
              { name: "amount", type: "number", label: "Amount (credits)", required: true }
            ]
          },
          identityCreditWithdrawal: {
            label: "Identity Credit Withdrawal",
            description: "Withdraw credits from identity to Dash address",
            inputs: [
              { name: "toAddress", type: "text", label: "Dash Address", required: true },
              { name: "amount", type: "number", label: "Amount (credits)", required: true },
              { name: "coreFeePerByte", type: "number", label: "Core Fee Per Byte (optional)", required: false }
            ]
          }
        }
      },
      dataContract: {
        label: "Data Contract Transitions",
        transitions: {
          dataContractCreate: {
            label: "Data Contract Create",
            description: "Create a new data contract",
            inputs: [
              { name: "canBeDeleted", type: "checkbox", label: "Can Be Deleted", required: false },
              { name: "readonly", type: "checkbox", label: "Read Only", required: false },
              { name: "keepsHistory", type: "checkbox", label: "Keeps History", required: false },
              { name: "documentsKeepHistoryContractDefault", type: "checkbox", label: "Documents Keep History (Default)", required: false },
              { name: "documentsMutableContractDefault", type: "checkbox", label: "Documents Mutable (Default)", required: false, defaultValue: true },
              { name: "documentsCanBeDeletedContractDefault", type: "checkbox", label: "Documents Can Be Deleted (Default)", required: false, defaultValue: true },
              { name: "requiresIdentityEncryptionBoundedKey", type: "text", label: "Requires Identity Encryption Key (optional)", required: false },
              { name: "requiresIdentityDecryptionBoundedKey", type: "text", label: "Requires Identity Decryption Key (optional)", required: false },
              { name: "documentSchemas", type: "json", label: "Document Schemas JSON", required: true, placeholder: '{\n  "note": {\n    "type": "object",\n    "properties": {\n      "message": {\n        "type": "string",\n        "maxLength": 100,\n        "position": 0\n      }\n    },\n    "required": ["message"],\n    "additionalProperties": false\n  }\n}' },
              { name: "groups", type: "json", label: "Groups (optional)", required: false, placeholder: '{}' },
              { name: "tokens", type: "json", label: "Tokens (optional)", required: false, placeholder: '{}' },
              { name: "keywords", type: "text", label: "Keywords (comma separated, optional)", required: false },
              { name: "description", type: "text", label: "Description (optional)", required: false }
            ]
          },
          dataContractUpdate: {
            label: "Data Contract Update",
            description: "Add document types, groups, or tokens to an existing data contract",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "newDocumentSchemas", type: "json", label: "New Document Schemas to Add (optional)", required: false, placeholder: '{\n  "newType": {\n    "type": "object",\n    "properties": {\n      "field": {\n        "type": "string",\n        "maxLength": 100,\n        "position": 0\n      }\n    },\n    "required": ["field"],\n    "additionalProperties": false\n  }\n}' },
              { name: "newGroups", type: "json", label: "New Groups to Add (optional)", required: false, placeholder: '{}' },
              { name: "newTokens", type: "json", label: "New Tokens to Add (optional)", required: false, placeholder: '{}' }
            ]
          }
        }
      },
      document: {
        label: "Document Transitions",
        transitions: {
          documentCreate: {
            label: "Document Create",
            description: "Create a new document",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "fetchSchema", type: "button", label: "Fetch Schema", action: "fetchDocumentSchema" },
              { name: "documentFields", type: "dynamic", label: "Document Fields" }
            ]
          },
          documentReplace: {
            label: "Document Replace",
            description: "Replace an existing document",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true },
              { name: "loadDocument", type: "button", label: "Load Document", action: "loadExistingDocument" },
              { name: "documentFields", type: "dynamic", label: "Document Fields" }
            ]
          },
          documentDelete: {
            label: "Document Delete",
            description: "Delete an existing document",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true }
            ]
          },
          documentTransfer: {
            label: "Document Transfer",
            description: "Transfer document ownership",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true },
              { name: "recipientId", type: "text", label: "Recipient Identity ID", required: true }
            ]
          },
          documentPurchase: {
            label: "Document Purchase",
            description: "Purchase a document",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true },
              { name: "price", type: "number", label: "Price (credits)", required: true }
            ]
          },
          documentSetPrice: {
            label: "Document Set Price",
            description: "Set or update document price (0 to remove price)",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true },
              { name: "price", type: "number", label: "Price (credits, 0 to remove)", required: true }
            ]
          }
        }
      },
      token: {
        label: "Token Transitions",
        transitions: {
          tokenBurn: {
            label: "Token Burn",
            description: "Burn tokens",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenPosition", type: "number", label: "Token Contract Position", required: true },
              { name: "amount", type: "text", label: "Amount to Burn", required: true },
              { name: "keyId", type: "number", label: "Key ID (for signing)", required: true },
              { name: "publicNote", type: "text", label: "Public Note", required: false }
            ]
          },
          tokenMint: {
            label: "Token Mint",
            description: "Mint new tokens",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenPosition", type: "number", label: "Token Contract Position", required: true },
              { name: "amount", type: "text", label: "Amount to Mint", required: true },
              { name: "keyId", type: "number", label: "Key ID (for signing)", required: true },
              { name: "issuedToIdentityId", type: "text", label: "Issue To Identity ID", required: false },
              { name: "publicNote", type: "text", label: "Public Note", required: false }
            ]
          },
          tokenTransfer: {
            label: "Token Transfer",
            description: "Transfer tokens to another identity",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenId", type: "text", label: "Token Contract Position", required: true },
              { name: "amount", type: "number", label: "Amount to Transfer", required: true },
              { name: "recipientId", type: "text", label: "Recipient Identity ID", required: true }
            ]
          },
          tokenFreeze: {
            label: "Token Freeze",
            description: "Freeze tokens for an identity",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenId", type: "text", label: "Token Contract Position", required: true },
              { name: "identityId", type: "text", label: "Identity ID to Freeze", required: true }
            ]
          },
          tokenUnfreeze: {
            label: "Token Unfreeze",
            description: "Unfreeze tokens for an identity",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenId", type: "text", label: "Token Contract Position", required: true },
              { name: "identityId", type: "text", label: "Identity ID to Unfreeze", required: true }
            ]
          },
          tokenDestroyFrozen: {
            label: "Token Destroy Frozen Funds",
            description: "Destroy frozen tokens",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true },
              { name: "tokenId", type: "text", label: "Token Contract Position", required: true },
              { name: "identityId", type: "text", label: "Identity ID", required: true }
            ]
          }
        }
      },
      voting: {
        label: "Voting Transitions",
        transitions: {
          dpnsUsername: {
            label: "DPNS Username",
            description: "Cast a vote for a contested DPNS username (simplified)",
            inputs: [
              { name: "contestedUsername", type: "text", label: "Contested Username", required: true,
                placeholder: "Enter the contested username (e.g., 'myusername')" },
              { name: "voteChoice", type: "select", label: "Vote Choice", required: true,
                options: [
                  { value: "abstain", label: "Abstain" },
                  { value: "lock", label: "Lock (Give to no one)" },
                  { value: "towardsIdentity", label: "Vote for Identity" }
                ]
              },
              { name: "targetIdentity", type: "text", label: "Target Identity ID (if voting for identity)", required: false,
                placeholder: "Identity ID to vote for",
                dependsOn: { field: "voteChoice", value: "towardsIdentity" } }
            ]
          },
          masternodeVote: {
            label: "Contested Resource",
            description: "Cast a vote for contested resources as a masternode",
            inputs: [
              { name: "contractId", type: "text", label: "Data Contract ID", required: true,
                placeholder: "Contract ID containing the contested resource" },
              { name: "fetchContestedResources", type: "button", label: "Get Contested Resources", action: "fetchContestedResources" },
              { name: "contestedResourceDropdown", type: "dynamic", label: "Contested Resources" },
              { name: "voteChoice", type: "select", label: "Vote Choice", required: true,
                options: [
                  { value: "abstain", label: "Abstain" },
                  { value: "lock", label: "Lock (Give to no one)" },
                  { value: "towardsIdentity", label: "Vote for Identity" }
                ]
              },
              { name: "targetIdentity", type: "text", label: "Target Identity ID (if voting for identity)", required: false,
                placeholder: "Identity ID to vote for",
                dependsOn: { field: "voteChoice", value: "towardsIdentity" } }
            ]
          }
        }
      }
    };

    // Query definitions
    const queryDefinitions = {
      identity: {
        label: "Identity Queries",
        queries: {
          getIdentity: {
            label: "Get Identity",
            description: "Fetch an identity by its identifier",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityKeys: {
            label: "Get Identity Keys",
            description: "Retrieve keys associated with an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "keyRequestType", type: "select", label: "Key Request Type", required: true, 
                options: [
                  { value: "all", label: "All Keys" },
                  { value: "specific", label: "Specific Keys" },
                  { value: "search", label: "Search Keys" }
                ]
              },
              { name: "specificKeyIds", type: "array", label: "Key IDs (for Specific Keys)", required: false, 
                dependsOn: { field: "keyRequestType", value: "specific" } },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false }
            ]
          },
          getIdentitiesContractKeys: {
            label: "Get Identities Contract Keys",
            description: "Get keys for multiple identities related to a specific contract",
            inputs: [
              { name: "identitiesIds", type: "array", label: "Identity IDs", required: true },
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: false },
              { name: "purposes", type: "multiselect", label: "Key Purposes", required: false,
                options: [
                  { value: "0", label: "Authentication" },
                  { value: "1", label: "Encryption" },
                  { value: "2", label: "Decryption" },
                  { value: "3", label: "Transfer" },
                  { value: "5", label: "Voting" }
                ]
              }
            ]
          },
          getIdentityNonce: {
            label: "Get Identity Nonce",
            description: "Get the current nonce for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityContractNonce: {
            label: "Get Identity Contract Nonce",
            description: "Get the nonce for an identity in relation to a specific contract",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "contractId", type: "text", label: "Contract ID", required: true }
            ]
          },
          getIdentityBalance: {
            label: "Get Identity Balance",
            description: "Get the credit balance of an identity",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentitiesBalances: {
            label: "Get Identities Balances",
            description: "Get balances for multiple identities",
            inputs: [
              { name: "ids", type: "array", label: "Identity IDs", required: true }
            ]
          },
          getIdentityBalanceAndRevision: {
            label: "Get Identity Balance and Revision",
            description: "Get both balance and revision number for an identity",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityByPublicKeyHash: {
            label: "Get Identity by Public Key Hash",
            description: "Find an identity by its unique public key hash",
            inputs: [
              { name: "publicKeyHash", type: "text", label: "Public Key Hash", required: true }
            ]
          },
          getIdentityByNonUniquePublicKeyHash: {
            label: "Get Identity by Non-Unique Public Key Hash",
            description: "Find identities by non-unique public key hash",
            inputs: [
              { name: "publicKeyHash", type: "text", label: "Public Key Hash", required: true },
              { name: "startAfter", type: "text", label: "Start After (Identity ID)", required: false }
            ]
          },
          getIdentityTokenBalances: {
            label: "Get Identity Token Balances",
            description: "Get token balances for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getIdentitiesTokenBalances: {
            label: "Get Identities Token Balances",
            description: "Get token balance for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          },
          getIdentityTokenInfos: {
            label: "Get Identity Token Info",
            description: "Get token information for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenIds", type: "array", label: "Token IDs (optional)", required: false },
              { name: "withPurchaseInfo", type: "checkbox", label: "Include Purchase Info", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false }
            ]
          },
          getIdentitiesTokenInfos: {
            label: "Get Identities Token Info",
            description: "Get token information for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token Contract Position", required: true },
              { name: "withPurchaseInfo", type: "checkbox", label: "Include Purchase Info", required: false }
            ]
          }
        }
      },
      dataContract: {
        label: "Data Contract Queries",
        queries: {
          getDataContract: {
            label: "Get Data Contract",
            description: "Fetch a data contract by its identifier",
            inputs: [
              { name: "id", type: "text", label: "Data Contract ID", required: true }
            ]
          },
          getDataContractHistory: {
            label: "Get Data Contract History",
            description: "Get the version history of a data contract",
            inputs: [
              { name: "id", type: "text", label: "Data Contract ID", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "startAtMs", type: "number", label: "Start At (ms)", required: false }
            ]
          },
          getDataContracts: {
            label: "Get Data Contracts",
            description: "Fetch multiple data contracts by their identifiers",
            inputs: [
              { name: "ids", type: "array", label: "Data Contract IDs", required: true }
            ]
          }
        }
      },
      document: {
        label: "Document Queries",
        queries: {
          getDocuments: {
            label: "Get Documents",
            description: "Query documents from a data contract",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "loadContract", type: "button", label: "Load Contract", action: "loadDataContractForDocuments" },
              { name: "indexSelector", type: "select", label: "Select Index", required: false, dynamic: true },
              { name: "whereFields", type: "dynamic", label: "Where Fields", required: false },
              { name: "orderByFields", type: "dynamic", label: "Order By Fields", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "startOption", type: "select", label: "Start Option", required: false,
                options: [
                  { value: "none", label: "None" },
                  { value: "startAfter", label: "Start After" },
                  { value: "startAt", label: "Start At" }
                ]
              },
              { name: "startValue", type: "text", label: "Start Value (Document ID)", required: false,
                dependsOn: { field: "startOption", value: ["startAfter", "startAt"] } }
            ]
          },
          getDocument: {
            label: "Get Document",
            description: "Fetch a specific document by ID",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true }
            ]
          }
        }
      },
      voting: {
        label: "Voting & Contested Resources",
        queries: {
          getContestedResources: {
            label: "Get Contested Resources",
            description: "Get list of contested resources",
            inputs: [
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "resultType", type: "select", label: "Result Type", required: true,
                options: [
                  { value: "documents", label: "Documents" },
                  { value: "vote_tally", label: "Vote Tally" },
                  { value: "document_with_vote_tally", label: "Document with Vote Tally" }
                ]
              },
              { name: "allowIncludeLockedAndAbstainingVoteTally", type: "checkbox", label: "Include Locked and Abstaining", required: false },
              { name: "startAtValue", type: "text", label: "Start At Value (hex bytes)", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceVoteState: {
            label: "Get Contested Resource Vote State",
            description: "Get the current vote state for a contested resource",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "resultType", type: "select", label: "Result Type", required: true,
                options: [
                  { value: "contenders", label: "Contenders" },
                  { value: "abstainers", label: "Abstainers" },
                  { value: "locked", label: "Locked" }
                ]
              },
              { name: "allowIncludeLockedAndAbstainingVoteTally", type: "checkbox", label: "Include Locked and Abstaining", required: false },
              { name: "startAtIdentifierInfo", type: "json", label: "Start At Identifier Info (JSON)", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceVotersForIdentity: {
            label: "Get Contested Resource Voters for Identity",
            description: "Get voters who voted for a specific identity in a contested resource",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "contestantId", type: "text", label: "Contestant ID", required: true },
              { name: "startAtIdentifierInfo", type: "json", label: "Start At Identifier Info (JSON)", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceIdentityVotes: {
            label: "Get Contested Resource Identity Votes",
            description: "Get all votes cast by a specific identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getVotePollsByEndDate: {
            label: "Get Vote Polls by End Date",
            description: "Get vote polls within a time range",
            inputs: [
              { name: "startTimeMs", type: "number", label: "Start Time (ms)", required: false },
              { name: "endTimeMs", type: "number", label: "End Time (ms)", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          }
        }
      },
      protocol: {
        label: "Protocol & Version",
        queries: {
          getProtocolVersionUpgradeState: {
            label: "Get Protocol Version Upgrade State",
            description: "Get the current state of protocol version upgrades",
            inputs: []
          },
          getProtocolVersionUpgradeVoteStatus: {
            label: "Get Protocol Version Upgrade Vote Status",
            description: "Get voting status for protocol version upgrades",
            inputs: [
              { name: "startProTxHash", type: "text", label: "Start ProTx Hash (optional - leave empty to start from beginning)", required: false },
              { name: "count", type: "number", label: "Count (default: 100)", required: false }
            ]
          }
        }
      },
      epoch: {
        label: "Epoch & Block",
        queries: {
          getEpochsInfo: {
            label: "Get Epochs Info",
            description: "Get information about epochs",
            inputs: [
              { name: "startEpoch", type: "number", label: "Start Epoch", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "ascending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          },
          getCurrentEpoch: {
            label: "Get Current Epoch",
            description: "Get information about the current epoch",
            inputs: []
          },
          getFinalizedEpochInfos: {
            label: "Get Finalized Epoch Info",
            description: "Get information about finalized epochs",
            inputs: [
              { name: "startEpoch", type: "number", label: "Start Epoch", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "ascending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          },
          getEvonodesProposedEpochBlocksByIds: {
            label: "Get Evonodes Proposed Epoch Blocks by IDs",
            description: "Get proposed blocks by evonode IDs",
            inputs: [
              { name: "epoch", type: "number", label: "Epoch", required: true },
              { name: "ids", type: "array", label: "Evonode IDs", required: true }
            ]
          },
          getEvonodesProposedEpochBlocksByRange: {
            label: "Get Evonodes Proposed Epoch Blocks by Range",
            description: "Get proposed blocks by range",
            inputs: [
              { name: "epoch", type: "number", label: "Epoch", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "startAfter", type: "text", label: "Start After (Evonode ID)", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          }
        }
      },
      token: {
        label: "Token Queries",
        queries: {
          getIdentitiesTokenBalances: {
            label: "Get Identities Token Balances",
            description: "Get token balances for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          },
          getIdentityTokenInfos: {
            label: "Get Identity Token Infos",
            description: "Get token information (frozen status) for specific tokens of an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenIds", type: "array", label: "Token IDs", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false }
            ]
          },
          getIdentitiesTokenInfos: {
            label: "Get Identities Token Infos",
            description: "Get token information (frozen status) for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          },
          getTokenStatuses: {
            label: "Get Token Statuses",
            description: "Get pause/unpause status for tokens",
            inputs: [
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getTokenDirectPurchasePrices: {
            label: "Get Token Direct Purchase Prices",
            description: "Get direct purchase prices for tokens",
            inputs: [
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getTokenContractInfo: {
            label: "Get Token Contract Info",
            description: "Get contract information for a token",
            inputs: [
              { name: "dataContractId", type: "text", label: "Token ID", required: true }
            ]
          },
          getTokenPerpetualDistributionLastClaim: {
            label: "Get Token Perpetual Distribution Last Claim",
            description: "Get last claim information for token perpetual distribution",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          },
          getTokenTotalSupply: {
            label: "Get Token Total Supply",
            description: "Get total supply information for a token",
            inputs: [
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          }
        }
      },
      group: {
        label: "Group Queries",
        queries: {
          getGroupInfo: {
            label: "Get Group Info",
            description: "Get information about a specific group",
            inputs: [
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "groupContractPosition", type: "number", label: "Group Contract Position", required: true }
            ]
          },
          getGroupInfos: {
            label: "Get Group Infos",
            description: "Get information about multiple groups",
            inputs: [
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "startAtGroupContractPosition", type: "number", label: "Start at Position", required: false },
              { name: "startGroupContractPositionIncluded", type: "checkbox", label: "Include Start Position", required: false },
              { name: "count", type: "number", label: "Count", required: false }
            ]
          },
          getGroupActions: {
            label: "Get Group Actions",
            description: "Get actions for a specific group",
            inputs: [
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "groupContractPosition", type: "number", label: "Group Contract Position", required: true },
              { name: "status", type: "select", label: "Status", required: true, options: [
                { value: "ACTIVE", label: "Active" },
                { value: "CLOSED", label: "Closed" }
              ]},
              { name: "startActionId", type: "text", label: "Start Action ID", required: false },
              { name: "startActionIdIncluded", type: "checkbox", label: "Include Start Action", required: false },
              { name: "count", type: "number", label: "Count", required: false }
            ]
          },
          getGroupActionSigners: {
            label: "Get Group Action Signers",
            description: "Get signers for a specific group action",
            inputs: [
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "groupContractPosition", type: "number", label: "Group Contract Position", required: true },
              { name: "status", type: "select", label: "Status", required: true, options: [
                { value: "ACTIVE", label: "Active" },
                { value: "CLOSED", label: "Closed" }
              ]},
              { name: "actionId", type: "text", label: "Action ID", required: true }
            ]
          }
        }
      },
      system: {
        label: "System & Utility",
        queries: {
          getStatus: {
            label: "Get Status",
            description: "Get node and network status information",
            inputs: []
          },
          getCurrentQuorumsInfo: {
            label: "Get Current Quorums Info",
            description: "Get information about current quorums",
            inputs: []
          },
          getPrefundedSpecializedBalance: {
            label: "Get Prefunded Specialized Balance",
            description: "Get prefunded balance for specialized transactions",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true }
            ]
          },
          getTotalCreditsInPlatform: {
            label: "Get Total Credits in Platform",
            description: "Get the total amount of credits in the platform",
            inputs: []
          },
          getPathElements: {
            label: "Get Path Elements",
            description: "Get elements at specific paths in the state tree",
            inputs: [
              { name: "keys", type: "array", label: "Keys (hex strings)", required: true }
            ]
          },
          waitForStateTransitionResult: {
            label: "Wait for State Transition Result",
            description: "Wait for a state transition to be processed",
            inputs: [
              { name: "stateTransitionHash", type: "text", label: "State Transition Hash", required: true }
            ]
          }
        }
      }
    };

    // Helper functions for result actions
    window.clearResults = function() {
      const resultContent = document.getElementById('identityInfo');
      resultContent.textContent = 'No data fetched yet. Select a query category and type to begin.';
      resultContent.className = 'result-content empty';
      currentResult = null;
    };

    window.copyResults = function() {
      if (!currentResult) {
        alert('No results to copy');
        return;
      }
      navigator.clipboard.writeText(JSON.stringify(currentResult, null, 2))
        .then(() => {
          const copyButton = document.getElementById('copyButton');
          const originalText = copyButton.textContent;
          copyButton.textContent = 'Copied!';
          setTimeout(() => {
            copyButton.textContent = originalText;
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy:', err);
          alert('Failed to copy to clipboard');
        });
    };

    // Function to load data contract and populate index selector
    window.loadDataContractForDocuments = async function() {
      const contractIdInput = document.querySelector('input[name="dataContractId"]');
      const documentTypeInput = document.querySelector('input[name="documentType"]');
      
      if (!contractIdInput?.value || !documentTypeInput?.value) {
        alert('Please enter both Data Contract ID and Document Type');
        return;
      }

      const contractId = contractIdInput.value;
      const documentType = documentTypeInput.value;
      
      try {
        updateStatus('Loading data contract...', 'loading');
        
        // Fetch the data contract
        const dataContract = await data_contract_fetch(sdk, contractId);
        const contractData = dataContract.toJSON();
        
        // Find the document type
        // Note: The serialized format uses 'documentSchemas' while internal representation might use 'documentTypes'
        const docType = contractData.documentSchemas?.[documentType];
        if (!docType) {
          throw new Error(`Document type '${documentType}' not found in contract`);
        }

        // Extract indexes
        const indexes = docType.indices || [];
        
        // Populate index selector
        const indexSelector = document.querySelector('select[name="indexSelector"]');
        if (indexSelector) {
          // Clear existing options
          indexSelector.innerHTML = '<option value="">Select an index</option>';
          
          // Add index options
          indexes.forEach((index, idx) => {
            const option = document.createElement('option');
            option.value = idx;
            option.textContent = index.name || `Index ${idx}`;
            option.dataset.indexData = JSON.stringify(index);
            indexSelector.appendChild(option);
          });

          // Show the selector
          indexSelector.parentElement.style.display = 'block';
        }

        // Add index change handler
        indexSelector.addEventListener('change', function() {
          const selectedOption = this.options[this.selectedIndex];
          if (selectedOption.value && selectedOption.dataset.indexData) {
            const indexData = JSON.parse(selectedOption.dataset.indexData);
            populateIndexFields(indexData, docType);
          } else {
            clearIndexFields();
          }
        });

        updateStatus('Data contract loaded successfully', 'success');
      } catch (error) {
        console.error('Error loading data contract:', error);
        updateStatus(`Error loading data contract: ${error.message}`, 'error');
      }
    };

    // Function to populate where and order by fields based on selected index
    function populateIndexFields(index, docType) {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (!whereContainer || !orderByContainer) return;

      // Clear existing fields
      whereContainer.innerHTML = '<h5>Where Conditions</h5>';
      orderByContainer.innerHTML = '<h5>Order By</h5>';

      // Extract properties from index
      const indexProperties = index.properties || [];
      
      // Create where fields for each indexed property
      indexProperties.forEach(prop => {
        // Properties are objects like {"records.identity": "asc"}
        let propName;
        let sortOrder;
        
        if (typeof prop === 'object' && !Array.isArray(prop)) {
          // Extract the property name and sort order from the object
          const keys = Object.keys(prop);
          if (keys.length > 0) {
            propName = keys[0];
            sortOrder = prop[propName];
          }
        } else if (typeof prop === 'string') {
          propName = prop;
        } else {
          return; // Skip invalid properties
        }
        
        if (!propName) return;
        
        // Where field
        const whereGroup = document.createElement('div');
        whereGroup.className = 'field-group where-field-group';
        
        const whereLabel = document.createElement('label');
        whereLabel.textContent = `${propName}:`;
        whereLabel.style.minWidth = '200px';
        
        // Operator dropdown
        const operatorSelect = document.createElement('select');
        operatorSelect.name = `whereOp_${propName}`;
        operatorSelect.className = 'operator-select';
        
        // Determine property type from schema if available
        const propDef = docType.properties?.[propName] || docType.properties?.[propName.split('.')[0]];
        const isStringType = propDef?.type === 'string' || propName.includes('label') || propName.includes('name');
        const isNumericType = propDef?.type === 'number' || propDef?.type === 'integer';
        const isArrayType = propDef?.type === 'array' || propDef?.byteArray;
        
        // Add common operators
        const operators = [
          { value: '==', label: '==' },
          { value: '!=', label: '!=' },
        ];
        
        if (isStringType) {
          operators.push(
            { value: 'startsWith', label: 'starts with' },
            { value: 'endsWith', label: 'ends with' },
            { value: 'contains', label: 'contains' }
          );
        }
        
        if (isNumericType || isArrayType) {
          operators.push(
            { value: '>', label: '>' },
            { value: '>=', label: '>=' },
            { value: '<', label: '<' },
            { value: '<=', label: '<=' }
          );
        }
        
        if (isArrayType) {
          operators.push(
            { value: 'in', label: 'in' },
            { value: 'contains', label: 'contains' },
            { value: 'elementMatch', label: 'element match' }
          );
        }
        
        operators.forEach(op => {
          const option = document.createElement('option');
          option.value = op.value;
          option.textContent = op.label;
          operatorSelect.appendChild(option);
        });
        
        // Value input
        const whereInput = document.createElement('input');
        whereInput.type = 'text';
        whereInput.name = `where_${propName}`;
        whereInput.placeholder = `Value`;
        whereInput.className = 'where-value-input';
        
        whereGroup.appendChild(whereLabel);
        whereGroup.appendChild(operatorSelect);
        whereGroup.appendChild(whereInput);
        whereContainer.appendChild(whereGroup);

        // Order by field (only if the property has a sort order)
        if (sortOrder) {
          const orderGroup = document.createElement('div');
          orderGroup.className = 'field-group';
          
          const orderLabel = document.createElement('label');
          orderLabel.textContent = `Sort by ${propName}:`;
          
          const orderSelect = document.createElement('select');
          orderSelect.name = `orderBy_${propName}`;
          
          const noneOption = document.createElement('option');
          noneOption.value = '';
          noneOption.textContent = 'None';
          orderSelect.appendChild(noneOption);
          
          const ascOption = document.createElement('option');
          ascOption.value = 'asc';
          ascOption.textContent = 'Ascending';
          orderSelect.appendChild(ascOption);
          
          const descOption = document.createElement('option');
          descOption.value = 'desc';
          descOption.textContent = 'Descending';
          orderSelect.appendChild(descOption);
          
          orderGroup.appendChild(orderLabel);
          orderGroup.appendChild(orderSelect);
          orderByContainer.appendChild(orderGroup);
        }
      });

      // Show the containers
      whereContainer.parentElement.style.display = 'block';
      orderByContainer.parentElement.style.display = 'block';
    }

    // Function to clear index fields
    function clearIndexFields() {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (whereContainer) {
        whereContainer.innerHTML = '';
        whereContainer.parentElement.style.display = 'none';
      }
      
      if (orderByContainer) {
        orderByContainer.innerHTML = '';
        orderByContainer.parentElement.style.display = 'none';
      }
    }

    function displayResult(data, isError = false) {
      const resultContent = document.getElementById('identityInfo');
      if (isError) {
        resultContent.className = 'result-content error-result';
        resultContent.textContent = data;
        currentResult = null;
      } else {
        resultContent.className = 'result-content';
        // Parse JSON string if necessary
        let dataToFormat = data;
        if (typeof data === 'string') {
          try {
            dataToFormat = JSON.parse(data);
          } catch (e) {
            // If parsing fails, use the string as-is
            dataToFormat = data;
          }
        }
        // Use custom formatter for better display with credit tooltips
        resultContent.innerHTML = formatResultWithCredits(dataToFormat);
        currentResult = data;
      }
    }
    
    function formatResultWithCredits(data) {
      const CREDITS_PER_DASH = 100000000000; // 100 billion credits = 1 Dash
      
      function formatCreditsValue(credits) {
        const creditsNum = BigInt(credits);
        const dashValue = Number(creditsNum) / CREDITS_PER_DASH;
        const dashFormatted = dashValue.toFixed(8).replace(/\.?0+$/, '');
        return `<span class="credits-value" title="${dashFormatted} DASH">${credits}</span>`;
      }
      
      function processValue(value, key, indent = 0) {
        // Check if this is a credits field
        const creditsFields = ['balance', 'totalCreditsInPlatform', 'credits', 'amount', 'totalCredits'];
        const isCreditsField = creditsFields.some(field => key.toLowerCase().includes(field.toLowerCase()));
        
        if (typeof value === 'string' && isCreditsField && /^\d+$/.test(value)) {
          return formatCreditsValue(value);
        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          return formatObject(value, indent);
        } else if (Array.isArray(value)) {
          return formatArray(value, indent);
        } else {
          return escapeHtml(JSON.stringify(value));
        }
      }
      
      function formatObject(obj, indent = 0) {
        const indentStr = '  '.repeat(indent);
        const innerIndentStr = '  '.repeat(indent + 1);
        const entries = Object.entries(obj).map(([key, value]) => {
          const formattedValue = processValue(value, key, indent + 1);
          return `${innerIndentStr}<span class="json-key">"${escapeHtml(key)}"</span>: ${formattedValue}`;
        });
        return `{
${entries.join(',\n')}
${indentStr}}`;
      }
      
      function formatArray(arr, indent = 0) {
        const indentStr = '  '.repeat(indent);
        const innerIndentStr = '  '.repeat(indent + 1);
        const items = arr.map((item, index) => {
          const formatted = processValue(item, '', indent + 1);
          // If the formatted value is multiline, we need to handle it differently
          if (formatted.includes('\n')) {
            return `${innerIndentStr}${formatted}`;
          }
          return `${innerIndentStr}${formatted}`;
        });
        return `[
${items.join(',\n')}
${indentStr}]`;
      }
      
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      return `<pre>${processValue(data, '')}</pre>`;
    }

    function updateStatus(message, type = 'loading') {
      const statusBanner = document.getElementById('statusBanner');
      statusBanner.textContent = message;
      statusBanner.className = `status-banner ${type}`;
    }

    async function initializeSdk(network) {
      const currentRequestToken = ++initRequestCounter;
      
      const preloader = document.getElementById('preloader');
      preloader.style.display = 'block';
      const useTrusted = true; // Always use trusted mode
      const modeStr = 'trusted';
      updateStatus(`Initializing ${network.toUpperCase()} SDK (${modeStr} mode)...`, 'loading');
      
      try {
        let newSdk;
        let shouldContinue = true;
        
        if (useTrusted) {
          updateStatus(`Prefetching quorum information for ${network.toUpperCase()}...`, 'loading');
          if (network === 'mainnet') {
            await prefetch_trusted_quorums_mainnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              newSdk = await WasmSdkBuilder.new_mainnet_trusted().build();
            }
          } else {
            await prefetch_trusted_quorums_testnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              newSdk = await WasmSdkBuilder.new_testnet_trusted().build();
            }
          }
        } else if (shouldContinue) {
          if (network === 'mainnet') {
            newSdk = await WasmSdkBuilder.new_mainnet().build();
          } else {
            newSdk = await WasmSdkBuilder.new_testnet().build();
          }
        }
        
        if (shouldContinue && currentRequestToken === initRequestCounter) {
          sdk = newSdk;
          console.log(`Initialized ${network} SDK (${modeStr} mode):`, sdk);
          updateStatus(`WASM SDK successfully loaded on ${network.toUpperCase()} (${modeStr} mode)`, 'success');
        }
      } catch (error) {
        if (currentRequestToken === initRequestCounter) {
          console.error(`Error initializing ${network} SDK:`, error);
          clearResults();
          updateStatus(`Error loading WASM SDK: ${error.message || error}`, 'error');
        }
      } finally {
        if (currentRequestToken === initRequestCounter) {
          preloader.style.display = 'none';
        }
      }
    }

    // Dynamic input creation
    function createInput(inputDef, container) {
      const inputGroup = document.createElement('div');
      inputGroup.className = 'input-group';
      
      if (inputDef.type !== 'checkbox') {
        const label = document.createElement('label');
        label.textContent = inputDef.label;
        if (!inputDef.required) {
          const optionalSpan = document.createElement('span');
          optionalSpan.className = 'optional-label';
          optionalSpan.textContent = ' (optional)';
          label.appendChild(optionalSpan);
        }
        inputGroup.appendChild(label);
      }

      if (inputDef.type === 'text' || inputDef.type === 'number') {
        const input = document.createElement('input');
        input.type = inputDef.type;
        input.name = inputDef.name;
        input.placeholder = inputDef.label;
        inputGroup.appendChild(input);
      } else if (inputDef.type === 'checkbox') {
        const checkboxContainer = document.createElement('div');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = inputDef.name;
        checkbox.id = `input_${inputDef.name}`;
        if (inputDef.defaultValue === true) {
          checkbox.checked = true;
        }
        
        const checkboxLabel = document.createElement('label');
        checkboxLabel.htmlFor = checkbox.id;
        checkboxLabel.textContent = inputDef.label;
        if (!inputDef.required) {
          const optionalSpan = document.createElement('span');
          optionalSpan.className = 'optional-label';
          optionalSpan.textContent = ' (optional)';
          checkboxLabel.appendChild(optionalSpan);
        }
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(checkboxLabel);
        inputGroup.appendChild(checkboxContainer);
      } else if (inputDef.type === 'select') {
        const select = document.createElement('select');
        select.name = inputDef.name;
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = `Select ${inputDef.label}`;
        select.appendChild(defaultOption);
        
        if (!inputDef.dynamic) {
          inputDef.options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            select.appendChild(option);
          });
        }
        
        inputGroup.appendChild(select);
        
        // Hide dynamic selects initially
        if (inputDef.dynamic) {
          inputGroup.style.display = 'none';
        }
      } else if (inputDef.type === 'multiselect') {
        const selectContainer = document.createElement('div');
        selectContainer.className = 'array-input-container';
        
        inputDef.options.forEach(opt => {
          const checkboxDiv = document.createElement('div');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.name = `${inputDef.name}_${opt.value}`;
          checkbox.value = opt.value;
          checkbox.id = `input_${inputDef.name}_${opt.value}`;
          
          const checkboxLabel = document.createElement('label');
          checkboxLabel.htmlFor = checkbox.id;
          checkboxLabel.textContent = opt.label;
          checkboxLabel.style.marginLeft = '5px';
          
          checkboxDiv.appendChild(checkbox);
          checkboxDiv.appendChild(checkboxLabel);
          selectContainer.appendChild(checkboxDiv);
        });
        
        inputGroup.appendChild(selectContainer);
      } else if (inputDef.type === 'array') {
        const arrayContainer = document.createElement('div');
        arrayContainer.className = 'array-input-container';
        arrayContainer.dataset.arrayName = inputDef.name;
        
        const addButton = document.createElement('button');
        addButton.className = 'add-array-item';
        addButton.textContent = '+ Add Item';
        addButton.onclick = () => addArrayItem(arrayContainer);
        
        arrayContainer.appendChild(addButton);
        inputGroup.appendChild(arrayContainer);
        
        // Add one empty item by default
        addArrayItem(arrayContainer);
      } else if (inputDef.type === 'json') {
        const textarea = document.createElement('textarea');
        textarea.name = inputDef.name;
        textarea.placeholder = inputDef.placeholder || `Enter valid JSON for ${inputDef.label}`;
        textarea.style.width = '100%';
        textarea.style.minHeight = '100px';
        textarea.style.padding = '8px';
        textarea.style.border = '1px solid #ddd';
        textarea.style.borderRadius = '4px';
        textarea.style.fontFamily = 'monospace';
        textarea.setAttribute('data-json', 'true'); // Mark as JSON textarea
        inputGroup.appendChild(textarea);
      } else if (inputDef.type === 'button') {
        const button = document.createElement('button');
        button.textContent = inputDef.label;
        button.className = 'action-button';
        button.onclick = () => window[inputDef.action]();
        inputGroup.appendChild(button);
      } else if (inputDef.type === 'dynamic') {
        // Container for dynamically generated fields
        const dynamicContainer = document.createElement('div');
        dynamicContainer.id = `dynamic_${inputDef.name}`;
        dynamicContainer.className = 'dynamic-fields-container';
        inputGroup.appendChild(dynamicContainer);
        // Hide initially
        inputGroup.style.display = 'none';
      }

      // Handle dependencies
      if (inputDef.dependsOn) {
        inputGroup.style.display = 'none';
        inputGroup.dataset.dependsOn = inputDef.dependsOn.field;
        inputGroup.dataset.dependsOnValue = Array.isArray(inputDef.dependsOn.value) 
          ? inputDef.dependsOn.value.join(',') 
          : inputDef.dependsOn.value;
      }

      container.appendChild(inputGroup);
    }

    function addArrayItem(container) {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'array-item';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Enter value';
      
      const removeButton = document.createElement('button');
      removeButton.textContent = 'Remove';
      removeButton.onclick = () => itemDiv.remove();
      
      itemDiv.appendChild(input);
      itemDiv.appendChild(removeButton);
      
      const addButton = container.querySelector('.add-array-item');
      container.insertBefore(itemDiv, addButton);
    }

    function getInputValues() {
      const values = {};
      const dynamicInputs = document.getElementById('dynamicInputs');
      
      // Text, number, and select inputs
      dynamicInputs.querySelectorAll('input[type="text"], input[type="number"], select').forEach(input => {
        if (input.name) {
          if (input.type === 'number') {
            if (input.value !== '') {
              const numValue = parseInt(input.value);
              if (!isNaN(numValue)) {
                values[input.name] = numValue;
              }
            }
          } else if (input.value) {
            values[input.name] = input.value;
          }
        }
      });
      
      // Checkboxes
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && !checkbox.name.includes('_')) {
          values[checkbox.name] = checkbox.checked;
        }
      });
      
      // Multiselect checkboxes
      const multiselects = {};
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && checkbox.name.includes('_')) {
          const baseName = checkbox.name.split('_')[0];
          if (!multiselects[baseName]) multiselects[baseName] = [];
          if (checkbox.checked) {
            multiselects[baseName].push(parseInt(checkbox.value));
          }
        }
      });
      Object.assign(values, multiselects);
      
      // Arrays
      dynamicInputs.querySelectorAll('.array-input-container').forEach(container => {
        const arrayName = container.dataset.arrayName;
        if (arrayName) {
          const arrayValues = [];
          container.querySelectorAll('.array-item input').forEach(input => {
            if (input.value) arrayValues.push(input.value);
          });
          if (arrayValues.length > 0) {
            values[arrayName] = arrayValues;
          }
        }
      });
      
      // JSON inputs (only for textareas explicitly marked as JSON)
      dynamicInputs.querySelectorAll('textarea[data-json="true"]').forEach(textarea => {
        if (textarea.name && textarea.value) {
          try {
            values[textarea.name] = JSON.parse(textarea.value);
          } catch (e) {
            throw new Error(`Invalid JSON in ${textarea.name}: ${e.message}`);
          }
        }
      });
      
      // Regular text textareas (not JSON)
      dynamicInputs.querySelectorAll('textarea:not([data-json="true"])').forEach(textarea => {
        if (textarea.name && textarea.value) {
          values[textarea.name] = textarea.value;
        }
      });
      
      // Handle dynamic where fields
      const whereInputs = dynamicInputs.querySelectorAll('input[name^="where_"]');
      if (whereInputs.length > 0) {
        const whereClause = [];
        whereInputs.forEach(input => {
          if (input.value) {
            const fieldName = input.name.replace('where_', '');
            // Find the corresponding operator
            const operatorSelect = dynamicInputs.querySelector(`select[name="whereOp_${fieldName}"]`);
            const operator = operatorSelect?.value || '==';
            whereClause.push([fieldName, operator, input.value]);
          }
        });
        if (whereClause.length > 0) {
          values.where = whereClause;
        }
      }
      
      // Handle dynamic order by fields
      const orderBySelects = dynamicInputs.querySelectorAll('select[name^="orderBy_"]');
      if (orderBySelects.length > 0) {
        const orderBy = [];
        orderBySelects.forEach(select => {
          if (select.value) {
            const fieldName = select.name.replace('orderBy_', '');
            orderBy.push([fieldName, select.value]);
          }
        });
        if (orderBy.length > 0) {
          values.orderBy = orderBy;
        }
      }
      
      return values;
    }

    // Query execution
    async function executeQuery(category, queryType) {
      if (!sdk) {
        alert('SDK not initialized. Please wait or refresh the page.');
        return;
      }

      const queryDef = queryDefinitions[category].queries[queryType];
      if (!queryDef) {
        alert('Invalid query selection');
        return;
      }

      const preloader = document.getElementById('preloader');
      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;

      preloader.style.display = 'block';
      button.disabled = true;
      button.textContent = 'Executing...';
      updateStatus(`Executing ${queryDef.label}...`, 'loading');

      try {
        const values = getInputValues();
        let result;
        
        // Identity queries
        if (queryType === 'getIdentity' && values.id) {
          result = await identity_fetch(sdk, values.id);
          result = result.toJSON();
        } else if (queryType === 'getIdentityKeys') {
          const keyIds = values.keyRequestType === 'specific' ? values.specificKeyIds : undefined;
          result = await get_identity_keys(
            sdk,
            values.identityId,
            values.keyRequestType,
            keyIds,
            values.limit,
            values.offset
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentitiesContractKeys') {
          const purposes = values.purposes ? values.purposes.map(p => parseInt(p)) : undefined;
          result = await get_identities_contract_keys(
            sdk,
            values.identitiesIds,
            values.contractId,
            values.documentTypeName || undefined,
            purposes
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityNonce') {
          result = await get_identity_nonce(sdk, values.identityId);
        } else if (queryType === 'getIdentityContractNonce') {
          result = await get_identity_contract_nonce(sdk, values.identityId, values.contractId);
        } else if (queryType === 'getIdentityBalance') {
          result = await get_identity_balance(sdk, values.id);
          // Result is already an object with balance field
        } else if (queryType === 'getIdentitiesBalances') {
          result = await get_identities_balances(sdk, values.ids);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityBalanceAndRevision') {
          result = await get_identity_balance_and_revision(sdk, values.id);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityByPublicKeyHash') {
          result = await get_identity_by_public_key_hash(sdk, values.publicKeyHash);
          result = result.toJSON();
        } else if (queryType === 'getIdentityByNonUniquePublicKeyHash') {
          result = await get_identity_by_non_unique_public_key_hash(
            sdk,
            values.publicKeyHash,
            values.startAfter || undefined
          );
          // Result is already a JS array
        } else if (queryType === 'getIdentityTokenBalances') {
          result = await get_identity_token_balances(sdk, values.identityId, values.tokenIds);
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Data contract queries
        else if (queryType === 'getDataContract' && values.id) {
          result = await data_contract_fetch(sdk, values.id);
          result = result.toJSON();
        } else if (queryType === 'getDataContractHistory') {
          result = await get_data_contract_history(
            sdk,
            values.id,
            values.limit,
            values.offset,
            values.startAtMs
          );
          result = JSON.parse(result);
        } else if (queryType === 'getDataContracts') {
          result = await get_data_contracts(sdk, values.ids);
          result = JSON.parse(result);
        }
        // Document queries
        else if (queryType === 'getDocuments') {
          const startAfter = values.startOption === 'startAfter' ? values.startValue : undefined;
          const startAt = values.startOption === 'startAt' ? values.startValue : undefined;
          result = await get_documents(
            sdk,
            values.dataContractId,
            values.documentType,
            values.where ? JSON.stringify(values.where) : undefined,
            values.orderBy ? JSON.stringify(values.orderBy) : undefined,
            values.limit,
            startAfter,
            startAt
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getDocument') {
          result = await get_document(
            sdk,
            values.dataContractId,
            values.documentType,
            values.documentId
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Protocol/Version queries
        else if (queryType === 'getProtocolVersionUpgradeState') {
          result = await get_protocol_version_upgrade_state(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getProtocolVersionUpgradeVoteStatus') {
          result = await get_protocol_version_upgrade_vote_status(
            sdk,
            values.startProTxHash || '',  // Empty string if not provided
            values.count || 100           // Default to 100 if not provided
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Epoch/Block queries
        else if (queryType === 'getEpochsInfo') {
          result = await get_epochs_info(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentEpoch') {
          result = await get_current_epoch(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getFinalizedEpochInfos') {
          result = await get_finalized_epoch_infos(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter || undefined,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // System/Utility queries
        else if (queryType === 'getStatus') {
          result = await get_status(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTotalCreditsInPlatform') {
          result = await get_total_credits_in_platform(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'waitForStateTransitionResult') {
          if (!values.stateTransitionHash) {
            throw new Error('Missing required parameter: stateTransitionHash is required');
          }
          result = await wait_for_state_transition_result(sdk, values.stateTransitionHash);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentQuorumsInfo') {
          result = await get_current_quorums_info(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPrefundedSpecializedBalance') {
          if (!values.identityId) {
            throw new Error('Missing required parameter: identityId is required');
          }
          result = await get_prefunded_specialized_balance(sdk, values.identityId);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPathElements') {
          if (!values.keys || values.keys.length === 0) {
            throw new Error('Missing required parameter: keys array is required');
          }
          result = await get_path_elements(sdk, values.keys);
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Token queries
        else if (queryType === 'getIdentitiesTokenBalances') {
          result = await get_identities_token_balances(sdk, values.identityIds, values.tokenId);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityTokenInfos') {
          result = await get_identity_token_infos(
            sdk,
            values.identityId,
            values.tokenIds,
            values.limit,
            values.offset
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentitiesTokenInfos') {
          result = await get_identities_token_infos(
            sdk,
            values.identityIds,
            values.tokenId
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenStatuses') {
          result = await get_token_statuses(sdk, values.tokenIds);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenDirectPurchasePrices') {
          result = await get_token_direct_purchase_prices(sdk, values.tokenIds);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenContractInfo') {
          result = await get_token_contract_info(sdk, values.dataContractId);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenPerpetualDistributionLastClaim') {
          result = await get_token_perpetual_distribution_last_claim(
            sdk,
            values.identityId,
            values.tokenId
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenTotalSupply') {
          result = await get_token_total_supply(sdk, values.tokenId);
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Voting/Contested Resource queries
        else if (queryType === 'getContestedResources') {
          const startAtValue = values.startAtValue ? new TextEncoder().encode(values.startAtValue) : undefined;
          result = await get_contested_resources(
            sdk,
            values.documentTypeName,
            values.dataContractId,
            values.indexName,
            values.resultType,
            values.allowIncludeLockedAndAbstainingVoteTally,
            startAtValue,
            values.limit,
            values.offset,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceVoteState') {
          result = await get_contested_resource_vote_state(
            sdk,
            values.dataContractId,
            values.documentTypeName,
            values.indexName,
            values.resultType,
            values.allowIncludeLockedAndAbstainingVoteTally,
            values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
            values.count,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceVotersForIdentity') {
          result = await get_contested_resource_voters_for_identity(
            sdk,
            values.dataContractId,
            values.documentTypeName,
            values.indexName,
            values.contestantId,
            values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
            values.count,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceIdentityVotes') {
          result = await get_contested_resource_identity_votes(
            sdk,
            values.identityId,
            values.limit,
            values.offset,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getVotePollsByEndDate') {
          result = await get_vote_polls_by_end_date(
            sdk,
            values.startTimeMs,
            values.endTimeMs,
            values.limit,
            values.offset,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Epoch/Block queries
        else if (queryType === 'getFinalizedEpochInfos') {
          result = await get_finalized_epoch_infos(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Group queries
        else if (queryType === 'getGroupInfo') {
          result = await get_group_info(sdk, values.contractId, values.groupContractPosition);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupInfos') {
          let startAtInfo = null;
          if (values.startAtGroupContractPosition !== undefined) {
            startAtInfo = {
              position: values.startAtGroupContractPosition,
              included: values.startGroupContractPositionIncluded || false
            };
          }
          result = await get_group_infos(
            sdk,
            values.contractId,
            startAtInfo,
            values.count
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupActions') {
          let startAtInfo = null;
          if (values.startActionId) {
            startAtInfo = {
              actionId: values.startActionId,
              included: values.startActionIdIncluded || false
            };
          }
          result = await get_group_actions(
            sdk,
            values.contractId,
            values.groupContractPosition,
            values.status,
            startAtInfo,
            values.count
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupActionSigners') {
          result = await get_group_action_signers(
            sdk,
            values.contractId,
            values.groupContractPosition,
            values.status,
            values.actionId
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else {
          // Placeholder for unimplemented queries
          throw new Error(`Query ${queryType} is not yet implemented in the WASM SDK bindings`);
        }
        
        displayResult(result);
        updateStatus(`${queryDef.label} executed successfully`, 'success');
      } catch (error) {
        console.error(`Error executing ${queryType}:`, error);
        displayResult(`Error executing query: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        preloader.style.display = 'none';
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }
    
    async function executeStateTransition(category, transitionType) {
      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;
      button.disabled = true;
      button.textContent = 'Processing...';
      
      const preloader = document.getElementById('preloader');
      preloader.style.display = 'block';
      updateStatus(`Executing ${transitionType} state transition...`, 'loading');
      
      try {
        // Check if this transition is disabled
        if (transitionType === 'identityCreate' || transitionType === 'identityTopUp') {
          throw new Error('This transition requires an Asset Lock Proof and is not available in the web interface');
        }
        
        // Get authentication values
        const identityId = document.getElementById('identityId').value.trim();
        const privateKey = document.getElementById('privateKey').value.trim();
        
        if (!identityId || !privateKey) {
          throw new Error('Identity ID and Private Key are required for state transitions');
        }
        
        // Get input values
        const values = getInputValues();
        let result;
        
        // Execute the state transition based on type
        if (transitionType === 'tokenMint') {
          result = await sdk.tokenMint(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId,
            privateKey,
            Number(values.keyId),
            values.issuedToIdentityId || null,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatus('Token mint executed successfully', 'success');
        } else if (transitionType === 'tokenBurn') {
          result = await sdk.tokenBurn(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId,
            privateKey,
            Number(values.keyId),
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatus('Token burn executed successfully', 'success');
        } else if (transitionType === 'documentCreate') {
          // Collect document fields from dynamic inputs
          const documentData = collectDocumentFields();
          
          // Generate entropy (32 bytes)
          const entropy = new Uint8Array(32);
          crypto.getRandomValues(entropy);
          const entropyHex = Array.from(entropy)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
          
          // Create the document using the SDK
          result = await sdk.documentCreate(
            values.contractId,
            values.documentType,
            identityId,
            JSON.stringify(documentData),
            entropyHex,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document created successfully', 'success');
        } else if (transitionType === 'documentReplace') {
          // Collect document fields from dynamic inputs
          const documentData = collectDocumentFields();
          
          // Ensure we have the loaded revision
          if (loadedDocumentRevision === null) {
            throw new Error('No document loaded. Please click "Load Document" first.');
          }
          
          // Handle document replace
          result = await sdk.documentReplace(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            JSON.stringify(documentData),
            BigInt(loadedDocumentRevision),
            privateKey,
            0 // key_id - using 0 as default
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document replaced successfully', 'success');
          
          // Reset loaded data
          loadedDocumentData = null;
          loadedDocumentRevision = null;
        } else if (transitionType === 'documentDelete') {
          // Handle document delete
          result = await sdk.documentDelete(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            privateKey,
            0 // key_id - using 0 as default
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document deleted successfully', 'success');
        } else if (transitionType === 'documentTransfer') {
          // Handle document transfer
          result = await sdk.documentTransfer(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            values.recipientId,
            privateKey,
            0 // key_id - using 0 as default
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document transferred successfully', 'success');
        } else if (transitionType === 'documentSetPrice') {
          // Handle document set price
          result = await sdk.documentSetPrice(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            values.price || 0, // price in credits, 0 to remove price
            privateKey,
            0 // key_id - using 0 as default
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document price set successfully', 'success');
        } else if (transitionType === 'documentPurchase') {
          // Handle document purchase
          result = await sdk.documentPurchase(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            values.price,
            privateKey,
            0 // key_id - using 0 as default
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Document purchased successfully', 'success');
        } else if (transitionType === 'identityCreditTransfer') {
          // Handle identity credit transfer
          result = await sdk.identityCreditTransfer(
            identityId, // sender is the authenticated identity
            values.recipientId,
            BigInt(values.amount),
            privateKey,
            null // key_id - will auto-select
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Credits transferred successfully', 'success');
        } else if (transitionType === 'identityCreditWithdrawal') {
          // Handle identity credit withdrawal
          result = await sdk.identityCreditWithdrawal(
            identityId,
            values.toAddress,
            BigInt(values.amount),
            values.coreFeePerByte ? Number(values.coreFeePerByte) : null,
            privateKey,
            null // key_id - will auto-select
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Credits withdrawn successfully', 'success');
        } else if (transitionType === 'identityUpdate') {
          // Handle identity update
          
          // Parse disable public keys
          let disableKeys = null;
          if (values.disablePublicKeys) {
            disableKeys = values.disablePublicKeys.split(',')
              .map(id => parseInt(id.trim()))
              .filter(id => !isNaN(id));
          }
          
          result = await sdk.identityUpdate(
            identityId,
            values.addPublicKeys || null, // JSON string
            disableKeys,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Identity updated successfully', 'success');
        } else if (transitionType === 'dpnsUsername') {
          // Handle DPNS Username vote (simplified version of masternode vote)
          
          // Fixed DPNS contract ID
          const dpnsContractId = 'GWRSAVFMjXx8HpQFaNJMqBV7MBgMK4br5UESsB4S31Ec';
          
          // Build index values from username: ["dash", username]
          const indexValues = ["dash", values.contestedUsername];
          
          // Prepare vote choice
          let voteChoice = values.voteChoice;
          if (voteChoice === 'towardsIdentity' && values.targetIdentity) {
            voteChoice = `towardsIdentity:${values.targetIdentity}`;
          } else if (voteChoice === 'towardsIdentity' && !values.targetIdentity) {
            throw new Error('Target identity ID is required when voting for an identity');
          }
          
          result = await sdk.masternodeVote(
            identityId, // This is the masternode ProTxHash
            dpnsContractId,
            'domain', // DPNS document type
            'parentNameAndLabel', // DPNS index name
            JSON.stringify(indexValues),
            voteChoice,
            privateKey // This is the voting key
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('DPNS username vote submitted successfully', 'success');
        } else if (transitionType === 'masternodeVote') {
          // Handle masternode vote
          
          // Get the selected contested resource from the dropdown
          const selectedResource = values.contestedResource;
          if (!selectedResource) {
            throw new Error('Please select a contested resource');
          }
          
          // Parse the selected resource data
          const resourceData = JSON.parse(selectedResource);
          
          // Get the index values from the separate input
          const indexValuesInput = document.querySelector('textarea[name="indexValues"]');
          let indexValues = [];
          if (indexValuesInput && indexValuesInput.value) {
            try {
              indexValues = JSON.parse(indexValuesInput.value);
            } catch (e) {
              throw new Error('Invalid JSON in index values: ' + e.message);
            }
          }
          
          if (indexValues.length === 0) {
            throw new Error('Please provide index values for the contested resource');
          }
          
          // Prepare vote choice
          let voteChoice = values.voteChoice;
          if (voteChoice === 'towardsIdentity' && values.targetIdentity) {
            voteChoice = `towardsIdentity:${values.targetIdentity}`;
          } else if (voteChoice === 'towardsIdentity' && !values.targetIdentity) {
            throw new Error('Target identity ID is required when voting for an identity');
          }
          
          result = await sdk.masternodeVote(
            identityId, // This is the masternode ProTxHash
            resourceData.contractId,
            resourceData.documentType,
            resourceData.indexName,
            JSON.stringify(indexValues),
            voteChoice,
            privateKey // This is the voting key
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatus('Vote submitted successfully', 'success');
        } else if (transitionType === 'dataContractCreate') {
          // Get document schemas JSON
          const schemasTextarea = document.querySelector('textarea[name="documentSchemas"]');
          if (!schemasTextarea || !schemasTextarea.value) {
            throw new Error('Document Schemas JSON is required');
          }
          
          let documentSchemas;
          try {
            documentSchemas = JSON.parse(schemasTextarea.value);
          } catch (e) {
            throw new Error(`Invalid JSON in Document Schemas field: ${e.message}`);
          }
          
          // Get optional JSON fields
          let groups = {};
          let tokens = {};
          
          const groupsTextarea = document.querySelector('textarea[name="groups"]');
          if (groupsTextarea && groupsTextarea.value) {
            try {
              groups = JSON.parse(groupsTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in Groups field: ${e.message}`);
            }
          }
          
          const tokensTextarea = document.querySelector('textarea[name="tokens"]');
          if (tokensTextarea && tokensTextarea.value) {
            try {
              tokens = JSON.parse(tokensTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in Tokens field: ${e.message}`);
            }
          }
          
          // Get keywords
          const keywords = values.keywords ? values.keywords.split(',').map(k => k.trim()).filter(k => k) : [];
          
          // Build the contract object
          const contractData = {
            "$format_version": "1",
            "id": "11111111111111111111111111111111", // Will be replaced by SDK
            "config": {
              "$format_version": "1",
              "canBeDeleted": values.canBeDeleted || false,
              "readonly": values.readonly || false,
              "keepsHistory": values.keepsHistory || false,
              "documentsKeepHistoryContractDefault": values.documentsKeepHistoryContractDefault || false,
              "documentsMutableContractDefault": values.documentsMutableContractDefault !== false, // Default true
              "documentsCanBeDeletedContractDefault": values.documentsCanBeDeletedContractDefault !== false, // Default true
              "requiresIdentityEncryptionBoundedKey": values.requiresIdentityEncryptionBoundedKey || null,
              "requiresIdentityDecryptionBoundedKey": values.requiresIdentityDecryptionBoundedKey || null,
              "sizedIntegerTypes": true
            },
            "version": 1,
            "ownerId": identityId,
            "schemaDefs": null,
            "documentSchemas": documentSchemas,
            "createdAt": null,
            "updatedAt": null,
            "createdAtBlockHeight": null,
            "updatedAtBlockHeight": null,
            "createdAtEpoch": null,
            "updatedAtEpoch": null,
            "groups": groups,
            "tokens": tokens,
            "keywords": keywords,
            "description": values.description || null
          };
          
          result = await sdk.contractCreate(
            identityId,
            JSON.stringify(contractData),
            privateKey,
            null  // Let SDK auto-detect the key
          );
          
          displayResult(result);
          updateStatus('Data contract created successfully', 'success');
        } else if (transitionType === 'dataContractUpdate') {
          // First fetch the existing contract
          updateStatus(`Fetching contract ${values.dataContractId}...`, 'loading');
          
          let existingContract;
          try {
            const contractWasm = await data_contract_fetch(sdk, values.dataContractId);
            // Convert to JSON to work with it - the method is toJSON not to_json
            const contractJson = await contractWasm.toJSON();
            existingContract = contractJson;
          } catch (e) {
            throw new Error(`Failed to fetch contract: ${e.message || e}`);
          }
          
          // Parse new schemas, groups, and tokens if provided
          let newSchemas = {};
          let newGroups = {};
          let newTokens = {};
          
          const newSchemasTextarea = document.querySelector('textarea[name="newDocumentSchemas"]');
          if (newSchemasTextarea && newSchemasTextarea.value) {
            try {
              newSchemas = JSON.parse(newSchemasTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Document Schemas field: ${e.message}`);
            }
          }
          
          const newGroupsTextarea = document.querySelector('textarea[name="newGroups"]');
          if (newGroupsTextarea && newGroupsTextarea.value) {
            try {
              newGroups = JSON.parse(newGroupsTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Groups field: ${e.message}`);
            }
          }
          
          const newTokensTextarea = document.querySelector('textarea[name="newTokens"]');
          if (newTokensTextarea && newTokensTextarea.value) {
            try {
              newTokens = JSON.parse(newTokensTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Tokens field: ${e.message}`);
            }
          }
          
          // Check if anything is being added
          if (Object.keys(newSchemas).length === 0 && 
              Object.keys(newGroups).length === 0 && 
              Object.keys(newTokens).length === 0) {
            throw new Error('No changes specified. Please add at least one new document schema, group, or token.');
          }
          
          // Merge new items with existing contract
          const updatedContract = {
            ...existingContract,
            version: existingContract.version + 1,
            ownerId: identityId,
            documentSchemas: {
              ...existingContract.documentSchemas,
              ...newSchemas
            },
            groups: {
              ...existingContract.groups,
              ...newGroups
            },
            tokens: {
              ...existingContract.tokens,
              ...newTokens
            }
          };
          
          // Show what's being added
          const additions = [];
          if (Object.keys(newSchemas).length > 0) {
            additions.push(`${Object.keys(newSchemas).length} document type(s)`);
          }
          if (Object.keys(newGroups).length > 0) {
            additions.push(`${Object.keys(newGroups).length} group(s)`);
          }
          if (Object.keys(newTokens).length > 0) {
            additions.push(`${Object.keys(newTokens).length} token(s)`);
          }
          
          updateStatus(`Adding ${additions.join(', ')} to contract...`, 'loading');
          
          result = await sdk.contractUpdate(
            values.dataContractId,
            identityId,
            JSON.stringify(updatedContract),
            privateKey,
            null  // Let SDK auto-detect the key
          );
          
          displayResult(result);
          updateStatus('Data contract updated successfully', 'success');
        } else {
          // For other transitions not yet implemented
          const transitionData = {
            type: transitionType,
            category: category,
            identityId: identityId,
            privateKey: '***hidden***',
            inputs: values
          };
          
          displayResult(JSON.stringify(transitionData, null, 2));
          updateStatus(`${transitionType} state transition not yet implemented in WASM SDK`, 'warning');
        }
        
      } catch (error) {
        console.error(`Error executing ${transitionType}:`, error);
        displayResult(`Error executing state transition: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        preloader.style.display = 'none';
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }

    // Event handlers
    document.getElementById('operationType').addEventListener('change', (e) => {
      const operationType = e.target.value;
      const categorySelect = document.getElementById('queryCategory');
      const authInputs = document.getElementById('authenticationInputs');
      
      // Clear category
      categorySelect.innerHTML = '<option value="">Select Category</option>';
      
      // Show/hide auth inputs
      authInputs.style.display = operationType === 'transitions' ? 'block' : 'none';
      
      if (operationType === 'queries') {
        // Populate query categories
        Object.entries(queryDefinitions).forEach(([key, category]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = category.label;
          categorySelect.appendChild(option);
        });
      } else if (operationType === 'transitions') {
        // Populate transition categories
        Object.entries(stateTransitionDefinitions).forEach(([key, category]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = category.label;
          categorySelect.appendChild(option);
        });
      }
      
      // Reset the rest
      document.getElementById('queryType').innerHTML = '<option value="">Select Type</option>';
      document.getElementById('queryType').style.display = 'none';
      document.getElementById('queryInputs').style.display = 'none';
      document.getElementById('executeQuery').style.display = 'none';
      document.getElementById('queryDescription').style.display = 'none';
    });
    
    document.getElementById('queryCategory').addEventListener('change', (e) => {
      const category = e.target.value;
      const operationType = document.getElementById('operationType').value;
      const queryTypeSelect = document.getElementById('queryType');
      const queryInputs = document.getElementById('queryInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear query type
      queryTypeSelect.innerHTML = '<option value="">Select Type</option>';
      queryTypeSelect.style.display = category ? 'block' : 'none';
      
      // Hide inputs and button
      queryInputs.style.display = 'none';
      executeButton.style.display = 'none';
      queryDescription.style.display = 'none';
      
      if (operationType === 'queries' && category && queryDefinitions[category]) {
        // Populate query types
        Object.entries(queryDefinitions[category].queries).forEach(([key, query]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = query.label;
          queryTypeSelect.appendChild(option);
        });
      } else if (operationType === 'transitions' && category && stateTransitionDefinitions[category]) {
        // Populate transition types
        Object.entries(stateTransitionDefinitions[category].transitions).forEach(([key, transition]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = transition.label;
          
          // Disable transitions that require asset lock proofs
          if (key === 'identityCreate' || key === 'identityTopUp') {
            option.disabled = true;
            option.textContent += ' (Requires Asset Lock Proof)';
            option.style.color = '#999';
          }
          
          queryTypeSelect.appendChild(option);
        });
      }
    });

    document.getElementById('queryType').addEventListener('change', (e) => {
      const queryType = e.target.value;
      const category = document.getElementById('queryCategory').value;
      const operationType = document.getElementById('operationType').value;
      const queryInputs = document.getElementById('queryInputs');
      const dynamicInputs = document.getElementById('dynamicInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryTitle = document.getElementById('queryTitle');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear existing inputs
      dynamicInputs.innerHTML = '';
      
      let definition;
      if (operationType === 'queries' && queryType && category && queryDefinitions[category]?.queries[queryType]) {
        definition = queryDefinitions[category].queries[queryType];
      } else if (operationType === 'transitions' && queryType && category && stateTransitionDefinitions[category]?.transitions[queryType]) {
        definition = stateTransitionDefinitions[category].transitions[queryType];
      }
      
      if (definition) {
        queryTitle.textContent = definition.label;
        
        // Show description
        if (definition.description) {
          queryDescription.textContent = definition.description;
          queryDescription.style.display = 'block';
        } else {
          queryDescription.style.display = 'none';
        }
        
        // Create inputs
        definition.inputs.forEach(inputDef => {
          createInput(inputDef, dynamicInputs);
        });
        
        // Setup dependency handlers
        dynamicInputs.querySelectorAll('select, input[type="checkbox"]').forEach(input => {
          input.addEventListener('change', () => {
            dynamicInputs.querySelectorAll('[data-depends-on]').forEach(dependent => {
              const dependsOn = dependent.dataset.dependsOn;
              const dependsOnValues = dependent.dataset.dependsOnValue.split(',');
              const currentValue = dynamicInputs.querySelector(`[name="${dependsOn}"]`)?.value;
              
              if (dependsOnValues.includes(currentValue)) {
                dependent.style.display = 'block';
              } else {
                dependent.style.display = 'none';
              }
            });
          });
        });
        
        queryInputs.style.display = 'block';
        executeButton.style.display = 'block';
        
        // Update button text based on operation type
        executeButton.textContent = operationType === 'transitions' ? 'Execute' : 'Execute Query';
        
        // Update authentication labels for masternode vote
        if (operationType === 'transitions' && (queryType === 'masternodeVote' || queryType === 'dpnsUsername')) {
          const identityIdLabel = document.querySelector('#authenticationInputs label[for="identityId"]');
          const privateKeyLabel = document.querySelector('#authenticationInputs label[for="privateKey"]');
          const identityIdInput = document.getElementById('identityId');
          const privateKeyInput = document.getElementById('privateKey');
          
          if (identityIdLabel) {
            identityIdLabel.textContent = 'ProTxHash (hex or Base58)';
          }
          if (privateKeyLabel) {
            privateKeyLabel.textContent = 'Voting Private Key (WIF or hex)';
          }
          if (identityIdInput) {
            identityIdInput.placeholder = 'Enter your masternode ProTxHash';
          }
          if (privateKeyInput) {
            privateKeyInput.placeholder = 'Enter your voting private key (WIF or 32-byte hex)';
          }
        } else if (operationType === 'transitions') {
          // Reset to default labels for other transitions
          const identityIdLabel = document.querySelector('#authenticationInputs label[for="identityId"]');
          const privateKeyLabel = document.querySelector('#authenticationInputs label[for="privateKey"]');
          const identityIdInput = document.getElementById('identityId');
          const privateKeyInput = document.getElementById('privateKey');
          
          if (identityIdLabel) {
            identityIdLabel.textContent = 'Identity ID';
          }
          if (privateKeyLabel) {
            privateKeyLabel.textContent = 'Private Key (WIF or hex)';
          }
          if (identityIdInput) {
            identityIdInput.placeholder = 'Enter identity ID';
          }
          if (privateKeyInput) {
            privateKeyInput.placeholder = 'Enter private key (WIF or 32-byte hex)';
          }
        }
      } else {
        queryInputs.style.display = 'none';
        executeButton.style.display = 'none';
        queryDescription.style.display = 'none';
      }
    });

    document.getElementById('executeQuery').addEventListener('click', async () => {
      const operationType = document.getElementById('operationType').value;
      const category = document.getElementById('queryCategory').value;
      const queryType = document.getElementById('queryType').value;
      
      if (operationType === 'queries') {
        await executeQuery(category, queryType);
      } else if (operationType === 'transitions') {
        await executeStateTransition(category, queryType);
      }
    });

    // Network toggle handlers
    document.querySelectorAll('input[name="network"]').forEach(radio => {
      radio.addEventListener('change', async (event) => {
        const network = event.target.value;
        const indicator = document.getElementById('networkIndicator');
        
        indicator.textContent = network.toUpperCase();
        indicator.className = `network-indicator ${network}`;
        
        // Save network preference to localStorage
        localStorage.setItem('wasm-sdk-network', network);
        
        clearResults();
        await initializeSdk(network);
      });
    });

    // Trusted mode is always on, no need for event listener

    // Store loaded document data globally for document replace
    let loadedDocumentData = null;
    let loadedDocumentRevision = null;

    // Load existing document for replacement
    window.loadExistingDocument = async function() {
      const contractIdInput = document.querySelector('input[name="contractId"]');
      const documentTypeInput = document.querySelector('input[name="documentType"]');
      const documentIdInput = document.querySelector('input[name="documentId"]');
      
      const contractId = contractIdInput?.value;
      const documentType = documentTypeInput?.value;
      const documentId = documentIdInput?.value;
      
      if (!contractId || !documentType || !documentId) {
        updateStatus('Please fill in Contract ID, Document Type, and Document ID', 'error');
        return;
      }
      
      try {
        updateStatus('Loading document and schema...', 'loading');
        
        // First fetch the document
        const documentResult = await get_document(sdk, contractId, documentType, documentId);
        
        if (!documentResult) {
          throw new Error('Document not found');
        }
        
        // Store document data and revision
        loadedDocumentData = documentResult.data || {};
        loadedDocumentRevision = documentResult.revision || 0;
        
        console.log('Loaded document:', documentResult);
        
        // Now fetch the data contract to get schema
        const dataContract = await data_contract_fetch(sdk, contractId);
        const contractData = dataContract.toJSON();
        
        // Find the document type schema
        const docType = contractData.documentSchemas?.[documentType];
        if (!docType) {
          throw new Error(`Document type '${documentType}' not found in contract`);
        }
        
        // Show the document fields container
        const fieldsContainer = document.getElementById('dynamic_documentFields');
        if (fieldsContainer) {
          fieldsContainer.parentElement.style.display = 'block';
          
          // Populate document fields with existing data
          populateDocumentFields(docType, fieldsContainer, loadedDocumentData);
        }
        
        updateStatus(`Document loaded successfully (revision: ${loadedDocumentRevision})`, 'success');
      } catch (error) {
        console.error('Error loading document:', error);
        updateStatus(`Error loading document: ${error.message}`, 'error');
      }
    };

    // Fetch document schema and generate dynamic fields
    window.fetchDocumentSchema = async function() {
      const contractId = document.querySelector('input[name="contractId"]')?.value;
      const documentType = document.querySelector('input[name="documentType"]')?.value;
      
      if (!contractId || !documentType) {
        updateStatus('Please enter both Data Contract ID and Document Type', 'error');
        return;
      }
      
      try {
        updateStatus('Fetching data contract...', 'loading');
        
        // Fetch the data contract
        const contract = await data_contract_fetch(sdk, contractId);
        if (!contract) {
          updateStatus('Data contract not found', 'error');
          return;
        }
        
        // Get the document schema
        const contractJson = contract.toJSON();
        const documentSchema = contractJson.documentSchemas?.[documentType];
        
        if (!documentSchema) {
          updateStatus(`Document type '${documentType}' not found in contract`, 'error');
          return;
        }
        
        // Generate dynamic fields
        generateDocumentFields(documentSchema);
        updateStatus(`Schema loaded for ${documentType}`, 'success');
        
      } catch (error) {
        console.error('Error fetching schema:', error);
        updateStatus(`Error: ${error.message || error}`, 'error');
      }
    };
    
    // Fetch contested resources from a contract
    window.fetchContestedResources = async function() {
      const contractId = document.querySelector('input[name="contractId"]')?.value;
      
      if (!contractId) {
        updateStatus('Please enter a Data Contract ID', 'error');
        return;
      }
      
      try {
        updateStatus('Fetching data contract and contested resources...', 'loading');
        
        // First fetch the data contract to identify contested document types
        const contract = await data_contract_fetch(sdk, contractId);
        if (!contract) {
          updateStatus('Data contract not found', 'error');
          return;
        }
        
        const contractJson = contract.toJSON();
        const documentSchemas = contractJson.documentSchemas || {};
        
        // Find document types with contested unique indexes
        const contestedResources = [];
        
        for (const [documentType, schema] of Object.entries(documentSchemas)) {
          const indexes = schema.indices || [];
          
          for (const index of indexes) {
            // Check if this is a contested unique index
            // contested can be either true or an object with contest rules
            if (index.unique && index.contested) {
              const indexName = index.name;
              const indexProperties = index.properties || [];
              
              // Get contest description if available
              let description = '';
              if (typeof index.contested === 'object' && index.contested.description) {
                description = ` - ${index.contested.description}`;
              }
              
              contestedResources.push({
                contractId: contractId,
                documentType: documentType,
                indexName: indexName,
                indexProperties: indexProperties,
                contestedRules: index.contested,
                displayName: `${documentType} - ${indexName}${description}`
              });
            }
          }
        }
        
        // Populate the dropdown
        const container = document.getElementById('dynamic_contestedResourceDropdown');
        if (!container) {
          console.error('Contested resource dropdown container not found');
          return;
        }
        
        container.parentElement.style.display = 'block';
        container.innerHTML = '';
        
        if (contestedResources.length === 0) {
          const noResourcesMsg = document.createElement('p');
          noResourcesMsg.textContent = 'No contested resources found in this contract';
          noResourcesMsg.style.color = '#666';
          container.appendChild(noResourcesMsg);
          updateStatus('No contested resources found', 'warning');
          return;
        }
        
        // Create dropdown
        const selectGroup = document.createElement('div');
        selectGroup.className = 'input-group';
        
        const label = document.createElement('label');
        label.textContent = 'Select Contested Resource:';
        label.style.display = 'block';
        label.style.marginBottom = '5px';
        selectGroup.appendChild(label);
        
        const select = document.createElement('select');
        select.name = 'contestedResource';
        select.style.width = '100%';
        select.style.marginBottom = '10px';
        
        // Add placeholder option
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = '-- Select a contested resource --';
        select.appendChild(placeholderOption);
        
        // Add contested resources
        contestedResources.forEach(resource => {
          const option = document.createElement('option');
          option.value = JSON.stringify({
            contractId: resource.contractId,
            documentType: resource.documentType,
            indexName: resource.indexName,
            indexValues: [] // This will need to be filled by the user
          });
          option.textContent = resource.displayName;
          select.appendChild(option);
        });
        
        selectGroup.appendChild(select);
        container.appendChild(selectGroup);
        
        // Add index values input when a resource is selected
        select.addEventListener('change', (e) => {
          const existingValuesInput = container.querySelector('.index-values-group');
          if (existingValuesInput) {
            existingValuesInput.remove();
          }
          
          if (e.target.value) {
            const resource = JSON.parse(e.target.value);
            const valuesGroup = document.createElement('div');
            valuesGroup.className = 'input-group index-values-group';
            valuesGroup.style.marginTop = '10px';
            
            const valuesLabel = document.createElement('label');
            valuesLabel.textContent = 'Index Values (JSON array):';
            valuesLabel.style.display = 'block';
            valuesLabel.style.marginBottom = '5px';
            valuesGroup.appendChild(valuesLabel);
            
            const valuesInput = document.createElement('textarea');
            valuesInput.name = 'indexValues';
            valuesInput.placeholder = 'e.g., ["dash", "username"]';
            valuesInput.rows = 2;
            valuesInput.style.width = '100%';
            valuesInput.dataset.json = 'true';
            
            // Store the index values without modifying the select value
            valuesInput.dataset.resourceData = select.value;
            
            valuesGroup.appendChild(valuesInput);
            container.appendChild(valuesGroup);
          }
        });
        
        updateStatus(`Found ${contestedResources.length} contested resource type(s)`, 'success');
        
      } catch (error) {
        console.error('Error fetching contested resources:', error);
        updateStatus(`Error: ${error.message || error}`, 'error');
      }
    };
    
    function generateDocumentFields(schema) {
      const container = document.getElementById('dynamic_documentFields');
      if (!container) return;
      
      // Clear existing fields
      // Show the container
      container.parentElement.style.display = 'block';
      
      // Use the shared function
      populateDocumentFields(schema, container);
    }
    
    // Shared function to populate document fields
    function populateDocumentFields(schema, container, existingData = null) {
      // Clear existing fields
      container.innerHTML = '';
      
      // Add header
      const header = document.createElement('h4');
      header.textContent = 'Document Fields';
      header.style.marginBottom = '10px';
      container.appendChild(header);
      
      // Generate fields based on schema properties
      const properties = schema.properties || {};
      const required = schema.required || [];
      
      Object.entries(properties).forEach(([fieldName, fieldSchema]) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'input-group';
        fieldGroup.style.marginBottom = '10px';
        
        const label = document.createElement('label');
        const isRequired = required.includes(fieldName);
        label.textContent = `${fieldName}${isRequired ? ' *' : ' (optional)'}`;
        label.style.display = 'block';
        label.style.marginBottom = '5px';
        label.style.fontWeight = isRequired ? 'bold' : 'normal';
        fieldGroup.appendChild(label);
        
        // Create appropriate input based on field type
        const input = createInputForField(fieldName, fieldSchema);
        
        // Populate with existing data if available
        if (existingData && existingData[fieldName] !== undefined) {
          const value = existingData[fieldName];
          
          if (input.type === 'checkbox') {
            input.checked = value;
          } else if (input.type === 'datetime-local' && typeof value === 'number') {
            // Convert timestamp to datetime-local format
            const date = new Date(value);
            input.value = date.toISOString().slice(0, 16);
          } else if (input.tagName === 'TEXTAREA' && (fieldSchema.type === 'array' || fieldSchema.type === 'object')) {
            // Convert arrays/objects to JSON string
            input.value = JSON.stringify(value, null, 2);
          } else {
            input.value = value;
          }
        }
        
        fieldGroup.appendChild(input);
        
        // Add description if available
        if (fieldSchema.description) {
          const desc = document.createElement('small');
          desc.textContent = fieldSchema.description;
          desc.style.display = 'block';
          desc.style.color = '#666';
          desc.style.marginTop = '2px';
          fieldGroup.appendChild(desc);
        }
        
        container.appendChild(fieldGroup);
      });
    }
    
    function createInputForField(fieldName, fieldSchema) {
      const fieldType = fieldSchema.type;
      const format = fieldSchema.format;
      
      let input;
      
      if (fieldType === 'string') {
        if (format === 'date-time') {
          input = document.createElement('input');
          input.type = 'datetime-local';
        } else if (fieldSchema.maxLength && fieldSchema.maxLength > 100) {
          input = document.createElement('textarea');
          input.rows = 4;
          input.style.width = '100%';
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }
        
        if (fieldSchema.maxLength) {
          input.maxLength = fieldSchema.maxLength;
        }
        if (fieldSchema.minLength) {
          input.minLength = fieldSchema.minLength;
        }
        if (fieldSchema.pattern) {
          input.pattern = fieldSchema.pattern;
        }
      } else if (fieldType === 'integer' || fieldType === 'number') {
        input = document.createElement('input');
        input.type = 'number';
        
        if (fieldSchema.minimum !== undefined) {
          input.min = fieldSchema.minimum;
        }
        if (fieldSchema.maximum !== undefined) {
          input.max = fieldSchema.maximum;
        }
        if (fieldType === 'integer') {
          input.step = '1';
        }
      } else if (fieldType === 'boolean') {
        input = document.createElement('input');
        input.type = 'checkbox';
      } else if (fieldType === 'array') {
        // Check if it's a byte array (identifier)
        if (fieldSchema.byteArray === true) {
          input = document.createElement('input');
          input.type = 'text';
          input.placeholder = fieldSchema.description || 'Enter identifier (base58)';
        } else {
          input = document.createElement('textarea');
          input.placeholder = fieldSchema.description || 'Enter array values';
          input.rows = 3;
          input.style.width = '100%';
        }
      } else if (fieldType === 'object') {
        input = document.createElement('textarea');
        input.placeholder = fieldSchema.description || 'Enter object data';
        input.rows = 4;
        input.style.width = '100%';
      } else {
        // Default to text input
        input = document.createElement('input');
        input.type = 'text';
      }
      
      input.name = `doc_field_${fieldName}`;
      input.dataset.fieldName = fieldName;
      input.dataset.fieldType = fieldType;
      if (fieldSchema.byteArray === true) {
        input.dataset.byteArray = 'true';
      }
      
      if (fieldSchema.default !== undefined) {
        if (fieldType === 'boolean') {
          input.checked = fieldSchema.default;
        } else {
          input.value = typeof fieldSchema.default === 'object' 
            ? JSON.stringify(fieldSchema.default) 
            : fieldSchema.default;
        }
      }
      
      return input;
    }
    
    // Collect document fields for submission
    function collectDocumentFields() {
      const container = document.getElementById('dynamic_documentFields');
      if (!container) return {};
      
      const fields = {};
      const inputs = container.querySelectorAll('input, textarea');
      
      inputs.forEach(input => {
        const fieldName = input.dataset.fieldName;
        const fieldType = input.dataset.fieldType;
        
        if (!fieldName) return;
        
        let value;
        
        if (input.type === 'checkbox') {
          value = input.checked;
        } else if (fieldType === 'integer' || fieldType === 'number') {
          value = input.value ? parseFloat(input.value) : undefined;
          if (fieldType === 'integer' && value !== undefined) {
            value = Math.floor(value);
          }
        } else if (fieldType === 'array') {
          // Check if it's a byte array (identifier)
          if (input.dataset.byteArray === 'true') {
            // For byte arrays, we need to convert the base58 string to bytes
            // For now, just pass the string - the SDK will handle conversion
            value = input.value || undefined;
          } else {
            try {
              value = input.value ? JSON.parse(input.value) : undefined;
            } catch (e) {
              console.error(`Invalid JSON for field ${fieldName}:`, e);
              value = undefined;
            }
          }
        } else if (fieldType === 'object') {
          try {
            value = input.value ? JSON.parse(input.value) : undefined;
          } catch (e) {
            console.error(`Invalid JSON for field ${fieldName}:`, e);
            value = undefined;
          }
        } else if (input.type === 'datetime-local' && input.value) {
          // Convert to Unix timestamp in milliseconds
          value = new Date(input.value).getTime();
        } else {
          value = input.value || undefined;
        }
        
        if (value !== undefined) {
          fields[fieldName] = value;
        }
      });
      
      return fields;
    }

    // Initialize
    async function run() {
      try {
        updateStatus('Loading WASM module...', 'loading');
        const initStart = performance.now();
        await init();
        const initEnd = performance.now();
        console.log(`[Performance] WASM init took ${(initEnd - initStart).toFixed(2)}ms`);
        
        updateStatus('WASM module loaded, initializing SDK...', 'loading');
        
        // Load saved network preference or default to mainnet
        const savedNetwork = localStorage.getItem('wasm-sdk-network') || 'mainnet';
        
        // Update the radio button to match saved preference
        const networkRadio = document.getElementById(savedNetwork);
        if (networkRadio) {
          networkRadio.checked = true;
          
          // Update the network indicator
          const indicator = document.getElementById('networkIndicator');
          indicator.textContent = savedNetwork.toUpperCase();
          indicator.className = `network-indicator ${savedNetwork}`;
        }
        
        await initializeSdk(savedNetwork);
      } catch (error) {
        console.error('Failed to initialize WASM:', error);
        updateStatus(`Failed to load WASM module: ${error.message || error}`, 'error');
      }
    }

    run();
    
    // Initialize with queries selected
    document.getElementById('operationType').dispatchEvent(new Event('change'));
  </script>
</body>

</html>