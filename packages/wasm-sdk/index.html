<!DOCTYPE html>
<html>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.6/dist/purify.min.js" 
        integrity="sha384-JEyTNhjM6R1ElGoJns4U2Ln4ofPcqzSsynQkmEc/KGy6336qAZl70tDLufbkla+3" 
        crossorigin="anonymous"></script>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dash Platform WASM JS SDK</title>
  <link rel="icon" type="image/svg+xml" href="https://media.dash.org/wp-content/uploads/blue-d.svg">
  <link rel="alternate icon" type="image/png" href="https://media.dash.org/wp-content/uploads/blue-d-250.png">
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div class="header">
    <h1>Dash Platform WASM JS SDK</h1>
    <nav class="header-nav">
      <a href="docs.html">Documentation</a>
      <a href="AI_REFERENCE.md">AI Reference</a>
      <a href="https://github.com/dashpay/platform" target="_blank">GitHub</a>
    </nav>
  </div>
  
  <!-- Error Banner for API definitions loading failures -->
  <div id="apiErrorBanner" style="display: none; background-color: #f8d7da; color: #721c24; padding: 15px; margin: 0; border-bottom: 1px solid #f5c6cb; text-align: center;">
    <div style="display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap;">
      <span id="apiErrorMessage">Failed to load API definitions. Please check your connection and try again.</span>
      <button id="apiRetryButton" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">Retry</button>
    </div>
  </div>
  
  <div id="preloader">
    <div class="preloader-content">
      <div class="preloader-text">Loading WASM module...</div>
      <div class="preloader-progress">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-percent" id="progressPercent">0%</div>
      </div>
    </div>
  </div>
  
  <div class="app-container">
    <div class="sidebar">
      <div class="network-toggle">
        <label>Network:</label>
        <input type="radio" id="mainnet" name="network" value="mainnet">
        <label for="mainnet">Mainnet</label>
        <input type="radio" id="testnet" name="network" value="testnet">
        <label for="testnet">Testnet</label>
        <span id="networkIndicator" class="network-indicator mainnet">MAINNET</span>
        <br>
        <label style="margin-top: 10px; display: block;">
          <input type="checkbox" id="trustedMode" style="margin-right: 5px;" checked disabled>
          Trusted Quorums Mode
        </label>
      </div>
      
      <!-- SDK Configuration Section (Collapsible) -->
      <details class="sdk-config" style="margin: 0; padding: 0; border-bottom: 1px solid #e0e0e0;">
        <summary style="padding: 15px 20px; background-color: #f8f9fa; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center;">
          <span style="font-weight: 500; color: #333;">Advanced SDK Configuration</span>
          <span style="font-size: 0.8em; color: #666;">▼</span>
        </summary>
        <div style="padding: 15px 20px; background-color: #f0f4f8;">
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">Platform Version:</label>
            <div style="display: flex; gap: 10px; align-items: center;">
              <input type="number" id="platformVersion" placeholder="Latest" style="flex: 1; padding: 5px;" min="1">
              <span id="latestVersionInfo" style="font-size: 0.9em; color: #666;"></span>
            </div>
            <small style="color: #666;">Leave empty for latest version</small>
          </div>
          
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; font-weight: 500; margin-bottom: 10px;">Request Settings</summary>
            <div style="margin-top: 10px;">
              <label style="display: block; margin-bottom: 5px;">Connect Timeout (ms):</label>
              <input type="number" id="connectTimeout" placeholder="Default: 3000" style="width: 100%; padding: 5px;">
            </div>
            <div style="margin-top: 10px;">
              <label style="display: block; margin-bottom: 5px;">Request Timeout (ms):</label>
              <input type="number" id="requestTimeout" placeholder="Default: 60000" style="width: 100%; padding: 5px;">
            </div>
            <div style="margin-top: 10px;">
              <label style="display: block; margin-bottom: 5px;">Retries:</label>
              <input type="number" id="retries" placeholder="Default: 5" style="width: 100%; padding: 5px;">
            </div>
            <div style="margin-top: 10px;">
              <label style="display: flex; align-items: center;">
                <input type="checkbox" id="banFailedAddress" style="margin-right: 5px;">
                Ban Failed Addresses
              </label>
            </div>
          </details>
          
          <button id="applyConfig" style="margin-top: 15px; padding: 8px 15px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Apply Configuration</button>
        </div>
      </details>
      
      <div class="query-container">
        <div class="query-selector">
          <select id="operationType">
            <option value="queries">Queries</option>
            <option value="transitions">State Transitions</option>
            <option value="wallet">Wallet</option>
          </select>
          
          <select id="queryCategory">
            <option value="">Select Query Category</option>
            <option value="identity">Identity Queries</option>
            <option value="dataContract">Data Contract Queries</option>
            <option value="document">Document Queries</option>
            <option value="dpns">DPNS Queries</option>
            <option value="voting">Voting & Contested Resources</option>
            <option value="protocol">Protocol & Version</option>
            <option value="epoch">Epoch & Block</option>
            <option value="token">Token Queries</option>
            <option value="group">Group Queries</option>
            <option value="system">System & Utility</option>
          </select>
          
          <select id="queryType" style="display: none;">
            <option value="">Select Query Type</option>
          </select>
        </div>
        
        <div id="authenticationInputs" class="query-inputs" style="display: none;">
          <h4>Authentication</h4>
          <div class="input-group" id="identityIdGroup">
            <label for="identityId">Identity ID</label>
            <input type="text" id="identityId" placeholder="Enter identity ID">
          </div>
          <div class="input-group" id="assetLockProofGroup" style="display: none;">
            <label for="assetLockProof">Asset Lock Proof</label>
            <input type="text" id="assetLockProof" placeholder="Enter asset lock proof (hex encoded)">
          </div>
          <div class="input-group">
            <label for="privateKey">Private Key (WIF or hex, optionally with :keyId)</label>
            <input type="password" id="privateKey" placeholder="Enter private key (WIF or 32-byte hex)">
          </div>
        </div>
        
        <div id="queryDescription" class="query-description" style="display: none;"></div>
        
        <div id="queryInputs" class="query-inputs" style="display: none;">
          <h4 id="queryTitle">Query Parameters</h4>
          <div id="dynamicInputs"></div>
        </div>
        
        <div class="proof-toggle" style="display: none; margin: 15px 0;" id="proofToggleContainer">
          <label style="display: flex; align-items: center; margin: 0;">
            <span class="toggle-switch">
              <input type="checkbox" id="proofToggle">
              <span class="toggle-slider"></span>
            </span>
            <span style="margin-left: 60px; font-weight: 500; color: #333;">With Proof Info</span>
          </label>
        </div>
        
        <div class="no-proof-info" style="display: none; margin: 15px 0; padding: 10px; background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; text-align: center;" id="noProofInfoContainer">
          <span style="color: #6c757d; font-size: 0.9em;">Note: this query does not provide cryptographic proof verification.</span>
        </div>
        
        <button id="executeQuery" class="execute-button" style="display: none;">Execute Query</button>
      </div>
    </div>
    
    <div class="result-container">
      <div class="result-header">
        <h2>Results</h2>
        <div class="result-actions">
          <button id="clearButton" onclick="clearResults()">Clear</button>
          <button id="copyButton" onclick="copyResults()">Copy</button>
          <button id="clearCacheButton" onclick="clearCache()" title="Clear WASM cache and reload">Clear Cache</button>
        </div>
      </div>
      <div id="resultSplitContainer" class="result-split-container">
        <div id="identityInfo" class="result-content empty">No data fetched yet. Select a query category and type to begin.</div>
      </div>
    </div>
  </div>

  <div id="statusBanner" class="status-banner loading">Initializing WASM SDK...</div>

  <script>
    // Global functions for button actions
    function clearResults() {
      document.getElementById('identityInfo').textContent = '';
      document.getElementById('identityInfo').classList.add('empty');
      document.getElementById('identityInfo').classList.remove('error');
      if (typeof currentResult !== 'undefined') {
        currentResult = null;
      }
    }
    
    function copyResults() {
      const content = document.getElementById('identityInfo').textContent;
      navigator.clipboard.writeText(content).then(() => {
        const button = document.getElementById('copyButton');
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy:', err);
      });
    }
    
    async function clearCache() {
      const button = document.getElementById('clearCacheButton');
      const originalText = button.textContent;
      button.textContent = 'Clearing...';
      button.disabled = true;
      
      try {
        // Clear service worker cache
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          // Use MessageChannel for response
          const channel = new MessageChannel();
          channel.port1.onmessage = (event) => {
            console.log('Cache cleared:', event.data);
          };
          navigator.serviceWorker.controller.postMessage(
            { action: 'clearCache' }, 
            [channel.port2]
          );
        }
        
        // Clear browser caches
        if ('caches' in window) {
          const cacheNames = await caches.keys();
          await Promise.all(
            cacheNames.map(cacheName => caches.delete(cacheName))
          );
        }
        
        button.textContent = 'Cache Cleared!';
        
        // Reload after a short delay
        setTimeout(() => {
          window.location.reload(true);
        }, 1000);
        
      } catch (error) {
        console.error('Failed to clear cache:', error);
        button.textContent = 'Failed';
        setTimeout(() => {
          button.textContent = originalText;
          button.disabled = false;
        }, 2000);
      }
    }
    
    // Register service worker for caching
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker-simple.js')
          .then(registration => {
            console.log('ServiceWorker registration successful:', registration.scope);
            
            // Check for updates periodically
            setInterval(() => {
              registration.update();
            }, 60 * 60 * 1000); // Check every hour
            
            // Listen for updates from service worker
            navigator.serviceWorker.addEventListener('message', event => {
              if (event.data.type === 'cache-updated') {
                console.log('Cache updated:', event.data.oldCache, '->', event.data.newCache);
                
                // Show notification to user
                const banner = document.getElementById('statusBanner');
                if (banner && !banner.querySelector('button')) {
                  banner.textContent = 'New version detected! Refresh to update.';
                  banner.className = 'status-banner warning';
                  
                  // Add refresh button
                  const refreshBtn = document.createElement('button');
                  refreshBtn.textContent = 'Refresh Now';
                  refreshBtn.style.marginLeft = '10px';
                  refreshBtn.onclick = () => window.location.reload(true);
                  banner.appendChild(refreshBtn);
                }
              }
            });
          })
          .catch(err => {
            console.log('ServiceWorker registration failed:', err);
          });
      });
    }
  </script>

  <script type="module">
    // Add performance timing
    const startTime = performance.now();
    console.log('[Performance] Starting WASM module load...');
    
    import init, { 
      WasmSdkBuilder, 
      identity_fetch,
      identity_fetch_unproved,
      identity_fetch_with_proof_info,
      data_contract_fetch,
      data_contract_fetch_with_proof_info,
      prefetch_trusted_quorums_mainnet, 
      prefetch_trusted_quorums_testnet,
      // Identity queries
      get_identity_keys,
      get_identity_keys_with_proof_info,
      get_identity_nonce,
      get_identity_nonce_with_proof_info,
      get_identity_contract_nonce,
      get_identity_contract_nonce_with_proof_info,
      get_identity_balance,
      get_identity_balance_with_proof_info,
      get_identities_balances,
      get_identities_balances_with_proof_info,
      get_identity_balance_and_revision,
      get_identity_balance_and_revision_with_proof_info,
      get_identity_by_public_key_hash,
      get_identity_by_public_key_hash_with_proof_info,
      get_identities_contract_keys,
      get_identities_contract_keys_with_proof_info,
      get_identity_by_non_unique_public_key_hash,
      get_identity_by_non_unique_public_key_hash_with_proof_info,
      get_identity_token_balances,
      get_identity_token_balances_with_proof_info,
      // Data contract queries
      get_data_contract_history,
      get_data_contract_history_with_proof_info,
      get_data_contracts,
      get_data_contracts_with_proof_info,
      // Document queries
      get_documents,
      get_documents_with_proof_info,
      get_document,
      get_document_with_proof_info,
      get_dpns_username,
      get_dpns_usernames,
      get_dpns_usernames_with_proof_info,
      get_dpns_username_by_name,
      get_dpns_username_by_name_with_proof_info,
      // Protocol/Version queries
      get_protocol_version_upgrade_state,
      get_protocol_version_upgrade_state_with_proof_info,
      get_protocol_version_upgrade_vote_status,
      // Epoch/Block queries
      get_epochs_info,
      get_epochs_info_with_proof_info,
      get_finalized_epoch_infos,
      get_finalized_epoch_infos_with_proof_info,
      get_current_epoch,
      get_current_epoch_with_proof_info,
      get_evonodes_proposed_epoch_blocks_by_ids,
      get_evonodes_proposed_epoch_blocks_by_range,
      // System/Utility queries
      get_status,
      get_total_credits_in_platform,
      get_total_credits_in_platform_with_proof_info,
      get_current_quorums_info,
      get_prefunded_specialized_balance,
      get_prefunded_specialized_balance_with_proof_info,
      get_path_elements,
      get_path_elements_with_proof_info,
      wait_for_state_transition_result,
      // Token queries
      get_identities_token_balances,
      get_identities_token_balances_with_proof_info,
      get_identity_token_infos,
      get_identity_token_infos_with_proof_info,
      get_identities_token_infos,
      get_identities_token_infos_with_proof_info,
      get_token_statuses,
      get_token_statuses_with_proof_info,
      get_token_direct_purchase_prices,
      get_token_direct_purchase_prices_with_proof_info,
      get_token_contract_info,
      get_token_contract_info_with_proof_info,
      get_token_perpetual_distribution_last_claim,
      get_token_perpetual_distribution_last_claim_with_proof_info,
      get_token_total_supply,
      get_token_total_supply_with_proof_info,
      // Voting/Contested Resource queries
      get_contested_resources,
      get_contested_resources_with_proof_info,
      get_contested_resource_vote_state,
      get_contested_resource_vote_state_with_proof_info,
      get_contested_resource_voters_for_identity,
      get_contested_resource_voters_for_identity_with_proof_info,
      get_contested_resource_identity_votes,
      get_contested_resource_identity_votes_with_proof_info,
      get_vote_polls_by_end_date,
      get_vote_polls_by_end_date_with_proof_info,
      // Group queries
      get_group_info,
      get_group_info_with_proof_info,
      get_group_infos,
      get_group_infos_with_proof_info,
      get_group_actions,
      get_group_actions_with_proof_info,
      get_group_action_signers,
      get_group_action_signers_with_proof_info,
      // DPNS functions
      dpns_convert_to_homograph_safe,
      dpns_is_valid_username,
      dpns_is_contested_username,
      dpns_register_name,
      dpns_is_name_available,
      dpns_resolve_name,
      // Wallet functions
      generate_key_pair,
      generate_key_pairs,
      key_pair_from_wif,
      key_pair_from_hex,
      pubkey_to_address,
      validate_address,
      sign_message,
      derivation_path_bip44_mainnet,
      derivation_path_bip44_testnet,
      derivation_path_dip9_mainnet,
      derivation_path_dip9_testnet,
      generate_mnemonic,
      validate_mnemonic,
      mnemonic_to_seed,
      derive_key_from_seed_phrase,
      derive_key_from_seed_with_path,
      derive_key_from_seed_with_extended_path,
      derive_dashpay_contact_key,
      derivation_path_dip13_mainnet,
      derivation_path_dip13_testnet,
      derive_child_public_key,
      xprv_to_xpub
    } from './pkg/wasm_sdk.js';
    
    // Import all placeholder query functions
    import * as queryFunctions from './pkg/wasm_sdk.js';

    let sdk = null;
    let currentNetwork = 'mainnet'; // Track the current network (defaults to mainnet)
    let currentResult = null;
    let initRequestCounter = 0;
    
    // API definitions - will be loaded from JSON
    let queryDefinitions = {};
    let stateTransitionDefinitions = {};

    // Function to load API definitions from JSON
    async function loadApiDefinitions() {
      try {
        const response = await fetch('./api-definitions.json', {
          cache: 'no-store' // Bypass browser cache to ensure fresh data
        });
        if (!response.ok) {
          throw new Error(`Failed to load API definitions: ${response.status}`);
        }
        const apiData = await response.json();
        queryDefinitions = apiData.queries || {};
        stateTransitionDefinitions = apiData.transitions || {};
        console.log('API definitions loaded successfully');
        return true;
      } catch (error) {
        console.error('Failed to load API definitions:', error);
        return false;
      }
    }

    // Function to show API error banner
    function showApiErrorBanner(message) {
      const banner = document.getElementById('apiErrorBanner');
      const messageElement = document.getElementById('apiErrorMessage');
      if (banner && messageElement) {
        messageElement.textContent = message || 'Failed to load API definitions. Please check your connection and try again.';
        banner.style.display = 'block';
      }
    }

    // Function to hide API error banner
    function hideApiErrorBanner() {
      const banner = document.getElementById('apiErrorBanner');
      if (banner) {
        banner.style.display = 'none';
      }
    }

    // Function to handle API definitions loading with retry functionality
    async function tryLoadApiDefinitions() {
      const success = await loadApiDefinitions();
      if (success) {
        hideApiErrorBanner();
        return true;
      } else {
        showApiErrorBanner();
        return false;
      }
    }

    // Wallet definitions
    const walletDefinitions = {
      keyGeneration: {
        label: "Key Generation",
        operations: {
          generateSeed: {
            label: "Generate Seed",
            description: "Generate a new mnemonic seed phrase",
            inputs: [
              { name: "wordCount", type: "select", label: "Word Count", required: true,
                options: [
                  { value: "12", label: "12 words" },
                  { value: "15", label: "15 words" },
                  { value: "18", label: "18 words" },
                  { value: "21", label: "21 words" },
                  { value: "24", label: "24 words" }
                ]
              },
              { name: "language", type: "select", label: "Language", required: false,
                options: [
                  { value: "en", label: "English" },
                  { value: "zh-cn", label: "Chinese Simplified" },
                  { value: "zh-tw", label: "Chinese Traditional" },
                  { value: "cs", label: "Czech" },
                  { value: "fr", label: "French" },
                  { value: "it", label: "Italian" },
                  { value: "ja", label: "Japanese" },
                  { value: "ko", label: "Korean" },
                  { value: "pt", label: "Portuguese" },
                  { value: "es", label: "Spanish" }
                ],
                defaultValue: "en"
              }
            ]
          },
          generateKeyPair: {
            label: "Generate Key Pair",
            description: "Generate a new random key pair",
            inputs: []
          },
          generateKeyPairs: {
            label: "Generate Multiple Key Pairs",
            description: "Generate multiple random key pairs",
            inputs: [
              { name: "count", type: "number", label: "Number of Key Pairs", required: true, min: 1, max: 100 }
            ]
          },
          keyPairFromWif: {
            label: "Key Pair from WIF",
            description: "Import a key pair from WIF (Wallet Import Format)",
            inputs: [
              { name: "privateKeyWif", type: "text", label: "Private Key (WIF)", required: true, 
                placeholder: "e.g., XBrZJKcW4ajWVNAU6yP87WQog6CjFnpbqyAKgNTZRqmhYvPgMNV2" }
            ]
          },
          keyPairFromHex: {
            label: "Key Pair from Hex",
            description: "Import a key pair from hex private key",
            inputs: [
              { name: "privateKeyHex", type: "text", label: "Private Key (Hex)", required: true,
                placeholder: "64 character hex string" }
            ]
          },
          pubkeyToAddress: {
            label: "Public Key to Address",
            description: "Convert a public key to a Dash address",
            inputs: [
              { name: "pubkeyHex", type: "text", label: "Public Key (Hex)", required: true,
                placeholder: "Compressed public key hex" }
            ]
          },
          validateAddress: {
            label: "Validate Address",
            description: "Check if a Dash address is valid",
            inputs: [
              { name: "address", type: "text", label: "Dash Address", required: true }
            ]
          },
          signMessage: {
            label: "Sign Message",
            description: "Sign a message with a private key",
            inputs: [
              { name: "message", type: "text", label: "Message to Sign", required: true },
              { name: "privateKeyWif", type: "text", label: "Private Key (WIF)", required: true }
            ]
          }
        }
      },
      keyDerivation: {
        label: "Key Derivation",
        operations: {
          enteredPath: {
            label: "Entered Path", 
            description: "Derive a key from a custom BIP32 derivation path",
            inputs: [
              { name: "seedPhrase", type: "textarea", label: "Seed Phrase", required: true, 
                placeholder: "Enter test seed phrase (12-24 words)" },
              { name: "generateSeedButton", type: "button", label: "Generate Test Seed", 
                action: "generateTestSeed" },
              { name: "passphrase", type: "text", label: "Passphrase (optional)", required: false,
                placeholder: "Optional BIP39 passphrase" },
              { name: "path", type: "text", label: "Derivation Path", required: true, 
                placeholder: "m/44'/5'/0'/0/0", 
                help: "Enter any BIP32 derivation path (e.g., m/44'/5'/0'/0/0 or m/9'/5'/0/1/0 or m/13'/5'/0)" }
            ]
          },
          derivationPathBip44: {
            label: "BIP44 from Seed",
            description: "⚠️ WARNING: Only use test seeds! Never enter seeds with real funds!",
            inputs: [
              { name: "seedPhrase", type: "textarea", label: "Seed Phrase", required: true, 
                placeholder: "Enter test seed phrase (12-24 words)" },
              { name: "generateSeedButton", type: "button", label: "Generate Test Seed", 
                action: "generateTestSeed" },
              { name: "passphrase", type: "text", label: "Passphrase (optional)", required: false,
                placeholder: "Optional BIP39 passphrase" },
              { name: "account", type: "number", label: "Account Index", required: true, min: 0, value: 0 },
              { name: "change", type: "checkbox", label: "Internal Address (change)", required: false },
              { name: "index", type: "number", label: "Address Index", required: true, min: 0, value: 0 }
            ]
          },
          derivationPathDip13: {
            label: "DIP13 Identity Keys",
            description: "Derive keys for Dash Platform identities using DIP13 (HD identity wallets)",
            inputs: [
              { name: "seedPhrase", type: "textarea", label: "Seed Phrase", required: true, 
                placeholder: "Enter test seed phrase (12-24 words)" },
              { name: "generateSeedButton", type: "button", label: "Generate Test Seed", 
                action: "generateTestSeed" },
              { name: "passphrase", type: "text", label: "Passphrase (optional)", required: false,
                placeholder: "Optional BIP39 passphrase" },
              { name: "subFeature", type: "select", label: "Key Type", required: true,
                options: [
                  { value: "0", label: "Authentication Keys" },
                  { value: "1", label: "Registration Funding Keys" },
                  { value: "2", label: "Top Up Funding Keys" },
                  { value: "3", label: "Invitation Funding Keys" }
                ]
              },
              { name: "identityIndex", type: "number", label: "Identity Index", required: true, min: 0, value: 0,
                help: "Index of the identity (0 for first identity, 1 for second, etc.)" },
              { name: "keyIndex", type: "number", label: "Key Index", required: false, min: 0, value: 0,
                help: "For authentication keys only - index of the key (0 for first key, 1 for second, etc.)" }
            ]
          },
          dashpayPath: {
            label: "DashPay Contact Keys (DIP15)",
            description: "Derive payment keys between two DashPay users using DIP15",
            inputs: [
              { name: "seedPhrase", type: "textarea", label: "Seed Phrase", required: true, 
                placeholder: "Enter test seed phrase (12-24 words)" },
              { name: "generateSeedButton", type: "button", label: "Generate Test Seed", 
                action: "generateTestSeed" },
              { name: "passphrase", type: "text", label: "Passphrase (optional)", required: false,
                placeholder: "Optional BIP39 passphrase" },
              { name: "senderIdentity", type: "text", label: "Sender Identity ID", required: true,
                placeholder: "e.g., 5DbLwAxGBzUzo81VewMUwn4b5P4bpv9FNFybi25XB5Bk",
                help: "Your identity ID (the owner of this seed)" },
              { name: "receiverIdentity", type: "text", label: "Receiver Identity ID", required: true,
                placeholder: "e.g., 3mFKtDYspCMd8YmXNTB3qzKmbY3Azf4Kx3x8e36V8Gho",
                help: "The contact's identity ID you want to pay" },
              { name: "account", type: "number", label: "Account", required: true, min: 0, value: 0,
                help: "Usually 0 for the first account" },
              { name: "addressIndex", type: "number", label: "Address Index", required: true, min: 0, value: 0,
                help: "Index for this contact (0 for first address, increment for new addresses)" },
              { name: "dipInfo", type: "info", label: "DIP15 Information", 
                content: "<strong>DIP15 Path Structure:</strong> <code>m/9'/coin'/15'/account'/sender_id/receiver_id/index</code><br><br>This creates deterministic payment addresses between two DashPay users. Each user derives unique addresses for each contact, enabling private payments without sharing keys.<br><br><strong>✅ Full DIP14/DIP15 Support:</strong> This implementation fully supports 256-bit identity IDs in derivation paths." }
            ]
          }
        }
      }
    };

    // Helper functions for result actions
    window.clearResults = function() {
      const resultContent = document.getElementById('identityInfo');
      resultContent.textContent = 'No data fetched yet. Select a query category and type to begin.';
      resultContent.className = 'result-content empty';
      currentResult = null;
    };

    window.copyResults = function() {
      if (!currentResult) {
        alert('No results to copy');
        return;
      }
      navigator.clipboard.writeText(JSON.stringify(currentResult, null, 2))
        .then(() => {
          const copyButton = document.getElementById('copyButton');
          const originalText = copyButton.textContent;
          copyButton.textContent = 'Copied!';
          setTimeout(() => {
            copyButton.textContent = originalText;
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy:', err);
          alert('Failed to copy to clipboard');
        });
    };

    // Function to generate a test seed phrase
    window.generateTestSeed = async function() {
      const seedInput = document.querySelector('textarea[name="seedPhrase"]');
      if (!seedInput) return;
      
      try {
        // Generate a proper BIP39 mnemonic with valid checksum
        // The generate_mnemonic function is already imported at the top
        const mnemonic = generate_mnemonic(12); // Generate 12-word mnemonic
        
        seedInput.value = mnemonic;
        
        // Add a warning in red
        const existingWarning = seedInput.parentElement.querySelector('.seed-warning');
        if (!existingWarning) {
          const warning = document.createElement('div');
          warning.className = 'seed-warning';
          warning.style.color = '#dc3545';
          warning.style.fontSize = '0.9em';
          warning.style.marginTop = '5px';
          warning.textContent = '⚠️ TEST SEED GENERATED - Never use this with real funds!';
          seedInput.parentElement.appendChild(warning);
        }
      } catch (error) {
        console.error('Error generating test seed:', error);
        alert('Failed to generate test seed: ' + error.message);
      }
    };
    
    // Function to load data contract and populate index selector
    window.loadDataContractForDocuments = async function() {
      const contractIdInput = document.querySelector('input[name="dataContractId"]');
      const documentTypeInput = document.querySelector('input[name="documentType"]');
      
      if (!contractIdInput?.value || !documentTypeInput?.value) {
        alert('Please enter both Data Contract ID and Document Type');
        return;
      }

      const contractId = contractIdInput.value;
      const documentType = documentTypeInput.value;
      
      // Start timing
      const startTime = performance.now();
      
      try {
        updateStatus('Loading data contract...', 'loading');
        
        // Fetch the data contract
        const dataContract = await data_contract_fetch(sdk, contractId);
        const contractData = dataContract.toJSON();
        
        // Find the document type
        // Note: The serialized format uses 'documentSchemas' while internal representation might use 'documentTypes'
        const docType = contractData.documentSchemas?.[documentType];
        if (!docType) {
          const availableTypes = Object.keys(contractData.documentSchemas || {});
          const availableTypesStr = availableTypes.length > 0 
            ? `Available document types: ${availableTypes.join(', ')}` 
            : 'No document types found in contract';
          throw new Error(`Document type '${documentType}' not found in contract. ${availableTypesStr}`);
        }

        // Extract indexes
        const indexes = docType.indices || [];
        
        // Populate index selector
        const indexSelector = document.querySelector('select[name="indexSelector"]');
        if (indexSelector) {
          // Clear existing options
          indexSelector.innerHTML = '<option value="">Select an index</option>';
          
          // Add index options
          indexes.forEach((index, idx) => {
            const option = document.createElement('option');
            option.value = idx;
            option.textContent = index.name || `Index ${idx}`;
            option.dataset.indexData = JSON.stringify(index);
            indexSelector.appendChild(option);
          });

          // Show the selector
          indexSelector.parentElement.style.display = 'block';
        }

        // Add index change handler
        indexSelector.addEventListener('change', function() {
          const selectedOption = this.options[this.selectedIndex];
          if (selectedOption.value && selectedOption.dataset.indexData) {
            const indexData = JSON.parse(selectedOption.dataset.indexData);
            populateIndexFields(indexData, docType);
          } else {
            clearIndexFields();
          }
        });

        updateStatusWithTime('Data contract loaded successfully', 'success', startTime);
      } catch (error) {
        console.error('Error loading data contract:', error);
        updateStatus(`Error loading data contract: ${error.message}`, 'error');
      }
    };

    // Track current index properties for validation
    let currentIndexProperties = [];
    let rangeFields = new Map(); // Track fields with range operators

    // Function to populate where and order by fields based on selected index
    function populateIndexFields(index, docType) {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (!whereContainer || !orderByContainer) return;

      // Clear existing fields and reset tracking
      whereContainer.innerHTML = '<h5>Where Conditions</h5>';
      orderByContainer.innerHTML = '<h5>Order By</h5>';
      currentIndexProperties = [];
      rangeFields.clear();

      // Add compound index info
      const indexInfo = document.createElement('div');
      indexInfo.className = 'compound-index-warning';
      indexInfo.innerHTML = '<strong>Compound Index Rules:</strong><br>' +
        '• Range queries on non-first properties require equality on all preceding properties<br>' +
        '• You can use up to 2 range clauses on the same field (they will be combined into a Between operator)<br>' +
        '• Only one IN clause is allowed per query';
      whereContainer.appendChild(indexInfo);

      // Extract properties from index
      const indexProperties = index.properties || [];
      
      // Create where fields for each indexed property
      indexProperties.forEach((prop, propIndex) => {
        // Properties are objects like {"records.identity": "asc"}
        let propName;
        let sortOrder;
        
        if (typeof prop === 'object' && !Array.isArray(prop)) {
          // Extract the property name and sort order from the object
          const keys = Object.keys(prop);
          if (keys.length > 0) {
            propName = keys[0];
            sortOrder = prop[propName];
          }
        } else if (typeof prop === 'string') {
          propName = prop;
        } else {
          return; // Skip invalid properties
        }
        
        if (!propName) return;
        
        // Track property order
        currentIndexProperties.push(propName);
        
        // Create range group container
        const rangeGroup = document.createElement('div');
        rangeGroup.className = 'range-group';
        rangeGroup.dataset.fieldName = propName;
        rangeGroup.dataset.fieldIndex = propIndex;
        
        // Range group header
        const rangeHeader = document.createElement('div');
        rangeHeader.className = 'range-group-header';
        
        // Add position badge
        const positionBadge = document.createElement('span');
        positionBadge.className = `index-property-badge ${
          propIndex === 0 ? 'index-property-first' : 
          propIndex === 1 ? 'index-property-second' : 
          'index-property-third'
        }`;
        positionBadge.textContent = `Position ${propIndex + 1}`;
        
        rangeHeader.innerHTML = `${propName} `;
        rangeHeader.appendChild(positionBadge);
        
        // Determine property type from schema
        const propDef = docType.properties?.[propName] || docType.properties?.[propName.split('.')[0]];
        const isSpecialField = propName.startsWith('$');
        let fieldType = 'unknown';
        
        if (isSpecialField) {
          if (propName === '$id' || propName === '$ownerId') {
            fieldType = 'identifier';
          } else if (propName === '$createdAt' || propName === '$updatedAt') {
            fieldType = 'date';
          } else if (propName === '$revision') {
            fieldType = 'integer';
          }
        } else if (propDef) {
          fieldType = propDef.type || 'unknown';
        }
        
        const isStringType = fieldType === 'string';
        const isNumericType = fieldType === 'number' || fieldType === 'integer' || fieldType === 'date';
        const isDateType = fieldType === 'date';
        const isIdentifierType = fieldType === 'identifier' || propDef?.byteArray;
        
        // Add field type indicator
        const typeIndicator = document.createElement('span');
        typeIndicator.className = 'field-type-indicator';
        typeIndicator.textContent = `(${fieldType})`;
        rangeHeader.appendChild(typeIndicator);
        
        rangeGroup.appendChild(rangeHeader);
        
        // Create first where clause
        createWhereClause(rangeGroup, propName, propIndex, fieldType, isStringType, isNumericType, isIdentifierType, true);
        
        // Show the range group
        whereContainer.appendChild(rangeGroup);

        // Order by field (only if the property has a sort order)
        if (sortOrder) {
          const orderGroup = document.createElement('div');
          orderGroup.className = 'field-group';
          
          const orderLabel = document.createElement('label');
          orderLabel.textContent = `Sort by ${propName}:`;
          
          const orderSelect = document.createElement('select');
          orderSelect.name = `orderBy_${propName}`;
          
          const noneOption = document.createElement('option');
          noneOption.value = '';
          noneOption.textContent = 'None';
          orderSelect.appendChild(noneOption);
          
          const ascOption = document.createElement('option');
          ascOption.value = 'asc';
          ascOption.textContent = 'Ascending';
          orderSelect.appendChild(ascOption);
          
          const descOption = document.createElement('option');
          descOption.value = 'desc';
          descOption.textContent = 'Descending';
          orderSelect.appendChild(descOption);
          
          orderGroup.appendChild(orderLabel);
          orderGroup.appendChild(orderSelect);
          orderByContainer.appendChild(orderGroup);
        }
      });

      // Add query preview section
      const queryPreview = document.createElement('div');
      queryPreview.className = 'query-preview';
      queryPreview.innerHTML = '<h5>Query Preview</h5><div id="queryPreviewContent">Fill in fields to see query preview</div>';
      whereContainer.appendChild(queryPreview);

      // Show the containers
      whereContainer.parentElement.style.display = 'block';
      orderByContainer.parentElement.style.display = 'block';
      
      // Add change listeners for live preview
      addQueryPreviewListeners();
    }

    // Helper function to create a where clause input group
    function createWhereClause(container, propName, propIndex, fieldType, isStringType, isNumericType, isIdentifierType, isFirst) {
      const whereGroup = document.createElement('div');
      whereGroup.className = 'field-group where-field-group';
      whereGroup.dataset.clauseNumber = isFirst ? '1' : '2';
      
      const whereLabel = document.createElement('label');
      whereLabel.textContent = isFirst ? 'Where:' : 'And:';
      whereLabel.style.minWidth = '60px';
      
      // Operator dropdown
      const operatorSelect = document.createElement('select');
      operatorSelect.name = isFirst ? `whereOp_${propName}` : `whereOp2_${propName}`;
      operatorSelect.className = 'operator-select';
      
      // Add empty option
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = '';
      operatorSelect.appendChild(emptyOption);
      
      // Add valid Dash Platform operators
      const operators = [
        { value: '==', label: '==', types: ['all'] },
        { value: '>', label: '>', types: ['all'] },
        { value: '>=', label: '>=', types: ['all'] },
        { value: '<', label: '<', types: ['all'] },
        { value: '<=', label: '<=', types: ['all'] }
      ];
      
      // startsWith for strings and binary/identifier types
      if (isStringType || isIdentifierType) {
        operators.push(
          { value: 'startsWith', label: 'startsWith', types: ['string', 'identifier'] }
        );
      }
      
      // IN operator for all types
      operators.push(
        { value: 'in', label: 'in', types: ['all'] }
      );
      
      operators.forEach(op => {
        const option = document.createElement('option');
        option.value = op.value;
        option.textContent = op.label;
        operatorSelect.appendChild(option);
      });
      
      // Value input
      const whereInput = document.createElement('input');
      whereInput.type = 'text';
      whereInput.name = isFirst ? `where_${propName}` : `where2_${propName}`;
      whereInput.placeholder = `Enter value`;
      whereInput.className = 'where-value-input';
      
      // Add operator change handler
      operatorSelect.addEventListener('change', function() {
        handleOperatorChange(propName, propIndex, this.value, isFirst);
        
        // Toggle has-value class
        if (this.value) {
          this.classList.add('has-value');
        } else {
          this.classList.remove('has-value');
        }
        
        // Update placeholder based on operator
        if (this.value === 'in') {
          whereInput.placeholder = 'Enter values (comma-separated)';
        } else if (this.value === 'startsWith') {
          whereInput.placeholder = 'Enter prefix';
        } else {
          whereInput.placeholder = 'Enter value';
        }
      });
      
      whereGroup.appendChild(whereLabel);
      whereGroup.appendChild(operatorSelect);
      whereGroup.appendChild(whereInput);
      
      // Add second range button for first clause only
      if (isFirst && isNumericType) {
        const addRangeBtn = document.createElement('button');
        addRangeBtn.className = 'add-range-button';
        addRangeBtn.textContent = '+ Add Range';
        addRangeBtn.style.display = 'none';
        addRangeBtn.onclick = function() {
          addSecondRangeClause(container, propName, propIndex, fieldType, isStringType, isNumericType, isIdentifierType);
        };
        whereGroup.appendChild(addRangeBtn);
      }
      
      container.appendChild(whereGroup);
    }

    // Handle operator changes and validation
    function handleOperatorChange(fieldName, fieldIndex, operator, isFirst) {
      const rangeOperators = ['>', '>=', '<', '<=', 'startsWith'];
      const isRangeOperator = rangeOperators.includes(operator);
      
      // Update range fields tracking
      if (isRangeOperator) {
        if (!rangeFields.has(fieldName)) {
          rangeFields.set(fieldName, { count: 0, operators: [] });
        }
        const fieldRanges = rangeFields.get(fieldName);
        fieldRanges.count = isFirst ? 1 : fieldRanges.count;
        fieldRanges.operators[isFirst ? 0 : 1] = operator;
        
        // Show add range button if first range (but not for startsWith)
        if (isFirst && fieldRanges.count === 1 && operator !== 'startsWith') {
          const addBtn = document.querySelector(`[data-field-name="${fieldName}"] .add-range-button`);
          if (addBtn) addBtn.style.display = 'inline-block';
        }
        
        // Disable all fields after this one
        disableFieldsAfterIndex(fieldIndex);
      } else if (!isRangeOperator && rangeFields.has(fieldName)) {
        // Remove from range tracking if not range operator
        if (isFirst) {
          rangeFields.delete(fieldName);
          // Hide add range button
          const addBtn = document.querySelector(`[data-field-name="${fieldName}"] .add-range-button`);
          if (addBtn) addBtn.style.display = 'none';
          // Remove second range clause if exists
          const secondClause = document.querySelector(`[data-field-name="${fieldName}"] [data-clause-number="2"]`);
          if (secondClause) secondClause.remove();
        }
        
        // Check if we need to re-enable fields
        checkAndUpdateFieldStates();
      }
      
      // Validate compound index rules
      validateCompoundIndexRules();
      updateQueryPreview();
    }

    // Add second range clause
    function addSecondRangeClause(container, propName, propIndex, fieldType, isStringType, isNumericType, isIdentifierType) {
      // Check if second clause already exists
      if (container.querySelector('[data-clause-number="2"]')) return;
      
      createWhereClause(container, propName, propIndex, fieldType, isStringType, isNumericType, isIdentifierType, false);
      
      // Update range count
      if (rangeFields.has(propName)) {
        rangeFields.get(propName).count = 2;
      }
      
      // Hide add button
      const addBtn = container.querySelector('.add-range-button');
      if (addBtn) addBtn.style.display = 'none';
      
      // Add between operator info
      const betweenInfo = document.createElement('div');
      betweenInfo.className = 'between-info';
      betweenInfo.innerHTML = '✓ These two range clauses will be combined into a Between operator';
      container.appendChild(betweenInfo);
      
      // Add event listeners to the new inputs
      const newInputs = container.querySelectorAll('[data-clause-number="2"] input, [data-clause-number="2"] select');
      newInputs.forEach(input => {
        input.addEventListener('input', updateQueryPreview);
        input.addEventListener('change', updateQueryPreview);
      });
      
      updateQueryPreview();
    }

    // Disable fields after a given index
    function disableFieldsAfterIndex(index) {
      currentIndexProperties.forEach((propName, propIndex) => {
        if (propIndex > index) {
          const fieldGroup = document.querySelector(`[data-field-name="${propName}"]`);
          if (fieldGroup) {
            fieldGroup.style.opacity = '0.5';
            fieldGroup.style.pointerEvents = 'none';
            
            // Clear any values in these fields
            const inputs = fieldGroup.querySelectorAll('input, select');
            inputs.forEach(input => {
              if (input.tagName === 'SELECT') {
                input.value = '';
                input.classList.remove('has-value');
              } else {
                input.value = '';
              }
            });
            
            // Add disabled message
            let disabledMsg = fieldGroup.querySelector('.disabled-message');
            if (!disabledMsg) {
              disabledMsg = document.createElement('div');
              disabledMsg.className = 'disabled-message';
              disabledMsg.style.color = '#6c757d';
              disabledMsg.style.fontSize = '0.9em';
              disabledMsg.style.marginTop = '5px';
              disabledMsg.innerHTML = 'ⓘ Cannot query on fields after a range query';
              fieldGroup.appendChild(disabledMsg);
            }
          }
        }
      });
    }
    
    // Enable all fields
    function enableAllFields() {
      currentIndexProperties.forEach(propName => {
        const fieldGroup = document.querySelector(`[data-field-name="${propName}"]`);
        if (fieldGroup) {
          fieldGroup.style.opacity = '1';
          fieldGroup.style.pointerEvents = 'auto';
          
          // Remove disabled message
          const disabledMsg = fieldGroup.querySelector('.disabled-message');
          if (disabledMsg) {
            disabledMsg.remove();
          }
        }
      });
    }
    
    // Check and update field states based on current range queries
    function checkAndUpdateFieldStates() {
      // First, enable all fields
      enableAllFields();
      
      // Find the earliest field with a range query
      let earliestRangeIndex = -1;
      rangeFields.forEach((info, fieldName) => {
        const fieldIndex = currentIndexProperties.indexOf(fieldName);
        if (fieldIndex !== -1 && (earliestRangeIndex === -1 || fieldIndex < earliestRangeIndex)) {
          earliestRangeIndex = fieldIndex;
        }
      });
      
      // If we found a range field, disable all fields after it
      if (earliestRangeIndex !== -1) {
        disableFieldsAfterIndex(earliestRangeIndex);
      }
    }

    // Validate compound index rules
    function validateCompoundIndexRules() {
      const errors = [];
      
      // Check each field with range operators
      rangeFields.forEach((info, fieldName) => {
        const fieldIndex = currentIndexProperties.indexOf(fieldName);
        
        // If range is not on first field, check preceding fields have equality
        if (fieldIndex > 0) {
          for (let i = 0; i < fieldIndex; i++) {
            const precedingField = currentIndexProperties[i];
            const equalityInput = document.querySelector(`[name="where_${precedingField}"]`);
            const equalityOp = document.querySelector(`[name="whereOp_${precedingField}"]`);
            
            if (!equalityInput?.value || equalityOp?.value !== '==') {
              errors.push(`Range query on "${fieldName}" requires equality constraint on "${precedingField}"`);
            }
          }
        }
      });
      
      // Check for multiple IN clauses
      const inClauses = document.querySelectorAll('select[name^="whereOp_"]');
      let inClauseCount = 0;
      inClauses.forEach(select => {
        if (select.value === 'in') inClauseCount++;
      });
      
      if (inClauseCount > 1) {
        errors.push('Only one IN clause is allowed per query');
      }
      
      // Display errors
      displayValidationErrors(errors);
      
      // Disable/enable execute button based on validation
      const executeBtn = document.getElementById('executeQuery');
      if (executeBtn) {
        executeBtn.disabled = errors.length > 0;
      }
      
      return errors.length === 0;
    }

    // Display validation errors
    function displayValidationErrors(errors) {
      // Remove existing error display
      const existingErrors = document.querySelectorAll('.validation-error');
      existingErrors.forEach(err => err.remove());
      
      if (errors.length > 0) {
        const errorContainer = document.createElement('div');
        errorContainer.className = 'validation-error';
        errorContainer.innerHTML = '<strong>Validation Errors:</strong><br>' + errors.join('<br>');
        
        const whereContainer = document.getElementById('dynamic_whereFields');
        if (whereContainer) {
          whereContainer.insertBefore(errorContainer, whereContainer.querySelector('.query-preview'));
        }
      }
    }

    // Update query preview
    function updateQueryPreview() {
      const previewContent = document.getElementById('queryPreviewContent');
      if (!previewContent) return;
      
      const whereClauses = [];
      
      // Collect all where clauses
      currentIndexProperties.forEach(fieldName => {
        const op1 = document.querySelector(`[name="whereOp_${fieldName}"]`)?.value;
        const val1 = document.querySelector(`[name="where_${fieldName}"]`)?.value;
        const op2 = document.querySelector(`[name="whereOp2_${fieldName}"]`)?.value;
        const val2 = document.querySelector(`[name="where2_${fieldName}"]`)?.value;
        
        if (op1 && val1) {
          if (rangeFields.has(fieldName) && op2 && val2) {
            // Combine range clauses
            const combined = combineRangeClauses(op1, val1, op2, val2);
            whereClauses.push(`["${fieldName}", "${combined.operator}", ${combined.value}]`);
          } else if (op1 === 'in') {
            const values = val1.split(',').map(v => v.trim());
            whereClauses.push(`["${fieldName}", "in", [${values.map(v => `"${v}"`).join(', ')}]]`);
          } else {
            whereClauses.push(`["${fieldName}", "${op1}", "${val1}"]`);
          }
        }
      });
      
      // Collect order by
      const orderBy = [];
      currentIndexProperties.forEach(fieldName => {
        const orderVal = document.querySelector(`[name="orderBy_${fieldName}"]`)?.value;
        if (orderVal) {
          orderBy.push(`["${fieldName}", "${orderVal}"]`);
        }
      });
      
      // Build preview
      let preview = '{\n';
      if (whereClauses.length > 0) {
        preview += `  "where": [\n    ${whereClauses.join(',\n    ')}\n  ]`;
      }
      if (orderBy.length > 0) {
        if (whereClauses.length > 0) preview += ',\n';
        preview += `  "orderBy": [\n    ${orderBy.join(',\n    ')}\n  ]`;
      }
      
      const limitInput = document.querySelector('[name="limit"]');
      if (limitInput?.value) {
        if (whereClauses.length > 0 || orderBy.length > 0) preview += ',\n';
        preview += `  "limit": ${limitInput.value}`;
      }
      
      preview += '\n}';
      
      previewContent.textContent = preview;
    }

    // Combine range clauses into Between operator
    function combineRangeClauses(op1, val1, op2, val2) {
      const ops = [op1, op2].sort();
      const vals = [parseFloat(val1), parseFloat(val2)].sort((a, b) => a - b);
      
      let operator = 'Between';
      if (ops.includes('>') && ops.includes('<')) {
        operator = 'BetweenExcludeBounds';
      } else if (ops.includes('>') && ops.includes('<=')) {
        operator = 'BetweenExcludeLeft';
      } else if (ops.includes('>=') && ops.includes('<')) {
        operator = 'BetweenExcludeRight';
      }
      
      return {
        operator: operator,
        value: `[${vals[0]}, ${vals[1]}]`
      };
    }

    // Add listeners for live preview updates
    function addQueryPreviewListeners() {
      const inputs = document.querySelectorAll('#dynamic_whereFields input, #dynamic_whereFields select, #dynamic_orderByFields select');
      inputs.forEach(input => {
        input.addEventListener('input', updateQueryPreview);
        input.addEventListener('change', updateQueryPreview);
      });
    }

    // Function to clear index fields
    function clearIndexFields() {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (whereContainer) {
        whereContainer.innerHTML = '';
        whereContainer.parentElement.style.display = 'none';
      }
      
      if (orderByContainer) {
        orderByContainer.innerHTML = '';
        orderByContainer.parentElement.style.display = 'none';
      }
      
      // Reset tracking variables
      currentIndexProperties = [];
      rangeFields.clear();
    }

    function displayResult(data, isError = false) {
      const splitContainer = document.getElementById('resultSplitContainer');
      const proofToggle = document.getElementById('proofToggle');
      const isProofMode = proofToggle && proofToggle.checked;
      
      if (isError) {
        // For errors, show in single view
        const safeData = DOMPurify.sanitize(data);
        splitContainer.innerHTML = `<div id="identityInfo" class="result-content error-result">${safeData}</div>`;
        currentResult = null;
      } else {
        // Parse JSON string if necessary
        let dataToFormat = data;
        if (typeof data === 'string') {
          try {
            dataToFormat = JSON.parse(data);
          } catch (e) {
            // If parsing fails, use the string as-is
            dataToFormat = data;
          }
        }
        
        // Check if this is a proof response (has data, metadata, and proof fields)
        const isProofResponse = dataToFormat && 
          typeof dataToFormat === 'object' && 
          'data' in dataToFormat && 
          'metadata' in dataToFormat && 
          'proof' in dataToFormat;
        
        if (isProofMode && isProofResponse) {
          // Split view for proof mode
          splitContainer.innerHTML = `
            <div class="result-data-section">
              <div class="section-header">Data</div>
              <div id="identityInfo" class="result-content"></div>
            </div>
            <div class="result-proof-section">
              <div class="section-header">Proof & Metadata</div>
              <div id="proofInfo" class="result-content"></div>
            </div>
          `;
          
          // Display data in top section
          const dataContent = document.getElementById('identityInfo');
          dataContent.innerHTML = DOMPurify.sanitize(formatResultWithCredits(dataToFormat.data));
          
          // Display proof and metadata in bottom section
          const proofContent = document.getElementById('proofInfo');
          const proofDisplay = {
            metadata: dataToFormat.metadata,
            proof: {
              grovedbProof: dataToFormat.proof.grovedbProof,
              quorumHash: dataToFormat.proof.quorumHash,
              signature: dataToFormat.proof.signature,
              round: dataToFormat.proof.round,
              blockIdHash: dataToFormat.proof.blockIdHash,
              quorumType: dataToFormat.proof.quorumType
            }
          };
          proofContent.innerHTML = DOMPurify.sanitize(formatResultWithCredits(proofDisplay));
        } else {
          // Single view for non-proof mode or non-proof responses
          splitContainer.innerHTML = `<div id="identityInfo" class="result-content"></div>`;
          const resultContent = document.getElementById('identityInfo');
          resultContent.innerHTML = DOMPurify.sanitize(formatResultWithCredits(dataToFormat));
        }
        
        currentResult = data;
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function formatResultWithCredits(data) {
      const CREDITS_PER_DASH = 100000000000; // 100 billion credits = 1 Dash
      
      function formatCreditsValue(credits) {
        const creditsNum = BigInt(credits);
        const CREDITS_PER_DASH_BIGINT = BigInt(CREDITS_PER_DASH);
        
        // Perform division using BigInt to get whole DASH
        const wholeDash = creditsNum / CREDITS_PER_DASH_BIGINT;
        // Get remainder for fractional part
        const remainder = creditsNum % CREDITS_PER_DASH_BIGINT;
        
        // Convert remainder to 8 decimal places
        // Multiply by 100000000 (8 decimal places) and divide by CREDITS_PER_DASH
        const fractionalPart = (remainder * BigInt(100000000)) / CREDITS_PER_DASH_BIGINT;
        
        // Construct the decimal string
        let dashFormatted;
        if (fractionalPart === BigInt(0)) {
          dashFormatted = wholeDash.toString();
        } else {
          // Pad fractional part to 8 digits
          const fractionalStr = fractionalPart.toString().padStart(8, '0');
          // Remove trailing zeros
          const trimmedFractional = fractionalStr.replace(/0+$/, '');
          dashFormatted = `${wholeDash}.${trimmedFractional}`;
        }
        
        return `<span class="credits-value" title="${escapeHtml(dashFormatted)} DASH">${escapeHtml(credits)}</span>`;
      }
      
      function formatNonceValue(nonce, key) {
        // Parse the nonce as a BigInt to handle large numbers
        const nonceBigInt = BigInt(nonce);
        
        // Determine if this is an identity contract nonce based on the field name
        const isContractNonce = key && key.toLowerCase().includes('contract');
        
        let nonceTooltip;
        
        if (isContractNonce) {
          // Identity Contract Nonce: First 24 bits are revision bitset, lower 40 bits are the nonce value
          const IDENTITY_NONCE_VALUE_FILTER = 0xFFFFFFFFFFn; // 40 bits
          const MISSING_IDENTITY_REVISIONS_FILTER = 0xFFFFFF0000000000n; // Upper 24 bits
          
          // Extract components
          const nonceValue = nonceBigInt & IDENTITY_NONCE_VALUE_FILTER; // Lower 40 bits
          const missingRevisionsBitset = (nonceBigInt & MISSING_IDENTITY_REVISIONS_FILTER) >> 40n; // Upper 24 bits
          
          // Convert to binary representation
          const binaryStr = nonceBigInt.toString(2).padStart(64, '0');
          const revisionBitsetBits = binaryStr.slice(0, 24);
          const nonceValueBits = binaryStr.slice(24, 64);
          
          // Find missing nonces based on the bitset
          const missingNonces = [];
          for (let i = 0; i < 24; i++) {
            if ((missingRevisionsBitset >> BigInt(i)) & 1n) {
              const missingNonce = nonceValue - BigInt(i + 1);
              missingNonces.push(missingNonce);
            }
          }
          
          nonceTooltip = `Identity Contract Nonce: ${nonce} (0x${nonceBigInt.toString(16).padStart(16, '0')})

Binary: ${binaryStr}

Bit Structure (Identity Contract Nonce):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Bits 63-40 (Missing Revisions): ${revisionBitsetBits} = ${missingRevisionsBitset}
Bits 39-0  (Nonce Value):       ${nonceValueBits} = ${nonceValue}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Decoded Values:
• Nonce Value: ${nonceValue} (current sequence number)
• Missing Revisions Bitset: ${missingRevisionsBitset} (tracks up to 24 missing nonces)
${missingNonces.length > 0 ? `• Missing Nonces: ${missingNonces.map(n => n.toString()).join(', ')}` : '• No missing nonces detected'}

Used for: Document operations and data contract updates`;
        } else {
          // Identity Nonce: Same structure as contract nonce but used for different operations
          const IDENTITY_NONCE_VALUE_FILTER = 0xFFFFFFFFFFn; // 40 bits
          const MISSING_IDENTITY_REVISIONS_FILTER = 0xFFFFFF0000000000n; // Upper 24 bits
          
          // Extract components
          const nonceValue = nonceBigInt & IDENTITY_NONCE_VALUE_FILTER; // Lower 40 bits
          const missingRevisionsBitset = (nonceBigInt & MISSING_IDENTITY_REVISIONS_FILTER) >> 40n; // Upper 24 bits
          
          // Convert to binary representation
          const binaryStr = nonceBigInt.toString(2).padStart(64, '0');
          const revisionBitsetBits = binaryStr.slice(0, 24);
          const nonceValueBits = binaryStr.slice(24, 64);
          
          // Find missing nonces based on the bitset
          const missingNonces = [];
          for (let i = 0; i < 24; i++) {
            if ((missingRevisionsBitset >> BigInt(i)) & 1n) {
              const missingNonce = nonceValue - BigInt(i + 1);
              missingNonces.push(missingNonce);
            }
          }
          
          nonceTooltip = `Identity Nonce: ${nonce} (0x${nonceBigInt.toString(16).padStart(16, '0')})

Binary: ${binaryStr}

Bit Structure (Identity Nonce):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Bits 63-40 (Missing Revisions): ${revisionBitsetBits} = ${missingRevisionsBitset}
Bits 39-0  (Nonce Value):       ${nonceValueBits} = ${nonceValue}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Decoded Values:
• Nonce Value: ${nonceValue} (current sequence number)
• Missing Revisions Bitset: ${missingRevisionsBitset} (tracks up to 24 missing nonces)
${missingNonces.length > 0 ? `• Missing Nonces: ${missingNonces.map(n => n.toString()).join(', ')}` : '• No missing nonces detected'}

Used for: Identity state transitions that use balance or create data contracts`;
        }
        
        return `<span class="nonce-value" title="${escapeHtml(nonceTooltip)}" style="cursor: help; border-bottom: 1px dotted #666; font-family: monospace;">${escapeHtml(nonce.toString())}</span>`;
      }
      
      function processValue(value, key, indent = 0) {
        // Check if this is a credits field
        const creditsFields = ['balance', 'totalCreditsInPlatform', 'credits', 'amount', 'totalCredits'];
        const isCreditsField = creditsFields.some(field => key.toLowerCase().includes(field.toLowerCase()));
        
        // Check if this is a nonce field
        const isNonceField = key.toLowerCase() === 'nonce';
        
        if (typeof value === 'string' && isCreditsField && /^\d+$/.test(value)) {
          return formatCreditsValue(value);
        } else if (typeof value === 'string' && isNonceField) {
          return formatNonceValue(value, key);
        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          return formatObject(value, indent);
        } else if (Array.isArray(value)) {
          return formatArray(value, indent);
        } else {
          return escapeHtml(JSON.stringify(value));
        }
      }
      
      function formatObject(obj, indent = 0) {
        const indentStr = '  '.repeat(indent);
        const innerIndentStr = '  '.repeat(indent + 1);
        const entries = Object.entries(obj).map(([key, value]) => {
          const formattedValue = processValue(value, key, indent + 1);
          const escapedKey = escapeHtml(key);
          return `${innerIndentStr}<span class="json-key">"${escapedKey}"</span>: ${formattedValue}`;
        });
        return `{
${entries.join(',\n')}
${indentStr}}`;
      }
      
      function formatArray(arr, indent = 0) {
        const indentStr = '  '.repeat(indent);
        const innerIndentStr = '  '.repeat(indent + 1);
        const items = arr.map((item, index) => {
          const formatted = processValue(item, '', indent + 1);
          // If the formatted value is multiline, we need to handle it differently
          if (formatted.includes('\n')) {
            return `${innerIndentStr}${formatted}`;
          }
          return `${innerIndentStr}${formatted}`;
        });
        return `[
${items.join(',\n')}
${indentStr}]`;
      }
      
      return `<pre>${processValue(data, '')}</pre>`;
    }

    function updateStatus(message, type = 'loading') {
      const statusBanner = document.getElementById('statusBanner');
      statusBanner.textContent = message;
      statusBanner.className = `status-banner ${type}`;
    }
    
    // Helper to update status with execution time
    function updateStatusWithTime(message, type, startTime) {
      const endTime = performance.now();
      const executionTime = ((endTime - startTime) / 1000).toFixed(1);
      updateStatus(`${message} (${executionTime}s)`, type);
    }

    async function initializeSdk(network) {
      const currentRequestToken = ++initRequestCounter;
      
      const preloader = document.getElementById('preloader');
      preloader.style.display = 'block';
      const useTrusted = true; // Always use trusted mode
      const modeStr = 'trusted';
      updateStatus(`Initializing ${network.toUpperCase()} SDK (${modeStr} mode)...`, 'loading');
      
      try {
        let newSdk;
        let shouldContinue = true;
        
        if (useTrusted) {
          updateStatus(`Prefetching quorum information for ${network.toUpperCase()}...`, 'loading');
          if (network === 'mainnet') {
            await prefetch_trusted_quorums_mainnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              let builder = WasmSdkBuilder.new_mainnet_trusted();
              
              // Apply configuration options
              const platformVersion = document.getElementById('platformVersion').value;
              if (platformVersion) {
                builder = builder.with_version(parseInt(platformVersion, 10));
              }
              
              // Apply request settings
              const connectTimeout = document.getElementById('connectTimeout').value;
              const requestTimeout = document.getElementById('requestTimeout').value;
              const retries = document.getElementById('retries').value;
              const banFailedAddress = document.getElementById('banFailedAddress').checked;
              
              builder = builder.with_settings(
                connectTimeout ? parseInt(connectTimeout, 10) : undefined,
                requestTimeout ? parseInt(requestTimeout, 10) : undefined,
                retries ? parseInt(retries, 10) : undefined,
                banFailedAddress || undefined
              );
              
              newSdk = await builder.build();
            }
          } else {
            await prefetch_trusted_quorums_testnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              let builder = WasmSdkBuilder.new_testnet_trusted();
              
              // Apply configuration options
              const platformVersion = document.getElementById('platformVersion').value;
              if (platformVersion) {
                builder = builder.with_version(parseInt(platformVersion, 10));
              }
              
              // Apply request settings
              const connectTimeout = document.getElementById('connectTimeout').value;
              const requestTimeout = document.getElementById('requestTimeout').value;
              const retries = document.getElementById('retries').value;
              const banFailedAddress = document.getElementById('banFailedAddress').checked;
              
              builder = builder.with_settings(
                connectTimeout ? parseInt(connectTimeout, 10) : undefined,
                requestTimeout ? parseInt(requestTimeout, 10) : undefined,
                retries ? parseInt(retries, 10) : undefined,
                banFailedAddress || undefined
              );
              
              newSdk = await builder.build();
            }
          }
        } else if (shouldContinue) {
          if (network === 'mainnet') {
            newSdk = await WasmSdkBuilder.new_mainnet().build();
          } else {
            newSdk = await WasmSdkBuilder.new_testnet().build();
          }
        }
        
        if (shouldContinue && currentRequestToken === initRequestCounter) {
          sdk = newSdk;
          currentNetwork = network; // Store the current network
          console.log(`Initialized ${network} SDK (${modeStr} mode):`, sdk);
          updateStatus(`WASM SDK successfully loaded on ${network.toUpperCase()} (${modeStr} mode)`, 'success');
          
          // Proof support is available for all queries - internally all queries use proof verification
          // When the proof toggle is ON (checked), queries return verified data WITH proof information displayed
          // When the proof toggle is OFF (unchecked), queries return verified data WITHOUT proof information displayed
          // Note: Both modes use proof verification internally; the toggle only controls whether proof details are shown
          
          // Display latest platform version info
          try {
            const latestVersion = WasmSdkBuilder.getLatestVersionNumber();
            document.getElementById('latestVersionInfo').textContent = `(Latest: v${latestVersion})`;
          } catch (e) {
            console.warn('Could not get latest platform version:', e);
          }
        }
      } catch (error) {
        if (currentRequestToken === initRequestCounter) {
          console.error(`Error initializing ${network} SDK:`, error);
          clearResults();
          updateStatus(`Error loading WASM SDK: ${error.message || error}`, 'error');
        }
      } finally {
        if (currentRequestToken === initRequestCounter) {
          preloader.style.display = 'none';
        }
      }
    }

// Dynamic input creation
    function createInput(inputDef, container) {
      const inputGroup = document.createElement('div');
      inputGroup.className = 'input-group';
      
      if (inputDef.type !== 'checkbox') {
        const label = document.createElement('label');
        label.textContent = inputDef.label;
        if (!inputDef.required) {
          const optionalSpan = document.createElement('span');
          optionalSpan.className = 'optional-label';
          optionalSpan.textContent = ' (optional)';
          label.appendChild(optionalSpan);
        }
        inputGroup.appendChild(label);
      }

      if (inputDef.type === 'text' || inputDef.type === 'number') {
        const input = document.createElement('input');
        input.type = inputDef.type;
        input.name = inputDef.name;
        input.placeholder = inputDef.placeholder || inputDef.label;
        if (inputDef.defaultValue !== undefined) {
          input.value = inputDef.defaultValue;
        }
        inputGroup.appendChild(input);
        
        // Add validation message container for DPNS username
        if (inputDef.validateOnType) {
          const validationMessage = document.createElement('div');
          validationMessage.className = 'validation-message';
          validationMessage.style.fontSize = '0.9em';
          validationMessage.style.marginTop = '5px';
          inputGroup.appendChild(validationMessage);
          
          // Add real-time validation
          input.addEventListener('input', (e) => {
            const value = e.target.value;
            
            if (!value) {
              validationMessage.textContent = '';
              validationMessage.className = 'validation-message';
              return;
            }
            
            // Check if it's a valid username
            const isValid = dpns_is_valid_username(value);
            
            if (!isValid) {
              validationMessage.textContent = '❌ Invalid username format. Must be 3-63 chars, start/end with letter/number, only letters/numbers/hyphens.';
              validationMessage.className = 'validation-message error';
              validationMessage.style.color = '#dc3545';
            } else {
              // Check if it's contested
              const isContested = dpns_is_contested_username(value);
              const homographSafe = dpns_convert_to_homograph_safe(value);
              const isHomographDifferent = value !== homographSafe;
              
              let message = '✅ Valid username';
              if (isContested) {
                message += ' (contested - requires masternode voting)';
              }
              if (isHomographDifferent) {
                message += `. Will be stored as "${homographSafe}"`;
              }
              
              validationMessage.textContent = message;
              validationMessage.className = 'validation-message success';
              validationMessage.style.color = isContested ? '#ff9800' : '#28a745';
            }
          });
        }
      } else if (inputDef.type === 'checkbox') {
        const checkboxContainer = document.createElement('div');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = inputDef.name;
        checkbox.id = `input_${inputDef.name}`;
        if (inputDef.defaultValue === true) {
          checkbox.checked = true;
        }
        
        const checkboxLabel = document.createElement('label');
        checkboxLabel.htmlFor = checkbox.id;
        checkboxLabel.textContent = inputDef.label;
        if (!inputDef.required) {
          const optionalSpan = document.createElement('span');
          optionalSpan.className = 'optional-label';
          optionalSpan.textContent = ' (optional)';
          checkboxLabel.appendChild(optionalSpan);
        }
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(checkboxLabel);
        inputGroup.appendChild(checkboxContainer);
      } else if (inputDef.type === 'select') {
        const select = document.createElement('select');
        select.name = inputDef.name;
        
        // Only add placeholder option if no default value is set
        if (!inputDef.value) {
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = `Select ${inputDef.label}`;
          select.appendChild(defaultOption);
        }
        
        if (!inputDef.dynamic) {
          inputDef.options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            // Set selected if this is the default value
            if (inputDef.value && opt.value === inputDef.value) {
              option.selected = true;
            }
            select.appendChild(option);
          });
        }
        
        inputGroup.appendChild(select);
        
        // Hide dynamic selects initially
        if (inputDef.dynamic) {
          inputGroup.style.display = 'none';
        }
      } else if (inputDef.type === 'multiselect') {
        const selectContainer = document.createElement('div');
        selectContainer.className = 'array-input-container';
        
        inputDef.options.forEach(opt => {
          const checkboxDiv = document.createElement('div');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.name = `${inputDef.name}_${opt.value}`;
          checkbox.value = opt.value;
          checkbox.id = `input_${inputDef.name}_${opt.value}`;
          
          const checkboxLabel = document.createElement('label');
          checkboxLabel.htmlFor = checkbox.id;
          checkboxLabel.textContent = opt.label;
          checkboxLabel.style.marginLeft = '5px';
          
          checkboxDiv.appendChild(checkbox);
          checkboxDiv.appendChild(checkboxLabel);
          selectContainer.appendChild(checkboxDiv);
        });
        
        inputGroup.appendChild(selectContainer);
      } else if (inputDef.type === 'array') {
        const arrayContainer = document.createElement('div');
        arrayContainer.className = 'array-input-container';
        arrayContainer.dataset.arrayName = inputDef.name;
        
        const addButton = document.createElement('button');
        addButton.className = 'add-array-item';
        addButton.textContent = '+ Add Item';
        addButton.onclick = () => addArrayItem(arrayContainer);
        
        arrayContainer.appendChild(addButton);
        inputGroup.appendChild(arrayContainer);
        
        // Add one empty item by default
        addArrayItem(arrayContainer);
      } else if (inputDef.type === 'json') {
        const textarea = document.createElement('textarea');
        textarea.name = inputDef.name;
        textarea.placeholder = inputDef.placeholder || `Enter valid JSON for ${inputDef.label}`;
        textarea.style.width = '100%';
        textarea.style.minHeight = '100px';
        textarea.style.padding = '8px';
        textarea.style.border = '1px solid #ddd';
        textarea.style.borderRadius = '4px';
        textarea.style.fontFamily = 'monospace';
        textarea.setAttribute('data-json', 'true'); // Mark as JSON textarea
        inputGroup.appendChild(textarea);
      } else if (inputDef.type === 'textarea') {
        const textarea = document.createElement('textarea');
        textarea.name = inputDef.name;
        textarea.placeholder = inputDef.placeholder || inputDef.label;
        textarea.rows = inputDef.rows || 3;
        textarea.style.width = '100%';
        textarea.style.padding = '8px';
        textarea.style.border = '1px solid #ddd';
        textarea.style.borderRadius = '4px';
        if (inputDef.defaultValue !== undefined) {
          textarea.value = inputDef.defaultValue;
        }
        inputGroup.appendChild(textarea);
      } else if (inputDef.type === 'button') {
        const button = document.createElement('button');
        button.textContent = inputDef.label;
        button.className = 'action-button';
        button.onclick = () => window[inputDef.action]();
        inputGroup.appendChild(button);
      } else if (inputDef.type === 'keyPreview') {
        // Key preview for identity creation
        const previewContainer = document.createElement('div');
        previewContainer.className = 'key-preview-container';
        previewContainer.style.marginTop = '10px';
        previewContainer.style.padding = '15px';
        previewContainer.style.backgroundColor = '#f8f9fa';
        previewContainer.style.border = '1px solid #dee2e6';
        previewContainer.style.borderRadius = '4px';
        previewContainer.id = 'keyPreviewContainer';
        
        // This will be updated dynamically based on seed phrase and selection mode
        previewContainer.innerHTML = '<p style="color: #6c757d;">Enter a seed phrase to preview keys</p>';
        
        inputGroup.appendChild(previewContainer);
      } else if (inputDef.type === 'info') {
        const infoDiv = document.createElement('div');
        infoDiv.className = 'info-box';
        infoDiv.style.padding = '10px';
        infoDiv.style.backgroundColor = '#f0f8ff';
        infoDiv.style.border = '1px solid #4682b4';
        infoDiv.style.borderRadius = '4px';
        infoDiv.style.marginTop = '10px';
        infoDiv.style.fontSize = '0.9em';
        infoDiv.innerHTML = inputDef.content || '';
        infoDiv.id = `info_${inputDef.name}`;
        inputGroup.appendChild(infoDiv);
      } else if (inputDef.type === 'dynamic') {
        // Container for dynamically generated fields
        const dynamicContainer = document.createElement('div');
        dynamicContainer.id = `dynamic_${inputDef.name}`;
        dynamicContainer.className = 'dynamic-fields-container';
        inputGroup.appendChild(dynamicContainer);
        // Hide initially
        inputGroup.style.display = 'none';
      }

      // Handle dependencies
      if (inputDef.dependsOn) {
        inputGroup.style.display = 'none';
        inputGroup.dataset.dependsOn = inputDef.dependsOn.field;
        inputGroup.dataset.dependsOnValue = Array.isArray(inputDef.dependsOn.value) 
          ? inputDef.dependsOn.value.join(',') 
          : inputDef.dependsOn.value;
      }

      container.appendChild(inputGroup);
    }

    function addArrayItem(container) {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'array-item';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Enter value';
      
      const removeButton = document.createElement('button');
      removeButton.textContent = 'Remove';
      removeButton.onclick = () => itemDiv.remove();
      
      itemDiv.appendChild(input);
      itemDiv.appendChild(removeButton);
      
      const addButton = container.querySelector('.add-array-item');
      container.insertBefore(itemDiv, addButton);
    }

    function getInputValues() {
      const values = {};
      const dynamicInputs = document.getElementById('dynamicInputs');
      
      // Text, number, and select inputs
      dynamicInputs.querySelectorAll('input[type="text"], input[type="number"], select').forEach(input => {
        if (input.name) {
          if (input.type === 'number') {
            if (input.value !== '') {
              const numValue = parseInt(input.value);
              if (!isNaN(numValue)) {
                values[input.name] = numValue;
              }
            }
          } else if (input.value) {
            values[input.name] = input.value;
          }
        }
      });
      
      // Checkboxes
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && !checkbox.name.includes('_')) {
          values[checkbox.name] = checkbox.checked;
        }
      });
      
      // Multiselect checkboxes
      const multiselects = {};
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && checkbox.name.includes('_')) {
          const baseName = checkbox.name.split('_')[0];
          if (!multiselects[baseName]) multiselects[baseName] = [];
          if (checkbox.checked) {
            multiselects[baseName].push(parseInt(checkbox.value));
          }
        }
      });
      Object.assign(values, multiselects);
      
      // Arrays
      dynamicInputs.querySelectorAll('.array-input-container').forEach(container => {
        const arrayName = container.dataset.arrayName;
        if (arrayName) {
          const arrayValues = [];
          container.querySelectorAll('.array-item input').forEach(input => {
            if (input.value) arrayValues.push(input.value);
          });
          if (arrayValues.length > 0) {
            values[arrayName] = arrayValues;
          }
        }
      });
      
      // JSON inputs (only for textareas explicitly marked as JSON)
      dynamicInputs.querySelectorAll('textarea[data-json="true"]').forEach(textarea => {
        if (textarea.name && textarea.value) {
          try {
            values[textarea.name] = JSON.parse(textarea.value);
          } catch (e) {
            throw new Error(`Invalid JSON in ${textarea.name}: ${e.message}`);
          }
        }
      });
      
      // Regular text textareas (not JSON)
      dynamicInputs.querySelectorAll('textarea:not([data-json="true"])').forEach(textarea => {
        if (textarea.name && textarea.value) {
          values[textarea.name] = textarea.value;
        }
      });
      
      // Handle dynamic where fields with improved support for multiple ranges
      if (currentIndexProperties && currentIndexProperties.length > 0) {
        const whereClause = [];
        
        currentIndexProperties.forEach(fieldName => {
          const op1 = dynamicInputs.querySelector(`select[name="whereOp_${fieldName}"]`)?.value;
          const val1 = dynamicInputs.querySelector(`input[name="where_${fieldName}"]`)?.value;
          const op2 = dynamicInputs.querySelector(`select[name="whereOp2_${fieldName}"]`)?.value;
          const val2 = dynamicInputs.querySelector(`input[name="where2_${fieldName}"]`)?.value;
          
          if (op1 && val1) {
            // Check if we have two range operators that should be combined
            if (rangeFields && rangeFields.has(fieldName) && op2 && val2) {
              // Combine range clauses into Between operator
              const combined = combineRangeClauses(op1, val1, op2, val2);
              // Keep values as strings and let backend handle type conversion
              const value = [val1, val2].sort();
              whereClause.push([fieldName, combined.operator, value]);
            } else if (op1 === 'in') {
              // Handle IN operator - split comma-separated values
              const values = val1.split(',').map(v => v.trim()).filter(v => v);
              whereClause.push([fieldName, op1, values]);
            } else {
              // Single operator clause
              // Keep value as string - the backend will handle type conversion
              whereClause.push([fieldName, op1, val1]);
            }
          }
        });
        
        if (whereClause.length > 0) {
          values.where = whereClause;
        }
      }
      
      // Handle dynamic order by fields
      const orderBySelects = dynamicInputs.querySelectorAll('select[name^="orderBy_"]');
      if (orderBySelects.length > 0) {
        const orderBy = [];
        orderBySelects.forEach(select => {
          if (select.value) {
            const fieldName = select.name.replace('orderBy_', '');
            orderBy.push([fieldName, select.value]);
          }
        });
        if (orderBy.length > 0) {
          values.orderBy = orderBy;
        }
      }
      
      return values;
    }

    // Query execution
    async function executeQuery(category, queryType) {
      if (!sdk) {
        alert('SDK not initialized. Please wait or refresh the page.');
        return;
      }

      const queryDef = queryDefinitions[category]?.queries?.[queryType];
      if (!queryDef) {
        alert('Invalid query selection or definitions not loaded');
        return;
      }
      
      // Start timing
      const startTime = performance.now();

      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;

      button.disabled = true;
      button.textContent = 'Executing...';
      updateStatus(`Executing ${queryDef.label}...`, 'loading');

      try {
        const values = getInputValues();
        let result;
        
        // Check if proof toggle is enabled
        const proofToggle = document.getElementById('proofToggle');
        const useProofs = proofToggle && proofToggle.checked;
        
        // Identity queries
        if (queryType === 'getIdentity') {
          if (!values.id) {
            throw new Error('Identity ID is required for getIdentity query');
          }
          if (useProofs) {
            result = await identity_fetch_with_proof_info(sdk, values.id);
            // Result is already a JS object with proof data
          } else {
            result = await identity_fetch(sdk, values.id);
            result = result.toJSON();
          }
        } else if (queryType === 'getIdentityKeys') {
          const keyIds = values.keyRequestType === 'specific' ? values.specificKeyIds : undefined;
          const searchPurposeMap = values.keyRequestType === 'search' ? values.searchPurposeMap : undefined;
          
          // Validate required parameters based on key request type
          if (values.keyRequestType === 'search' && !searchPurposeMap) {
            throw new Error('Search Purpose Map is required when using search key request type');
          }
          if (values.keyRequestType === 'specific' && (!keyIds || keyIds.length === 0)) {
            throw new Error('Key IDs are required when using specific key request type');
          }
          
          if (useProofs) {
            if (values.keyRequestType === 'search') {
              // Search keys with proof not yet supported in WASM SDK, fallback to non-proof version
              console.warn('Search keys with proof not yet supported, using non-proof version');
              result = await get_identity_keys(
                sdk,
                values.identityId,
                values.keyRequestType,
                keyIds,
                searchPurposeMap,
                values.limit,
                values.offset
              );
            } else {
              // 'all' and 'specific' key types support proof
              result = await get_identity_keys_with_proof_info(
                sdk,
                values.identityId,
                values.keyRequestType,
                keyIds,
                values.limit,
                values.offset
              );
            }
          } else {
            result = await get_identity_keys(
              sdk,
              values.identityId,
              values.keyRequestType,
              keyIds,
              searchPurposeMap,
              values.limit,
              values.offset
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentitiesContractKeys') {
          const purposes = values.purposes ? values.purposes.map(p => parseInt(p)) : undefined;
          if (useProofs) {
            result = await get_identities_contract_keys_with_proof_info(
              sdk,
              values.identitiesIds,
              values.contractId,
              purposes
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identities_contract_keys(
              sdk,
              values.identitiesIds,
              values.contractId,
              purposes
            );
            // Result is already a JS object from serde_wasm_bindgen
          }
        } else if (queryType === 'getIdentityNonce') {
          if (useProofs) {
            result = await get_identity_nonce_with_proof_info(sdk, values.identityId);
          } else {
            result = await get_identity_nonce(sdk, values.identityId);
          }
        } else if (queryType === 'getIdentityContractNonce') {
          if (useProofs) {
            result = await get_identity_contract_nonce_with_proof_info(sdk, values.identityId, values.contractId);
          } else {
            result = await get_identity_contract_nonce(sdk, values.identityId, values.contractId);
          }
        } else if (queryType === 'getIdentityBalance') {
          if (useProofs) {
            result = await get_identity_balance_with_proof_info(sdk, values.id);
          } else {
            result = await get_identity_balance(sdk, values.id);
          }
          // Result is already an object with balance field
        } else if (queryType === 'getIdentitiesBalances') {
          if (useProofs) {
            result = await get_identities_balances_with_proof_info(sdk, values.ids);
          } else {
            result = await get_identities_balances(sdk, values.ids);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityBalanceAndRevision') {
          if (useProofs) {
            result = await get_identity_balance_and_revision_with_proof_info(sdk, values.id);
          } else {
            result = await get_identity_balance_and_revision(sdk, values.id);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityByPublicKeyHash') {
          if (useProofs) {
            result = await get_identity_by_public_key_hash_with_proof_info(sdk, values.publicKeyHash);
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identity_by_public_key_hash(sdk, values.publicKeyHash);
            result = result.toJSON();
          }
        } else if (queryType === 'getIdentityByNonUniquePublicKeyHash') {
          if (useProofs) {
            result = await get_identity_by_non_unique_public_key_hash_with_proof_info(
              sdk,
              values.publicKeyHash,
              values.startAfter || undefined
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identity_by_non_unique_public_key_hash(
              sdk,
              values.publicKeyHash,
              values.startAfter || undefined
            );
            // Result is already a JS array
          }
        } else if (queryType === 'getIdentityTokenBalances') {
          if (useProofs) {
            result = await get_identity_token_balances_with_proof_info(sdk, values.identityId, values.tokenIds);
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identity_token_balances(sdk, values.identityId, values.tokenIds);
            // Result is already a JS object from serde_wasm_bindgen
          }
        }
        // Data contract queries
        else if (queryType === 'getDataContract' && values.id) {
          if (useProofs) {
            result = await data_contract_fetch_with_proof_info(sdk, values.id);
            // Result is already a JS object with proof data
          } else {
            result = await data_contract_fetch(sdk, values.id);
            result = result.toJSON();
          }
        } else if (queryType === 'getDataContractHistory') {
          if (useProofs) {
            result = await get_data_contract_history_with_proof_info(
              sdk,
              values.id,
              values.limit,
              values.offset,
              values.startAtMs
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_data_contract_history(
              sdk,
              values.id,
              values.limit,
              values.offset,
              values.startAtMs
            );
            // Result is already a JS object from serde_wasm_bindgen
          }
        } else if (queryType === 'getDataContracts') {
          if (useProofs) {
            result = await get_data_contracts_with_proof_info(sdk, values.ids);
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_data_contracts(sdk, values.ids);
            // Result is already a JS object from serde_wasm_bindgen
          }
        }
        // Document queries
        else if (queryType === 'getDocuments') {
          const startAfter = values.startOption === 'startAfter' ? values.startValue : undefined;
          const startAt = values.startOption === 'startAt' ? values.startValue : undefined;
          
          // Debug logging
          console.log('Document Query:', {
            dataContractId: values.dataContractId,
            documentType: values.documentType,
            where: values.where,
            orderBy: values.orderBy,
            limit: values.limit
          });
          
          if (useProofs) {
            result = await get_documents_with_proof_info(
              sdk,
              values.dataContractId,
              values.documentType,
              values.where ? JSON.stringify(values.where) : undefined,
              values.orderBy ? JSON.stringify(values.orderBy) : undefined,
              values.limit,
              startAfter,
              startAt
            );
          } else {
            result = await get_documents(
              sdk,
              values.dataContractId,
              values.documentType,
              values.where ? JSON.stringify(values.where) : undefined,
              values.orderBy ? JSON.stringify(values.orderBy) : undefined,
              values.limit,
              startAfter,
              startAt
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getDocument') {
          if (useProofs) {
            result = await get_document_with_proof_info(
              sdk,
              values.dataContractId,
              values.documentType,
              values.documentId
            );
          } else {
            result = await get_document(
              sdk,
              values.dataContractId,
              values.documentType,
              values.documentId
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getDpnsUsername') {
          if (useProofs) {
            result = await get_dpns_usernames_with_proof_info(
              sdk,
              values.identityId,
              values.limit || 10  // Default to 10 if not specified
            );
          } else {
            result = await get_dpns_usernames(
              sdk,
              values.identityId,
              values.limit || 10  // Default to 10 if not specified
            );
          }
          // Result is an array of usernames
        } else if (queryType === 'dpnsCheckAvailability') {
          // Handle DPNS availability check
          const isValid = dpns_is_valid_username(values.label);
          
          if (!isValid) {
            result = {
              label: values.label,
              valid: false,
              message: "❌ Invalid username format",
              requirements: [
                "Must be 3-63 characters long",
                "Must start and end with a letter or number",
                "Can only contain letters, numbers, and hyphens",
                "Cannot have consecutive hyphens"
              ]
            };
          } else {
            const isAvailable = await dpns_is_name_available(
              sdk,
              values.label
            );
            
            const homographSafe = dpns_convert_to_homograph_safe(values.label);
            const isHomographDifferent = values.label !== homographSafe;
            const isContested = dpns_is_contested_username(values.label);
            
            result = {
              label: values.label,
              valid: true,
              homographSafeLabel: homographSafe,
              available: isAvailable,
              contested: isContested,
              message: isAvailable ? `"${values.label}" is available!` : `"${values.label}" is already taken.`,
              note: isHomographDifferent ? `Note: Your username will be stored as "${homographSafe}" to prevent homograph attacks` : undefined,
              contestedNote: isContested && isAvailable ? 
                "⚠️ This is a contested username (3-19 chars, only a-z/0/1/-). It requires masternode voting to register." : undefined
            };
          }
        } else if (queryType === 'dpnsResolve') {
          // Handle DPNS name resolution
          const resolvedIdentityId = await dpns_resolve_name(
            sdk,
            values.name
          );
          
          result = {
            name: values.name,
            identityId: resolvedIdentityId,
            message: resolvedIdentityId ? `Resolved to identity: ${resolvedIdentityId}` : `Name "${values.name}" not found`
          };
        } else if (queryType === 'dpnsSearch') {
          // Handle DPNS name search with starts-with query
          const limit = values.limit || 10;
          
          // DPNS contract ID on testnet
          const DPNS_CONTRACT_ID = "GWRSAVFMjXx8HpQFaNJMqBV7MBgMK4br5UESsB4S31Ec";
          const DPNS_DOCUMENT_TYPE = "domain";
          
          // Build where clause for starts-with query on normalizedLabel
          const whereClause = JSON.stringify([
            ["normalizedLabel", "startsWith", values.prefix.toLowerCase()],
            ["normalizedParentDomainName", "==", "dash"]
          ]);
          
          // Order by normalizedLabel ascending
          const orderBy = JSON.stringify([
            ["normalizedLabel", "asc"]
          ]);
          
          // Execute the document query
          let documents;
          if (useProofs) {
            documents = await get_documents_with_proof_info(
              sdk,
              DPNS_CONTRACT_ID,
              DPNS_DOCUMENT_TYPE,
              whereClause,
              orderBy,
              limit,
              null, // startAfter
              null  // startAt
            );
          } else {
            documents = await get_documents(
              sdk,
              DPNS_CONTRACT_ID,
              DPNS_DOCUMENT_TYPE,
              whereClause,
              orderBy,
              limit,
              null, // startAfter
              null  // startAt
            );
          }
          
          // Transform the results to show username and owner identity
          const documentsArray = useProofs ? documents.data : documents;
          const searchResults = documentsArray.map(doc => {
            // Access the data field which contains the DPNS document fields
            const data = doc.data || doc;
            
            return {
              username: `${data.normalizedLabel || data.label || 'unknown'}.${data.normalizedParentDomainName || 'dash'}`,
              label: data.label || '',
              normalizedLabel: data.normalizedLabel || '',
              ownerId: doc.ownerId || doc.$ownerId || '',
              documentId: doc.id || doc.$id || ''
            };
          });
          
          const processedResult = {
            prefix: values.prefix,
            totalResults: searchResults.length,
            limit: limit,
            results: searchResults,
            message: searchResults.length > 0 
              ? `Found ${searchResults.length} name(s) starting with "${values.prefix}"` 
              : `No names found starting with "${values.prefix}"`
          };
          
          if (useProofs) {
            // Create proof response structure with processed data for split view
            result = {
              data: processedResult,
              metadata: documents.metadata,
              proof: documents.proof
            };
          } else {
            result = processedResult;
          }
        }
        // Protocol/Version queries
        else if (queryType === 'getProtocolVersionUpgradeState') {
          if (useProofs) {
            result = await get_protocol_version_upgrade_state_with_proof_info(sdk);
          } else {
            result = await get_protocol_version_upgrade_state(sdk);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getProtocolVersionUpgradeVoteStatus') {
          result = await get_protocol_version_upgrade_vote_status(
            sdk,
            values.startProTxHash || '',  // Empty string if not provided
            values.count || 100           // Default to 100 if not provided
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Epoch/Block queries
        else if (queryType === 'getEpochsInfo') {
          if (useProofs) {
            result = await get_epochs_info_with_proof_info(
              sdk,
              values.startEpoch,
              values.count,
              values.ascending
            );
          } else {
            result = await get_epochs_info(
              sdk,
              values.startEpoch,
              values.count,
              values.ascending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentEpoch') {
          if (useProofs) {
            result = await get_current_epoch_with_proof_info(sdk);
          } else {
            result = await get_current_epoch(sdk);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getFinalizedEpochInfos') {
          if (useProofs) {
            result = await get_finalized_epoch_infos_with_proof_info(
              sdk,
              values.startEpoch,
              values.count,
              values.ascending
            );
          } else {
            result = await get_finalized_epoch_infos(
              sdk,
              values.startEpoch,
              values.count,
              values.ascending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter || undefined,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // System/Utility queries
        else if (queryType === 'getStatus') {
          result = await get_status(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTotalCreditsInPlatform') {
          if (useProofs) {
            result = await get_total_credits_in_platform_with_proof_info(sdk);
          } else {
            result = await get_total_credits_in_platform(sdk);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'waitForStateTransitionResult') {
          if (!values.stateTransitionHash) {
            throw new Error('Missing required parameter: stateTransitionHash is required');
          }
          result = await wait_for_state_transition_result(sdk, values.stateTransitionHash);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentQuorumsInfo') {
          result = await get_current_quorums_info(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPrefundedSpecializedBalance') {
          if (!values.identityId) {
            throw new Error('Missing required parameter: identityId is required');
          }
          if (useProofs) {
            result = await get_prefunded_specialized_balance_with_proof_info(sdk, values.identityId);
          } else {
            result = await get_prefunded_specialized_balance(sdk, values.identityId);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPathElements') {
          if (!values.keys || values.keys.length === 0) {
            throw new Error('Missing required parameter: keys array is required');
          }
          if (!values.path) {
            values.path = []; // Default to empty path if not provided
          }
          if (useProofs) {
            result = await get_path_elements_with_proof_info(sdk, values.path, values.keys);
          } else {
            result = await get_path_elements(sdk, values.path, values.keys);
          }
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Token queries
        else if (queryType === 'getIdentitiesTokenBalances') {
          if (useProofs) {
            result = await get_identities_token_balances_with_proof_info(sdk, values.identityIds, values.tokenId);
          } else {
            result = await get_identities_token_balances(sdk, values.identityIds, values.tokenId);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityTokenInfos') {
          if (useProofs) {
            result = await get_identity_token_infos_with_proof_info(
              sdk,
              values.identityId,
              values.tokenIds,
              values.limit,
              values.offset
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identity_token_infos(
              sdk,
              values.identityId,
              values.tokenIds,
              values.limit,
              values.offset
            );
            // Result is already a JS object from serde_wasm_bindgen
          }
        } else if (queryType === 'getIdentitiesTokenInfos') {
          if (useProofs) {
            result = await get_identities_token_infos_with_proof_info(
              sdk,
              values.identityIds,
              values.tokenId
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_identities_token_infos(
              sdk,
              values.identityIds,
              values.tokenId
            );
            // Result is already a JS object from serde_wasm_bindgen
          }
        } else if (queryType === 'getTokenStatuses') {
          if (useProofs) {
            result = await get_token_statuses_with_proof_info(sdk, values.tokenIds);
          } else {
            result = await get_token_statuses(sdk, values.tokenIds);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenDirectPurchasePrices') {
          if (useProofs) {
            result = await get_token_direct_purchase_prices_with_proof_info(sdk, values.tokenIds);
          } else {
            result = await get_token_direct_purchase_prices(sdk, values.tokenIds);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenContractInfo') {
          if (useProofs) {
            result = await get_token_contract_info_with_proof_info(sdk, values.dataContractId);
          } else {
            result = await get_token_contract_info(sdk, values.dataContractId);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenPerpetualDistributionLastClaim') {
          if (useProofs) {
            result = await get_token_perpetual_distribution_last_claim_with_proof_info(
              sdk,
              values.identityId,
              values.tokenId
            );
          } else {
            result = await get_token_perpetual_distribution_last_claim(
              sdk,
              values.identityId,
              values.tokenId
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTokenTotalSupply') {
          if (useProofs) {
            result = await get_token_total_supply_with_proof_info(sdk, values.tokenId);
          } else {
            result = await get_token_total_supply(sdk, values.tokenId);
          }
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Voting/Contested Resource queries
        else if (queryType === 'getContestedResources') {
          const startAtValue = values.startAtValue ? new TextEncoder().encode(values.startAtValue) : undefined;
          if (useProofs) {
            result = await get_contested_resources_with_proof_info(
              sdk,
              values.documentTypeName,
              values.dataContractId,
              values.indexName,
              startAtValue,
              values.limit,
              values.offset,
              values.orderAscending
            );
          } else {
            result = await get_contested_resources(
              sdk,
              values.documentTypeName,
              values.dataContractId,
              values.indexName,
              startAtValue,
              values.limit,
              values.offset,
              values.orderAscending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceVoteState') {
          if (useProofs) {
            result = await get_contested_resource_vote_state_with_proof_info(
              sdk,
              values.dataContractId,
              values.documentTypeName,
              values.indexName,
              values.indexValues,
              values.resultType,
              values.allowIncludeLockedAndAbstainingVoteTally,
              values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
              values.count,
              values.orderAscending
            );
          } else {
            result = await get_contested_resource_vote_state(
              sdk,
              values.dataContractId,
              values.documentTypeName,
              values.indexName,
              values.indexValues,
              values.resultType,
              values.allowIncludeLockedAndAbstainingVoteTally,
              values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
              values.count,
              values.orderAscending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceVotersForIdentity') {
          if (useProofs) {
            result = await get_contested_resource_voters_for_identity_with_proof_info(
              sdk,
              values.dataContractId,
              values.documentTypeName,
              values.indexName,
              values.indexValues,
              values.contestantId,
              values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
              values.count,
              values.orderAscending
            );
          } else {
            result = await get_contested_resource_voters_for_identity(
              sdk,
              values.dataContractId,
              values.documentTypeName,
              values.indexName,
              values.indexValues,
              values.contestantId,
              values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
              values.count,
              values.orderAscending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getContestedResourceIdentityVotes') {
          if (useProofs) {
            result = await get_contested_resource_identity_votes_with_proof_info(
              sdk,
              values.identityId,
              values.limit,
              values.offset,
              values.orderAscending
            );
          } else {
            result = await get_contested_resource_identity_votes(
              sdk,
              values.identityId,
              values.limit,
              values.offset,
              values.orderAscending
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getVotePollsByEndDate') {
          if (useProofs) {
            result = await get_vote_polls_by_end_date_with_proof_info(
              sdk,
              values.startTimeMs,
              values.endTimeMs,
              values.limit,
              values.offset,
              values.orderAscending
            );
            // Result is already a JS object from serde_wasm_bindgen
          } else {
            result = await get_vote_polls_by_end_date(
              sdk,
              values.startTimeMs,
              values.endTimeMs,
              values.limit,
              values.offset,
              values.orderAscending
            );
            // Result is already a JS object from serde_wasm_bindgen
          }
        }
        // Epoch/Block queries
        else if (queryType === 'getFinalizedEpochInfos') {
          result = await get_finalized_epoch_infos(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Group queries
        else if (queryType === 'getGroupInfo') {
          if (useProofs) {
            result = await get_group_info_with_proof_info(sdk, values.contractId, values.groupContractPosition);
          } else {
            result = await get_group_info(sdk, values.contractId, values.groupContractPosition);
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupInfos') {
          let startAtInfo = null;
          if (values.startAtGroupContractPosition !== undefined) {
            startAtInfo = {
              position: values.startAtGroupContractPosition,
              included: values.startGroupContractPositionIncluded || false
            };
          }
          if (useProofs) {
            result = await get_group_infos_with_proof_info(
              sdk,
              values.contractId,
              startAtInfo,
              values.count
            );
          } else {
            result = await get_group_infos(
              sdk,
              values.contractId,
              startAtInfo,
              values.count
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupActions') {
          let startAtInfo = null;
          if (values.startActionId) {
            startAtInfo = {
              actionId: values.startActionId,
              included: values.startActionIdIncluded || false
            };
          }
          if (useProofs) {
            result = await get_group_actions_with_proof_info(
              sdk,
              values.contractId,
              values.groupContractPosition,
              values.status,
              startAtInfo,
              values.count
            );
          } else {
            result = await get_group_actions(
              sdk,
              values.contractId,
              values.groupContractPosition,
              values.status,
              startAtInfo,
              values.count
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getGroupActionSigners') {
          if (useProofs) {
            result = await get_group_action_signers_with_proof_info(
              sdk,
              values.contractId,
              values.groupContractPosition,
              values.status,
              values.actionId
            );
          } else {
            result = await get_group_action_signers(
              sdk,
              values.contractId,
              values.groupContractPosition,
              values.status,
              values.actionId
            );
          }
          // Result is already a JS object from serde_wasm_bindgen
        } else {
          // Placeholder for unimplemented queries
          throw new Error(`Query ${queryType} is not yet implemented in the WASM SDK bindings`);
        }
        
        displayResult(result);
        
        // Calculate and display execution time
        const endTime = performance.now();
        const executionTime = ((endTime - startTime) / 1000).toFixed(1);
        updateStatus(`${queryDef.label} executed successfully (${executionTime}s)`, 'success');
      } catch (error) {
        console.error(`Error executing ${queryType}:`, error);
        displayResult(`Error executing query: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }
    
    async function executeStateTransition(category, transitionType) {
      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;
      button.disabled = true;
      button.textContent = 'Processing...';
      
      // Start timing
      const startTime = performance.now();
      
      updateStatus(`Executing ${transitionType} state transition...`, 'loading');
      
      try {
        // Get authentication values
        let identityId = document.getElementById('identityId').value.trim();
        let privateKey = document.getElementById('privateKey').value.trim();
        let assetLockProof = document.getElementById('assetLockProof').value.trim();
        
        // Validate based on transition type
        if (transitionType === 'identityCreate' || transitionType === 'identityTopUp') {
          if (!assetLockProof || !privateKey) {
            throw new Error('Asset Lock Proof and Private Key are required for this transition');
          }
          identityId = null; // No identity ID needed for create (except for topUp which gets it from form)
        } else {
          if (!identityId || !privateKey) {
            throw new Error('Identity ID and Private Key are required for state transitions');
          }
          assetLockProof = null; // No asset lock proof needed for other transitions
        }
        
        // Get input values
        const values = getInputValues();
        let result;
        
        // Execute the state transition based on type
        if (transitionType === 'identityCreate') {
          // Generate public keys from seed phrase
          const seedPhrase = values.seedPhrase?.trim();
          const identityIndex = parseInt(values.identityIndex || '0');
          const keySelectionMode = values.keySelectionMode || 'default';
          const selectedKeyType = values.keyType || 'ECDSA_HASH160';
          
          if (!seedPhrase || !validate_mnemonic(seedPhrase)) {
            throw new Error('Invalid seed phrase');
          }
          
          let publicKeys = [];
          
          if (keySelectionMode === 'default') {
            // Generate the same keys as shown in the preview
            const coinType = currentNetwork === 'mainnet' ? 5 : 1;
            
            // Master key (authentication, master level)
            const masterKeyPath = `m/9'/${coinType}'/5'/0'/0'/${identityIndex}'/0'`;
            const masterKey = derive_key_from_seed_with_path(seedPhrase, undefined, masterKeyPath, currentNetwork);
            console.log('Master key object:', masterKey);
            console.log('Master key fields:', Object.keys(masterKey || {}));
            
            // Additional authentication key (high security)
            const authKeyPath = `m/9'/${coinType}'/5'/0'/0'/${identityIndex}'/1'`;
            const authKey = derive_key_from_seed_with_path(seedPhrase, undefined, authKeyPath, currentNetwork);
            
            // Transfer key (critical security)
            const transferKeyPath = `m/9'/${coinType}'/5'/0'/0'/${identityIndex}'/2'`;
            const transferKey = derive_key_from_seed_with_path(seedPhrase, undefined, transferKeyPath, currentNetwork);
            
            // Create public key objects for the SDK
            // Pass private keys so the SDK can derive the correct public key data using DPP
            // Use the selected key type for all keys
            publicKeys = [
              {
                id: 0,
                keyType: selectedKeyType,
                purpose: "AUTHENTICATION",
                securityLevel: "MASTER",
                privateKeyHex: masterKey.private_key_hex,
                readOnly: false
              },
              {
                id: 1,
                keyType: selectedKeyType,
                purpose: "AUTHENTICATION",
                securityLevel: "HIGH",
                privateKeyHex: authKey.private_key_hex,
                readOnly: false
              },
              {
                id: 2,
                keyType: selectedKeyType,
                purpose: "TRANSFER",
                securityLevel: "CRITICAL",
                privateKeyHex: transferKey.private_key_hex,
                readOnly: false
              }
            ];
          } else {
            throw new Error('Advanced key selection mode not yet implemented');
          }
          
          // Handle identity create with asset lock proof
          result = await sdk.identityCreate(
            assetLockProof,
            privateKey,
            JSON.stringify(publicKeys)
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Identity created successfully', 'success', startTime);
        } else if (transitionType === 'identityTopUp') {
          // Handle identity top up with asset lock proof
          const identityIdToTopUp = values.identityId;
          if (!identityIdToTopUp) {
            throw new Error('Identity ID is required for top up');
          }
          
          result = await sdk.identityTopUp(
            identityIdToTopUp,
            assetLockProof,
            privateKey
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Identity topped up successfully', 'success', startTime);
        } else if (transitionType === 'tokenMint') {
          result = await sdk.tokenMint(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId,
            privateKey,
            values.issuedToIdentityId || null,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token mint executed successfully', 'success', startTime);
        } else if (transitionType === 'tokenBurn') {
          result = await sdk.tokenBurn(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId,
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token burn executed successfully', 'success', startTime);
        } else if (transitionType === 'tokenClaim') {
          result = await sdk.tokenClaim(
            values.contractId,
            Number(values.tokenPosition),
            values.distributionType,
            identityId,
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token claim executed successfully', 'success', startTime);
        } else if (transitionType === 'tokenSetPriceForDirectPurchase') {
          result = await sdk.tokenSetPriceForDirectPurchase(
            values.contractId,
            Number(values.tokenPosition),
            identityId,
            values.priceType,
            values.priceData || '',
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token price updated successfully', 'success', startTime);
        } else if (transitionType === 'tokenDirectPurchase') {
          result = await sdk.tokenDirectPurchase(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId,
            values.totalAgreedPrice || null,  // Pass null if not provided
            privateKey
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token purchase executed successfully', 'success', startTime);
        } else if (transitionType === 'tokenConfigUpdate') {
          result = await sdk.tokenConfigUpdate(
            values.contractId,
            Number(values.tokenPosition),
            values.configItemType,
            values.configValue,
            identityId,
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Token configuration updated successfully', 'success', startTime);
        } else if (transitionType === 'tokenTransfer') {
          result = await sdk.tokenTransfer(
            values.contractId,
            Number(values.tokenPosition),
            values.amount,
            identityId, // sender ID
            values.recipientId,
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Tokens transferred successfully', 'success', startTime);
        } else if (transitionType === 'tokenFreeze') {
          result = await sdk.tokenFreeze(
            values.contractId,
            Number(values.tokenPosition),
            values.identityToFreeze,
            identityId, // freezer ID
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Tokens frozen successfully', 'success', startTime);
        } else if (transitionType === 'tokenUnfreeze') {
          result = await sdk.tokenUnfreeze(
            values.contractId,
            Number(values.tokenPosition),
            values.identityToUnfreeze,
            identityId, // unfreezer ID
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Tokens unfrozen successfully', 'success', startTime);
        } else if (transitionType === 'tokenDestroyFrozen') {
          result = await sdk.tokenDestroyFrozen(
            values.contractId,
            Number(values.tokenPosition),
            values.frozenIdentityId, // identity whose frozen tokens to destroy
            identityId, // destroyer ID
            privateKey,
            values.publicNote || null
          );
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('Frozen tokens destroyed successfully', 'success', startTime);
        } else if (transitionType === 'documentCreate') {
          // Collect document fields from dynamic inputs
          const documentData = collectDocumentFields();
          
          // Generate entropy (32 bytes)
          const entropy = new Uint8Array(32);
          crypto.getRandomValues(entropy);
          const entropyHex = Array.from(entropy)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
          
          // Create the document using the SDK
          result = await sdk.documentCreate(
            values.contractId,
            values.documentType,
            identityId,
            JSON.stringify(documentData),
            entropyHex,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document created successfully', 'success', startTime);
        } else if (transitionType === 'documentReplace') {
          // Collect document fields from dynamic inputs
          const documentData = collectDocumentFields();
          
          // Ensure we have the loaded revision
          if (loadedDocumentRevision === null) {
            throw new Error('No document loaded. Please click "Load Document" first.');
          }
          
          // Handle document replace
          result = await sdk.documentReplace(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            JSON.stringify(documentData),
            BigInt(loadedDocumentRevision),
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document replaced successfully', 'success', startTime);
          
          // Reset loaded data
          loadedDocumentData = null;
          loadedDocumentRevision = null;
        } else if (transitionType === 'documentDelete') {
          // Handle document delete
          result = await sdk.documentDelete(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document deleted successfully', 'success', startTime);
        } else if (transitionType === 'documentTransfer') {
          // Handle document transfer
          result = await sdk.documentTransfer(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            values.recipientId,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document transferred successfully', 'success', startTime);
        } else if (transitionType === 'documentSetPrice') {
          // Handle document set price
          result = await sdk.documentSetPrice(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            BigInt(values.price || 0), // price in credits, 0 to remove price
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document price set successfully', 'success', startTime);
        } else if (transitionType === 'dpnsRegister') {
          // Handle DPNS registration
          // First validate the username
          const isValid = dpns_is_valid_username(values.label);
          
          if (!isValid) {
            displayResult(JSON.stringify({
              label: values.label,
              valid: false,
              message: "❌ Invalid username format",
              requirements: [
                "Must be 3-63 characters long",
                "Must start and end with a letter or number",
                "Can only contain letters, numbers, and hyphens",
                "Cannot have consecutive hyphens"
              ]
            }, null, 2));
            updateStatus('Invalid username format', 'error');
            return;
          }
          
          // Check if name is available
          const isAvailable = await dpns_is_name_available(sdk, values.label);
          if (!isAvailable) {
            displayResult(JSON.stringify({
              label: values.label,
              available: false,
              message: `❌ Username "${values.label}" is already taken`
            }, null, 2));
            updateStatus('Username already taken', 'error');
            return;
          }
          
          // Fetch identity to get the key ID
          const identity = await identity_fetch(sdk, identityId);
          const identityJSON = identity.toJSON();
          
          console.log('Identity public keys:', identityJSON.publicKeys);
          
          // We need to derive the public key from the private key to find the matching key ID
          // For now, we'll prompt the user to specify the key ID since we can't easily derive
          // the public key from WIF in JavaScript without additional crypto libraries
          
          // Check if the private key has a key ID suffix (format: privateKey:keyId)
          let keyId = null;
          let actualPrivateKey = privateKey;
          
          if (privateKey.includes(':')) {
            const parts = privateKey.split(':');
            actualPrivateKey = parts[0];
            keyId = parseInt(parts[1]);
            
            // Verify the key exists and has the right security level
            const publicKey = identityJSON.publicKeys.find(key => key.id === keyId);
            if (!publicKey) {
              throw new Error(`Key ID ${keyId} not found in identity`);
            }
            if (publicKey.disabledAt) {
              throw new Error(`Key ID ${keyId} is disabled`);
            }
            // Check security level - MASTER=0, CRITICAL=1, HIGH=2
            console.log(`Key ${keyId} has security level: ${publicKey.securityLevel}`);
            if (publicKey.securityLevel === 0) {
              throw new Error(`Key ID ${keyId} has MASTER security level. DPNS requires CRITICAL (1) or HIGH (2) security level.`);
            }
          } else {
            // If no key ID provided, try to find the first suitable key
            const suitableKey = identityJSON.publicKeys.find(key => 
              !key.disabledAt && key.securityLevel !== 0  // Not MASTER
            );
            
            if (suitableKey) {
              keyId = suitableKey.id;
              const levelName = suitableKey.securityLevel === 1 ? 'CRITICAL' : 'HIGH';
              console.log(`No key ID specified. Using key ${keyId} with ${levelName} security level. For explicit control, use format: privateKey:keyId`);
            } else {
              throw new Error('No suitable keys found. DPNS requires CRITICAL or HIGH security level. Specify key ID using format: privateKey:keyId');
            }
          }
          
          console.log(`Using key ID ${keyId} for DPNS registration`);
          
          // Show initial status
          updateStatus('Submitting DPNS preorder document...', 'info');
          
          // Add a small delay to let the status message show
          await new Promise(resolve => setTimeout(resolve, 100));
          
          result = await dpns_register_name(
            sdk,
            values.label,
            identityId,       // Use the identity ID from authentication
            keyId,            // Use the determined key ID
            actualPrivateKey, // Use the actual private key (without :keyId suffix)
            // Callback for preorder success
            (preorderInfo) => {
              console.log('Preorder successful:', preorderInfo);
              updateStatus('Preorder successful! Now submitting domain document...', 'info');
              
              // Show preorder info in a temporary notification
              const preorderMsg = `Preorder Document ID: ${preorderInfo.documentId}`;
              const notification = document.createElement('div');
              notification.className = 'preorder-notification';
              notification.style.cssText = 'background: #4CAF50; color: white; padding: 10px; margin: 10px 0; border-radius: 4px;';
              notification.textContent = preorderMsg;
              
              const resultsSection = document.getElementById('results');
              if (resultsSection) {
                resultsSection.insertBefore(notification, resultsSection.firstChild);
                // Remove notification after 5 seconds
                setTimeout(() => notification.remove(), 5000);
              }
            }
          );
          
          // Since our callback is called at the end, let's update the message
          // to reflect that both documents were submitted
          displayResult(JSON.stringify(result, null, 2));
          updateStatusWithTime('DPNS name registered successfully! Both preorder and domain documents submitted.', 'success', startTime);
        } else if (transitionType === 'documentPurchase') {
          // Handle document purchase
          result = await sdk.documentPurchase(
            values.contractId,
            values.documentType,
            values.documentId,
            identityId,
            BigInt(values.price),
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Document purchased successfully', 'success', startTime);
        } else if (transitionType === 'identityCreditTransfer') {
          // Handle identity credit transfer
          result = await sdk.identityCreditTransfer(
            identityId, // sender is the authenticated identity
            values.recipientId,
            BigInt(values.amount),
            privateKey,
            null // key_id - will auto-select
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Credits transferred successfully', 'success', startTime);
        } else if (transitionType === 'identityCreditWithdrawal') {
          // Handle identity credit withdrawal
          result = await sdk.identityCreditWithdrawal(
            identityId,
            values.toAddress,
            BigInt(values.amount),
            values.coreFeePerByte ? Number(values.coreFeePerByte) : null,
            privateKey,
            null // key_id - will auto-select
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Credits withdrawn successfully', 'success', startTime);
        } else if (transitionType === 'identityUpdate') {
          // Handle identity update
          
          // Parse disable public keys
          let disableKeys = null;
          if (values.disablePublicKeys) {
            disableKeys = values.disablePublicKeys.split(',')
              .map(id => parseInt(id.trim()))
              .filter(id => !isNaN(id));
          }
          
          result = await sdk.identityUpdate(
            identityId,
            values.addPublicKeys || null, // JSON string
            disableKeys,
            privateKey
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Identity updated successfully', 'success', startTime);
        } else if (transitionType === 'dpnsUsername') {
          // Handle DPNS Username vote (simplified version of masternode vote)
          
          // Fixed DPNS contract ID
          const dpnsContractId = 'GWRSAVFMjXx8HpQFaNJMqBV7MBgMK4br5UESsB4S31Ec';
          
          // Build index values from username: ["dash", username]
          const indexValues = ["dash", values.contestedUsername];
          
          // Prepare vote choice
          let voteChoice = values.voteChoice;
          if (voteChoice === 'towardsIdentity' && values.targetIdentity) {
            voteChoice = `towardsIdentity:${values.targetIdentity}`;
          } else if (voteChoice === 'towardsIdentity' && !values.targetIdentity) {
            throw new Error('Target identity ID is required when voting for an identity');
          }
          
          result = await sdk.masternodeVote(
            identityId, // This is the masternode ProTxHash
            dpnsContractId,
            'domain', // DPNS document type
            'parentNameAndLabel', // DPNS index name
            JSON.stringify(indexValues),
            voteChoice,
            privateKey // This is the voting key
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('DPNS username vote submitted successfully', 'success', startTime);
        } else if (transitionType === 'masternodeVote') {
          // Handle masternode vote
          
          // Get the selected contested resource from the dropdown
          const selectedResource = values.contestedResource;
          if (!selectedResource) {
            throw new Error('Please select a contested resource');
          }
          
          // Parse the selected resource data
          const resourceData = JSON.parse(selectedResource);
          
          // Get the index values from the separate input
          const indexValuesInput = document.querySelector('textarea[name="indexValues"]');
          let indexValues = [];
          if (indexValuesInput && indexValuesInput.value) {
            try {
              indexValues = JSON.parse(indexValuesInput.value);
            } catch (e) {
              throw new Error('Invalid JSON in index values: ' + e.message);
            }
          }
          
          if (indexValues.length === 0) {
            throw new Error('Please provide index values for the contested resource');
          }
          
          // Prepare vote choice
          let voteChoice = values.voteChoice;
          if (voteChoice === 'towardsIdentity' && values.targetIdentity) {
            voteChoice = `towardsIdentity:${values.targetIdentity}`;
          } else if (voteChoice === 'towardsIdentity' && !values.targetIdentity) {
            throw new Error('Target identity ID is required when voting for an identity');
          }
          
          result = await sdk.masternodeVote(
            identityId, // This is the masternode ProTxHash
            resourceData.contractId,
            resourceData.documentType,
            resourceData.indexName,
            JSON.stringify(indexValues),
            voteChoice,
            privateKey // This is the voting key
          );
          
          // Pass the result object directly to displayResult
          displayResult(result);
          updateStatusWithTime('Vote submitted successfully', 'success', startTime);
        } else if (transitionType === 'dataContractCreate') {
          // Get document schemas JSON
          const schemasTextarea = document.querySelector('textarea[name="documentSchemas"]');
          if (!schemasTextarea || !schemasTextarea.value) {
            throw new Error('Document Schemas JSON is required');
          }
          
          let documentSchemas;
          try {
            documentSchemas = JSON.parse(schemasTextarea.value);
          } catch (e) {
            throw new Error(`Invalid JSON in Document Schemas field: ${e.message}`);
          }
          
          // Get optional JSON fields
          let groups = {};
          let tokens = {};
          
          const groupsTextarea = document.querySelector('textarea[name="groups"]');
          if (groupsTextarea && groupsTextarea.value) {
            try {
              groups = JSON.parse(groupsTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in Groups field: ${e.message}`);
            }
          }
          
          const tokensTextarea = document.querySelector('textarea[name="tokens"]');
          if (tokensTextarea && tokensTextarea.value) {
            try {
              tokens = JSON.parse(tokensTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in Tokens field: ${e.message}`);
            }
          }
          
          // Get keywords
          const keywords = values.keywords ? values.keywords.split(',').map(k => k.trim()).filter(k => k) : [];
          
          // Build the contract object
          const contractData = {
            "$format_version": "1",
            "id": "11111111111111111111111111111111", // Will be replaced by SDK
            "config": {
              "$format_version": "1",
              "canBeDeleted": values.canBeDeleted || false,
              "readonly": values.readonly || false,
              "keepsHistory": values.keepsHistory || false,
              "documentsKeepHistoryContractDefault": values.documentsKeepHistoryContractDefault || false,
              "documentsMutableContractDefault": values.documentsMutableContractDefault !== false, // Default true
              "documentsCanBeDeletedContractDefault": values.documentsCanBeDeletedContractDefault !== false, // Default true
              "requiresIdentityEncryptionBoundedKey": values.requiresIdentityEncryptionBoundedKey || null,
              "requiresIdentityDecryptionBoundedKey": values.requiresIdentityDecryptionBoundedKey || null,
              "sizedIntegerTypes": true
            },
            "version": 1,
            "ownerId": identityId,
            "schemaDefs": null,
            "documentSchemas": documentSchemas,
            "createdAt": null,
            "updatedAt": null,
            "createdAtBlockHeight": null,
            "updatedAtBlockHeight": null,
            "createdAtEpoch": null,
            "updatedAtEpoch": null,
            "groups": groups,
            "tokens": tokens,
            "keywords": keywords,
            "description": values.description || null
          };
          
          result = await sdk.contractCreate(
            identityId,
            JSON.stringify(contractData),
            privateKey,
            null  // Let SDK auto-detect the key
          );
          
          displayResult(result);
          updateStatusWithTime('Data contract created successfully', 'success', startTime);
        } else if (transitionType === 'dataContractUpdate') {
          // First fetch the existing contract
          updateStatus(`Fetching contract ${values.dataContractId}...`, 'loading');
          
          let existingContract;
          try {
            const contractWasm = await data_contract_fetch(sdk, values.dataContractId);
            // Convert to JSON to work with it - the method is toJSON not to_json
            const contractJson = await contractWasm.toJSON();
            existingContract = contractJson;
          } catch (e) {
            throw new Error(`Failed to fetch contract: ${e.message || e}`);
          }
          
          // Parse new schemas, groups, and tokens if provided
          let newSchemas = {};
          let newGroups = {};
          let newTokens = {};
          
          const newSchemasTextarea = document.querySelector('textarea[name="newDocumentSchemas"]');
          if (newSchemasTextarea && newSchemasTextarea.value) {
            try {
              newSchemas = JSON.parse(newSchemasTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Document Schemas field: ${e.message}`);
            }
          }
          
          const newGroupsTextarea = document.querySelector('textarea[name="newGroups"]');
          if (newGroupsTextarea && newGroupsTextarea.value) {
            try {
              newGroups = JSON.parse(newGroupsTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Groups field: ${e.message}`);
            }
          }
          
          const newTokensTextarea = document.querySelector('textarea[name="newTokens"]');
          if (newTokensTextarea && newTokensTextarea.value) {
            try {
              newTokens = JSON.parse(newTokensTextarea.value);
            } catch (e) {
              throw new Error(`Invalid JSON in New Tokens field: ${e.message}`);
            }
          }
          
          // Check if anything is being added
          if (Object.keys(newSchemas).length === 0 && 
              Object.keys(newGroups).length === 0 && 
              Object.keys(newTokens).length === 0) {
            throw new Error('No changes specified. Please add at least one new document schema, group, or token.');
          }
          
          // Merge new items with existing contract
          const updatedContract = {
            ...existingContract,
            version: existingContract.version + 1,
            ownerId: identityId,
            documentSchemas: {
              ...existingContract.documentSchemas,
              ...newSchemas
            },
            groups: {
              ...existingContract.groups,
              ...newGroups
            },
            tokens: {
              ...existingContract.tokens,
              ...newTokens
            }
          };
          
          // Show what's being added
          const additions = [];
          if (Object.keys(newSchemas).length > 0) {
            additions.push(`${Object.keys(newSchemas).length} document type(s)`);
          }
          if (Object.keys(newGroups).length > 0) {
            additions.push(`${Object.keys(newGroups).length} group(s)`);
          }
          if (Object.keys(newTokens).length > 0) {
            additions.push(`${Object.keys(newTokens).length} token(s)`);
          }
          
          updateStatus(`Adding ${additions.join(', ')} to contract...`, 'loading');
          
          result = await sdk.contractUpdate(
            values.dataContractId,
            identityId,
            JSON.stringify(updatedContract),
            privateKey,
            null  // Let SDK auto-detect the key
          );
          
          displayResult(result);
          updateStatusWithTime('Data contract updated successfully', 'success', startTime);
        } else {
          // For other transitions not yet implemented
          const transitionData = {
            type: transitionType,
            category: category,
            identityId: identityId,
            privateKey: '***hidden***',
            inputs: values
          };
          
          displayResult(JSON.stringify(transitionData, null, 2));
          updateStatus(`${transitionType} state transition not yet implemented in WASM SDK`, 'warning');
        }
        
      } catch (error) {
        console.error(`Error executing ${transitionType}:`, error);
        displayResult(`Error executing state transition: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }

    async function executeWalletOperation(category, operationType) {
      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;
      button.disabled = true;
      button.textContent = 'Processing...';
      
      const startTime = performance.now();
      
      try {
        const values = getInputValues();
        let result;
        
        updateStatus(`Executing ${operationType}...`, 'loading');
        
        switch (operationType) {
          case 'generateKeyPair':
            result = await generate_key_pair(currentNetwork);
            displayResult(JSON.stringify(result, null, 2));
            updateStatusWithTime('Key pair generated successfully', 'success', startTime);
            break;
            
          case 'generateKeyPairs':
            result = await generate_key_pairs(currentNetwork, values.count);
            displayResult(JSON.stringify(result, null, 2));
            updateStatusWithTime(`${values.count} key pairs generated successfully`, 'success', startTime);
            break;
            
          case 'keyPairFromWif':
            result = await key_pair_from_wif(values.privateKeyWif);
            displayResult(JSON.stringify(result, null, 2));
            updateStatusWithTime('Key pair imported from WIF successfully', 'success', startTime);
            break;
            
          case 'keyPairFromHex':
            result = await key_pair_from_hex(values.privateKeyHex, currentNetwork);
            displayResult(JSON.stringify(result, null, 2));
            updateStatusWithTime('Key pair imported from hex successfully', 'success', startTime);
            break;
            
          case 'pubkeyToAddress':
            result = await pubkey_to_address(values.pubkeyHex, currentNetwork);
            displayResult(result);
            updateStatusWithTime('Address generated successfully', 'success', startTime);
            break;
            
          case 'validateAddress':
            result = await validate_address(values.address, currentNetwork);
            displayResult(result ? 'Valid address' : 'Invalid address');
            updateStatusWithTime(`Address validation completed: ${result ? 'valid' : 'invalid'}`, result ? 'success' : 'warning', startTime);
            break;
            
          case 'signMessage':
            result = await sign_message(values.message, values.privateKeyWif);
            displayResult(result);
            updateStatusWithTime('Message signed successfully', 'success', startTime);
            break;
            
          case 'derivationPathBip44':
            // This now derives from seed
            if (!values.seedPhrase) {
              throw new Error('Seed phrase is required');
            }
            
            // Derive key from seed phrase
            result = await derive_key_from_seed_phrase(values.seedPhrase, values.passphrase || undefined, currentNetwork);
            
            // Add derivation path info to result
            const changeValue = values.change ? 1 : 0;
            const pathInfo = {
              ...result,
              derivationPath: `m/44'/${currentNetwork === 'mainnet' ? '5' : '1'}'/${values.account}'/${changeValue}/${values.index}`,
              account: values.account,
              change: changeValue,
              index: values.index
            };
            
            displayResult(JSON.stringify(pathInfo, null, 2));
            updateStatusWithTime('Key derived from seed phrase successfully', 'success', startTime);
            break;
            
          case 'enteredPath':
            // Derive key from custom path
            const pathStr = values.path.trim();
            const seedPhrase = values.seedPhrase.trim();
            
            if (!seedPhrase) {
              throw new Error('Please enter a seed phrase');
            }
            
            // Validate mnemonic
            if (!validate_mnemonic(seedPhrase)) {
              throw new Error('Invalid seed phrase');
            }
            
            try {
              // Check if the path contains identity IDs (hex or base58)
              const pathParts = pathStr.split('/');
              const hasIdentityIds = pathParts.some(part => {
                const cleanPart = part.replace(/['h]$/, ''); // Remove hardened markers
                // Check for hex (0x...) or base58 (long non-numeric strings)
                return cleanPart.startsWith('0x') || (cleanPart.length > 10 && !cleanPart.match(/^\d+$/));
              });
              
              if (hasIdentityIds) {
                // Use the extended path function that supports 256-bit identity IDs
                result = await derive_key_from_seed_with_extended_path(
                  seedPhrase,
                  values.passphrase || undefined,
                  pathStr,
                  currentNetwork
                );
              } else {
                // Use regular path function for standard BIP32 paths
                result = await derive_key_from_seed_with_path(
                  seedPhrase,
                  values.passphrase || undefined,
                  pathStr,
                  currentNetwork
                );
              }
              
              displayResult(JSON.stringify(result, null, 2));
              updateStatusWithTime(`Key derived for path ${pathStr}`, 'success', startTime);
            } catch (deriveError) {
              throw new Error(`Failed to derive key: ${deriveError.message}`);
            }
            break;
            
          case 'derivationPathDip13': {
            // DIP13 Identity key derivation
            const dip13SeedPhrase = values.seedPhrase.trim();
            
            if (!dip13SeedPhrase) {
              throw new Error('Please enter a seed phrase');
            }
            
            // Validate mnemonic
            if (!validate_mnemonic(dip13SeedPhrase)) {
              throw new Error('Invalid seed phrase');
            }
            
            // Build DIP13 path based on sub-feature
            // m / 9' / coin_type' / 5' / sub_feature' / ...
            const coinType = currentNetwork === 'mainnet' ? 5 : 1;
            const subFeature = parseInt(values.subFeature);
            let dip13Path;
            
            switch (subFeature) {
              case 0: // Authentication keys
                // m / 9' / coin_type' / 5' / 0' / key_type' / identity_index' / key_index'
                // For now, we'll use ECDSA (0') as key type
                const keyType = 0; // ECDSA
                dip13Path = `m/9'/${coinType}'/5'/0'/${keyType}'/${values.identityIndex}'/${values.keyIndex || 0}'`;
                break;
              case 1: // Registration Funding keys
                // m / 9' / coin_type' / 5' / 1' / identity_index
                dip13Path = `m/9'/${coinType}'/5'/1'/${values.identityIndex}`;
                break;
              case 2: // Top Up Funding keys
                // m / 9' / coin_type' / 5' / 2' / funding_index
                dip13Path = `m/9'/${coinType}'/5'/2'/${values.identityIndex}`;
                break;
              case 3: // Invitation Funding keys
                // m / 9' / coin_type' / 5' / 3' / funding_index'
                dip13Path = `m/9'/${coinType}'/5'/3'/${values.identityIndex}'`;
                break;
              default:
                throw new Error('Invalid sub-feature selected');
            }
            
            try {
              // Derive key using the constructed DIP13 path
              console.log('Calling derive_key_from_seed_with_path with:', {
                seedPhrase: dip13SeedPhrase.substring(0, 20) + '...',
                passphrase: values.passphrase ? 'provided' : 'none',
                path: dip13Path,
                network: currentNetwork
              });
              
              const rawResult = derive_key_from_seed_with_path(
                dip13SeedPhrase,
                values.passphrase || undefined,
                dip13Path,
                currentNetwork
              );
              
              console.log('Raw result (before await):', rawResult);
              
              result = await rawResult;
              
              // Debug: log what we actually received
              console.log('DIP13 derive_key_from_seed_with_path result (after await):', result);
              console.log('Result type:', typeof result);
              console.log('Result keys:', result ? Object.keys(result) : 'null');
              
              // If result is still not right, let's try to display it as is first
              if (!result) {
                throw new Error('derive_key_from_seed_with_path returned null/undefined');
              }
              
              // Create a combined result with both key info and DIP13 info
              const dip13KeyType = ['Authentication', 'Registration Funding', 'Top Up Funding', 'Invitation Funding'][subFeature];
              
              // Try to display the raw result first to see what we have
              console.log('Attempting to display raw result first...');
              displayResult(JSON.stringify(result, null, 2));
              
              // Now let's try to add DIP13 info
              setTimeout(() => {
                try {
                  const enrichedResult = {
                    ...result,
                    dip13Info: {
                      keyType: dip13KeyType,
                      identityIndex: values.identityIndex,
                      keyIndex: subFeature === 0 ? (values.keyIndex || 0) : undefined,
                      purpose: "DIP13 - Identities in HD Wallets"
                    }
                  };
                  
                  console.log('Enriched result:', enrichedResult);
                  displayResult(JSON.stringify(enrichedResult, null, 2));
                  updateStatusWithTime(`DIP13 ${dip13KeyType} key derived for identity ${values.identityIndex}`, 'success', startTime);
                } catch (enrichError) {
                  console.error('Error enriching result:', enrichError);
                }
              }, 100);
            } catch (deriveError) {
              throw new Error(`Failed to derive DIP13 key: ${deriveError.message}`);
            }
            break;
          }
            
          case 'dashpayPath': {
            // DIP15 DashPay contact key derivation
            const dashpaySeedPhrase = values.seedPhrase.trim();
            
            if (!dashpaySeedPhrase) {
              throw new Error('Please enter a seed phrase');
            }
            
            // Validate mnemonic
            if (!validate_mnemonic(dashpaySeedPhrase)) {
              throw new Error('Invalid seed phrase');
            }
            
            // Get values
            const senderIdentity = values.senderIdentity.trim();
            const receiverIdentity = values.receiverIdentity.trim();
            const account = parseInt(values.account) || 0;
            const addressIndex = parseInt(values.addressIndex) || 0;
            
            if (!senderIdentity || !receiverIdentity) {
              throw new Error('Both sender and receiver identity IDs are required');
            }
            
            try {
              // Use the new derive_dashpay_contact_key function that supports 256-bit identity IDs
              const result = await derive_dashpay_contact_key(
                dashpaySeedPhrase,
                values.passphrase || undefined,
                senderIdentity,
                receiverIdentity,
                account,
                addressIndex,
                currentNetwork
              );
              
              // The result already includes DIP15 metadata
              displayResult(JSON.stringify(result, null, 2));
              updateStatusWithTime(`DashPay contact key derived for ${receiverIdentity.substring(0, 8)}...`, 'success', startTime);
            } catch (deriveError) {
              throw new Error(`Failed to derive DashPay key: ${deriveError.message}`);
            }
            break;
          }
            
          case 'generateSeed':
            // Generate mnemonic based on word count and language
            const wordCount = parseInt(values.wordCount, 10) || 12;
            const language = values.language || undefined;
            try {
              const mnemonic = await generate_mnemonic(wordCount, language);
              const result = {
                mnemonic: mnemonic,
                wordCount: wordCount,
                language: language || 'en',
                warning: '⚠️ This is a cryptographically secure seed phrase. Store it safely and never share it!'
              };
              displayResult(JSON.stringify(result, null, 2));
              updateStatusWithTime(`${wordCount}-word seed phrase generated successfully`, 'success', startTime);
            } catch (error) {
              throw new Error(`Failed to generate seed: ${error.message || error}`);
            }
            break;
            
          default:
            displayResult(`Wallet operation ${operationType} not implemented`, true);
            updateStatus(`Wallet operation ${operationType} not implemented`, 'error');
        }
        
      } catch (error) {
        console.error(`Error executing wallet operation ${operationType}:`, error);
        displayResult(`Error: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }

    // Event handlers
    document.getElementById('operationType').addEventListener('change', (e) => {
      const operationType = e.target.value;
      const categorySelect = document.getElementById('queryCategory');
      const authInputs = document.getElementById('authenticationInputs');
      
      // Clear category
      categorySelect.innerHTML = '<option value="">Select Category</option>';
      
      // Show/hide auth inputs
      authInputs.style.display = operationType === 'transitions' ? 'block' : 'none';
      
      // Reset authentication input visibility to defaults
      const identityIdGroup = document.getElementById('identityIdGroup');
      const assetLockProofGroup = document.getElementById('assetLockProofGroup');
      if (identityIdGroup) {
        identityIdGroup.style.display = 'block';
      }
      if (assetLockProofGroup) {
        assetLockProofGroup.style.display = 'none';
      }
      
      if (operationType === 'queries') {
        // Populate query categories
        Object.entries(queryDefinitions).forEach(([key, category]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = category.label;
          categorySelect.appendChild(option);
        });
      } else if (operationType === 'transitions') {
        // Populate transition categories
        Object.entries(stateTransitionDefinitions).forEach(([key, category]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = category.label;
          categorySelect.appendChild(option);
        });
      } else if (operationType === 'wallet') {
        // Populate wallet categories
        Object.entries(walletDefinitions).forEach(([key, category]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = category.label;
          categorySelect.appendChild(option);
        });
      }
      
      // Reset the rest
      document.getElementById('queryType').innerHTML = '<option value="">Select Type</option>';
      document.getElementById('queryType').style.display = 'none';
      document.getElementById('queryInputs').style.display = 'none';
      document.getElementById('proofToggleContainer').style.display = 'none';
      document.getElementById('noProofInfoContainer').style.display = 'none';
      document.getElementById('executeQuery').style.display = 'none';
      document.getElementById('queryDescription').style.display = 'none';
    });
    
    document.getElementById('queryCategory').addEventListener('change', (e) => {
      const category = e.target.value;
      const operationType = document.getElementById('operationType').value;
      const queryTypeSelect = document.getElementById('queryType');
      const queryInputs = document.getElementById('queryInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear query type
      queryTypeSelect.innerHTML = '<option value="">Select Type</option>';
      queryTypeSelect.style.display = category ? 'block' : 'none';
      
      // Hide inputs and button
      queryInputs.style.display = 'none';
      document.getElementById('proofToggleContainer').style.display = 'none';
      document.getElementById('noProofInfoContainer').style.display = 'none';
      executeButton.style.display = 'none';
      queryDescription.style.display = 'none';
      
      if (operationType === 'queries' && category && queryDefinitions[category] && queryDefinitions[category].queries) {
        // Populate query types
        Object.entries(queryDefinitions[category].queries).forEach(([key, query]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = query.label;
          queryTypeSelect.appendChild(option);
        });
      } else if (operationType === 'transitions' && category && stateTransitionDefinitions[category] && stateTransitionDefinitions[category].transitions) {
        // Populate transition types
        Object.entries(stateTransitionDefinitions[category].transitions).forEach(([key, transition]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = transition.label;
          
          
          queryTypeSelect.appendChild(option);
        });
      } else if (operationType === 'wallet' && category && walletDefinitions[category]) {
        // Populate wallet operation types
        Object.entries(walletDefinitions[category].operations).forEach(([key, operation]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = operation.label;
          queryTypeSelect.appendChild(option);
        });
      }
    });

    document.getElementById('queryType').addEventListener('change', (e) => {
      const queryType = e.target.value;
      const category = document.getElementById('queryCategory').value;
      const operationType = document.getElementById('operationType').value;
      const queryInputs = document.getElementById('queryInputs');
      const dynamicInputs = document.getElementById('dynamicInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryTitle = document.getElementById('queryTitle');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear existing inputs
      dynamicInputs.innerHTML = '';
      
      // Clear authentication inputs to prevent stale data
      const identityIdInput = document.getElementById('identityId');
      const assetLockProofInput = document.getElementById('assetLockProof');
      const privateKeyInput = document.getElementById('privateKey');
      if (identityIdInput) identityIdInput.value = '';
      if (assetLockProofInput) assetLockProofInput.value = '';
      if (privateKeyInput) privateKeyInput.value = '';
      
      let definition;
      if (operationType === 'queries' && queryType && category && queryDefinitions[category]?.queries[queryType]) {
        definition = queryDefinitions[category].queries[queryType];
      } else if (operationType === 'transitions' && queryType && category && stateTransitionDefinitions[category]?.transitions[queryType]) {
        definition = stateTransitionDefinitions[category].transitions[queryType];
      } else if (operationType === 'wallet' && queryType && category && walletDefinitions[category]?.operations[queryType]) {
        definition = walletDefinitions[category].operations[queryType];
      }
      
      if (definition) {
        queryTitle.textContent = definition.label;
        
        // Show description
        if (definition.description) {
          queryDescription.textContent = definition.description;
          queryDescription.style.display = 'block';
        } else {
          queryDescription.style.display = 'none';
        }
        
        // Create inputs
        definition.inputs.forEach(inputDef => {
          createInput(inputDef, dynamicInputs);
        });
        
        // Setup dependency handlers
        dynamicInputs.querySelectorAll('select, input[type="checkbox"]').forEach(input => {
          input.addEventListener('change', () => {
            dynamicInputs.querySelectorAll('[data-depends-on]').forEach(dependent => {
              const dependsOn = dependent.dataset.dependsOn;
              const dependsOnValues = dependent.dataset.dependsOnValue.split(',');
              const currentValue = dynamicInputs.querySelector(`[name="${dependsOn}"]`)?.value;
              
              if (dependsOnValues.includes(currentValue)) {
                dependent.style.display = 'block';
              } else {
                dependent.style.display = 'none';
              }
            });
            
          });
        });
        
        // Special handling for identity create - update key preview
        if (operationType === 'transitions' && queryType === 'identityCreate') {
          const updateKeyPreview = () => {
            const seedPhrase = dynamicInputs.querySelector('[name="seedPhrase"]')?.value?.trim();
            const identityIndex = parseInt(dynamicInputs.querySelector('[name="identityIndex"]')?.value || '0');
            const keySelectionMode = dynamicInputs.querySelector('[name="keySelectionMode"]')?.value || 'default';
            const selectedKeyType = dynamicInputs.querySelector('[name="keyType"]')?.value || 'ECDSA_HASH160';
            const previewContainer = document.getElementById('keyPreviewContainer');
            
            if (!seedPhrase || !previewContainer) return;
            
            try {
              // Validate seed phrase
              if (!validate_mnemonic(seedPhrase)) {
                previewContainer.innerHTML = '<p style="color: #dc3545;">Invalid seed phrase</p>';
                return;
              }
              
              // Generate keys based on selection mode
              let keysHtml = '<h4 style="margin-top: 0;">Keys to be created:</h4>';
              
              if (keySelectionMode === 'default') {
                // Master key (authentication, master level)
                const masterKeyPath = `m/9'/${currentNetwork === 'mainnet' ? 5 : 1}'/5'/0'/0'/${identityIndex}'/0'`;
                const masterKey = derive_key_from_seed_with_path(seedPhrase, undefined, masterKeyPath, currentNetwork);
                
                // Additional authentication key (high security)
                const authKeyPath = `m/9'/${currentNetwork === 'mainnet' ? 5 : 1}'/5'/0'/0'/${identityIndex}'/1'`;
                const authKey = derive_key_from_seed_with_path(seedPhrase, undefined, authKeyPath, currentNetwork);
                
                // Transfer key (critical security)
                const transferKeyPath = `m/9'/${currentNetwork === 'mainnet' ? 5 : 1}'/5'/0'/0'/${identityIndex}'/2'`;
                const transferKey = derive_key_from_seed_with_path(seedPhrase, undefined, transferKeyPath, currentNetwork);
                
                // Show signature requirement info
                const signatureInfo = selectedKeyType === 'ECDSA_SECP256K1' 
                  ? ' (Individual signatures required)' 
                  : ' (No individual signatures required)';
                
                keysHtml += `
                  <div style="margin-bottom: 10px;">
                    <strong>Master Key:</strong><br>
                    <span style="font-family: monospace; font-size: 0.9em;">${masterKey.private_key_wif}</span><br>
                    <span style="color: #6c757d; font-size: 0.85em;">Purpose: Authentication | Security: Master | Type: ${selectedKeyType}${signatureInfo}</span>
                  </div>
                  <div style="margin-bottom: 10px;">
                    <strong>Key 1:</strong><br>
                    <span style="font-family: monospace; font-size: 0.9em;">${authKey.private_key_wif}</span><br>
                    <span style="color: #6c757d; font-size: 0.85em;">Purpose: Authentication | Security: High | Type: ${selectedKeyType}${signatureInfo}</span>
                  </div>
                  <div style="margin-bottom: 10px;">
                    <strong>Key 2:</strong><br>
                    <span style="font-family: monospace; font-size: 0.9em;">${transferKey.private_key_wif}</span><br>
                    <span style="color: #6c757d; font-size: 0.85em;">Purpose: Transfer | Security: Critical | Type: ${selectedKeyType}${signatureInfo}</span>
                  </div>
                `;
                
                keysHtml += '<p style="color: #28a745; margin-top: 10px;">✓ Default key set allows for most Platform operations</p>';
              } else {
                keysHtml += '<p style="color: #6c757d;">Advanced mode: You will need to manually specify keys (not yet implemented)</p>';
              }
              
              previewContainer.innerHTML = keysHtml;
            } catch (error) {
              previewContainer.innerHTML = DOMPurify.sanitize(`<p style="color: #dc3545;">Error generating keys: ${error.message}</p>`);
            }
          };
          
          // Add event listeners for relevant inputs
          const seedInput = dynamicInputs.querySelector('[name="seedPhrase"]');
          const indexInput = dynamicInputs.querySelector('[name="identityIndex"]');
          const modeSelect = dynamicInputs.querySelector('[name="keySelectionMode"]');
          const keyTypeSelect = dynamicInputs.querySelector('[name="keyType"]');
          
          if (seedInput) seedInput.addEventListener('input', updateKeyPreview);
          if (indexInput) indexInput.addEventListener('input', updateKeyPreview);
          if (modeSelect) modeSelect.addEventListener('change', updateKeyPreview);
          if (keyTypeSelect) keyTypeSelect.addEventListener('change', updateKeyPreview);
          
          // Initial update
          updateKeyPreview();
        }
        
        queryInputs.style.display = 'block';
        executeButton.style.display = 'block';
        
        // Show proof toggle for queries that support proofs
        const proofToggleContainer = document.getElementById('proofToggleContainer');
        const noProofInfoContainer = document.getElementById('noProofInfoContainer');
        if (operationType === 'queries') {
          // Check if query supports proof (defaults to true if not specified)
          const supportsProof = definition?.supportsProof !== false;
          if (supportsProof) {
            proofToggleContainer.style.display = 'block';
            noProofInfoContainer.style.display = 'none';
          } else {
            proofToggleContainer.style.display = 'none';
            noProofInfoContainer.style.display = 'block';
          }
        } else {
          proofToggleContainer.style.display = 'none';
          noProofInfoContainer.style.display = 'none';
        }
        
        // Update button text based on operation type
        if (operationType === 'transitions') {
          executeButton.textContent = 'Execute';
        } else if (operationType === 'wallet') {
          executeButton.textContent = 'View';
        } else {
          executeButton.textContent = 'Execute Query';
        }
        
        // Update authentication labels based on transition type
        if (operationType === 'transitions' && (queryType === 'masternodeVote' || queryType === 'dpnsUsername')) {
          const identityIdLabel = document.querySelector('#authenticationInputs label[for="identityId"]');
          const privateKeyLabel = document.querySelector('#authenticationInputs label[for="privateKey"]');
          const identityIdInput = document.getElementById('identityId');
          const privateKeyInput = document.getElementById('privateKey');
          
          if (identityIdLabel) {
            identityIdLabel.textContent = 'ProTxHash (hex or Base58)';
          }
          if (privateKeyLabel) {
            privateKeyLabel.textContent = 'Voting Private Key (WIF or hex)';
          }
          if (identityIdInput) {
            identityIdInput.placeholder = 'Enter your masternode ProTxHash';
          }
          if (privateKeyInput) {
            privateKeyInput.placeholder = 'Enter your voting private key (WIF or 32-byte hex)';
          }
        } else if (operationType === 'transitions' && (queryType === 'identityCreate' || queryType === 'identityTopUp')) {
          // For Identity Create and Top Up, show asset lock proof field instead of identity ID
          const identityIdGroup = document.getElementById('identityIdGroup');
          const assetLockProofGroup = document.getElementById('assetLockProofGroup');
          const privateKeyLabel = document.querySelector('#authenticationInputs label[for="privateKey"]');
          const privateKeyInput = document.getElementById('privateKey');
          
          // Hide identity ID and show asset lock proof
          if (identityIdGroup) {
            identityIdGroup.style.display = 'none';
          }
          if (assetLockProofGroup) {
            assetLockProofGroup.style.display = 'block';
          }
          
          if (privateKeyLabel) {
            privateKeyLabel.textContent = 'Asset Lock Proof Private Key (WIF)';
          }
          if (privateKeyInput) {
            privateKeyInput.placeholder = 'Enter the private key used in the asset lock';
          }
        } else if (operationType === 'transitions') {
          // Reset to default labels for other transitions
          const identityIdGroup = document.getElementById('identityIdGroup');
          const assetLockProofGroup = document.getElementById('assetLockProofGroup');
          const identityIdLabel = document.querySelector('#authenticationInputs label[for="identityId"]');
          const privateKeyLabel = document.querySelector('#authenticationInputs label[for="privateKey"]');
          const identityIdInput = document.getElementById('identityId');
          const privateKeyInput = document.getElementById('privateKey');
          
          // Show identity ID and hide asset lock proof
          if (identityIdGroup) {
            identityIdGroup.style.display = 'block';
          }
          if (assetLockProofGroup) {
            assetLockProofGroup.style.display = 'none';
          }
          
          if (identityIdLabel) {
            identityIdLabel.textContent = 'Identity ID';
          }
          if (privateKeyLabel) {
            privateKeyLabel.textContent = 'Private Key (WIF or hex)';
          }
          if (identityIdInput) {
            identityIdInput.placeholder = 'Enter identity ID';
          }
          if (privateKeyInput) {
            privateKeyInput.placeholder = 'Enter private key (WIF or 32-byte hex)';
          }
        }
      } else {
        queryInputs.style.display = 'none';
        document.getElementById('proofToggleContainer').style.display = 'none';
        document.getElementById('noProofInfoContainer').style.display = 'none';
        executeButton.style.display = 'none';
        queryDescription.style.display = 'none';
      }
    });

    document.getElementById('executeQuery').addEventListener('click', async () => {
      const operationType = document.getElementById('operationType').value;
      const category = document.getElementById('queryCategory').value;
      const queryType = document.getElementById('queryType').value;
      
      if (operationType === 'queries') {
        await executeQuery(category, queryType);
      } else if (operationType === 'transitions') {
        await executeStateTransition(category, queryType);
      } else if (operationType === 'wallet') {
        await executeWalletOperation(category, queryType);
      }
    });

    // Network toggle handlers
    document.querySelectorAll('input[name="network"]').forEach(radio => {
      radio.addEventListener('change', async (event) => {
        const network = event.target.value;
        const indicator = document.getElementById('networkIndicator');
        
        indicator.textContent = network.toUpperCase();
        indicator.className = `network-indicator ${network}`;
        
        // Save network preference to localStorage
        localStorage.setItem('wasm-sdk-network', network);
        
        clearResults();
        await initializeSdk(network);
      });
    });

    // Trusted mode is always on, no need for event listener
    
    // Apply Configuration button handler
    document.getElementById('applyConfig').addEventListener('click', async () => {
      const network = document.querySelector('input[name="network"]:checked')?.value || 'mainnet';
      clearResults();
      updateStatus('Applying new SDK configuration...', 'loading');
      await initializeSdk(network);
    });

    // Store loaded document data globally for document replace
    let loadedDocumentData = null;
    let loadedDocumentRevision = null;

    // Load existing document for replacement
    window.loadExistingDocument = async function() {
      const contractIdInput = document.querySelector('input[name="contractId"]');
      const documentTypeInput = document.querySelector('input[name="documentType"]');
      const documentIdInput = document.querySelector('input[name="documentId"]');
      
      const contractId = contractIdInput?.value;
      const documentType = documentTypeInput?.value;
      const documentId = documentIdInput?.value;
      
      if (!contractId || !documentType || !documentId) {
        updateStatus('Please fill in Contract ID, Document Type, and Document ID', 'error');
        return;
      }
      
      // Start timing
      const startTime = performance.now();
      
      try {
        updateStatus('Loading document and schema...', 'loading');
        
        // First fetch the document
        const documentResult = await get_document(sdk, contractId, documentType, documentId);
        
        if (!documentResult) {
          throw new Error('Document not found');
        }
        
        // Store document data and revision
        loadedDocumentData = documentResult.data || {};
        loadedDocumentRevision = documentResult.revision || 0;
        
        console.log('Loaded document:', documentResult);
        
        // Now fetch the data contract to get schema
        const dataContract = await data_contract_fetch(sdk, contractId);
        const contractData = dataContract.toJSON();
        
        // Find the document type schema
        const docType = contractData.documentSchemas?.[documentType];
        if (!docType) {
          const availableTypes = Object.keys(contractData.documentSchemas || {});
          const availableTypesStr = availableTypes.length > 0 
            ? `Available document types: ${availableTypes.join(', ')}` 
            : 'No document types found in contract';
          throw new Error(`Document type '${documentType}' not found in contract. ${availableTypesStr}`);
        }
        
        // Show the document fields container
        const fieldsContainer = document.getElementById('dynamic_documentFields');
        if (fieldsContainer) {
          fieldsContainer.parentElement.style.display = 'block';
          
          // Populate document fields with existing data
          populateDocumentFields(docType, fieldsContainer, loadedDocumentData);
        }
        
        updateStatusWithTime(`Document loaded successfully (revision: ${loadedDocumentRevision})`, 'success', startTime);
      } catch (error) {
        console.error('Error loading document:', error);
        updateStatus(`Error loading document: ${error.message}`, 'error');
      }
    };

    // Fetch document schema and generate dynamic fields
    window.fetchDocumentSchema = async function() {
      const contractId = document.querySelector('input[name="contractId"]')?.value;
      const documentType = document.querySelector('input[name="documentType"]')?.value;
      
      if (!contractId || !documentType) {
        updateStatus('Please enter both Data Contract ID and Document Type', 'error');
        return;
      }
      
      try {
        updateStatus('Fetching data contract...', 'loading');
        
        // Fetch the data contract
        const contract = await data_contract_fetch(sdk, contractId);
        if (!contract) {
          updateStatus('Data contract not found', 'error');
          return;
        }
        
        // Get the document schema
        const contractJson = contract.toJSON();
        const documentSchema = contractJson.documentSchemas?.[documentType];
        
        if (!documentSchema) {
          const availableTypes = Object.keys(contractJson.documentSchemas || {});
          const availableTypesStr = availableTypes.length > 0 
            ? `Available document types: ${availableTypes.join(', ')}` 
            : 'No document types found in contract';
          updateStatus(`Document type '${documentType}' not found in contract. ${availableTypesStr}`, 'error');
          return;
        }
        
        // Generate dynamic fields
        generateDocumentFields(documentSchema);
        updateStatus(`Schema loaded for ${documentType}`, 'success');
        
      } catch (error) {
        console.error('Error fetching schema:', error);
        updateStatus(`Error: ${error.message || error}`, 'error');
      }
    };
    
    // Fetch contested resources from a contract
    window.fetchContestedResources = async function() {
      const contractId = document.querySelector('input[name="contractId"]')?.value;
      
      if (!contractId) {
        updateStatus('Please enter a Data Contract ID', 'error');
        return;
      }
      
      try {
        updateStatus('Fetching data contract and contested resources...', 'loading');
        
        // First fetch the data contract to identify contested document types
        const contract = await data_contract_fetch(sdk, contractId);
        if (!contract) {
          updateStatus('Data contract not found', 'error');
          return;
        }
        
        const contractJson = contract.toJSON();
        const documentSchemas = contractJson.documentSchemas || {};
        
        // Find document types with contested unique indexes
        const contestedResources = [];
        
        for (const [documentType, schema] of Object.entries(documentSchemas)) {
          const indexes = schema.indices || [];
          
          for (const index of indexes) {
            // Check if this is a contested unique index
            // contested can be either true or an object with contest rules
            if (index.unique && index.contested) {
              const indexName = index.name;
              const indexProperties = index.properties || [];
              
              // Get contest description if available
              let description = '';
              if (typeof index.contested === 'object' && index.contested.description) {
                description = ` - ${index.contested.description}`;
              }
              
              contestedResources.push({
                contractId: contractId,
                documentType: documentType,
                indexName: indexName,
                indexProperties: indexProperties,
                contestedRules: index.contested,
                displayName: `${documentType} - ${indexName}${description}`
              });
            }
          }
        }
        
        // Populate the dropdown
        const container = document.getElementById('dynamic_contestedResourceDropdown');
        if (!container) {
          console.error('Contested resource dropdown container not found');
          return;
        }
        
        container.parentElement.style.display = 'block';
        container.innerHTML = '';
        
        if (contestedResources.length === 0) {
          const noResourcesMsg = document.createElement('p');
          noResourcesMsg.textContent = 'No contested resources found in this contract';
          noResourcesMsg.style.color = '#666';
          container.appendChild(noResourcesMsg);
          updateStatus('No contested resources found', 'warning');
          return;
        }
        
        // Create dropdown
        const selectGroup = document.createElement('div');
        selectGroup.className = 'input-group';
        
        const label = document.createElement('label');
        label.textContent = 'Select Contested Resource:';
        label.style.display = 'block';
        label.style.marginBottom = '5px';
        selectGroup.appendChild(label);
        
        const select = document.createElement('select');
        select.name = 'contestedResource';
        select.style.width = '100%';
        select.style.marginBottom = '10px';
        
        // Add placeholder option
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = '-- Select a contested resource --';
        select.appendChild(placeholderOption);
        
        // Add contested resources
        contestedResources.forEach(resource => {
          const option = document.createElement('option');
          option.value = JSON.stringify({
            contractId: resource.contractId,
            documentType: resource.documentType,
            indexName: resource.indexName,
            indexValues: [] // This will need to be filled by the user
          });
          option.textContent = resource.displayName;
          select.appendChild(option);
        });
        
        selectGroup.appendChild(select);
        container.appendChild(selectGroup);
        
        // Add index values input when a resource is selected
        select.addEventListener('change', (e) => {
          const existingValuesInput = container.querySelector('.index-values-group');
          if (existingValuesInput) {
            existingValuesInput.remove();
          }
          
          if (e.target.value) {
            const resource = JSON.parse(e.target.value);
            const valuesGroup = document.createElement('div');
            valuesGroup.className = 'input-group index-values-group';
            valuesGroup.style.marginTop = '10px';
            
            const valuesLabel = document.createElement('label');
            valuesLabel.textContent = 'Index Values (JSON array):';
            valuesLabel.style.display = 'block';
            valuesLabel.style.marginBottom = '5px';
            valuesGroup.appendChild(valuesLabel);
            
            const valuesInput = document.createElement('textarea');
            valuesInput.name = 'indexValues';
            valuesInput.placeholder = 'e.g., ["dash", "username"]';
            valuesInput.rows = 2;
            valuesInput.style.width = '100%';
            valuesInput.dataset.json = 'true';
            
            // Store the index values without modifying the select value
            valuesInput.dataset.resourceData = select.value;
            
            valuesGroup.appendChild(valuesInput);
            container.appendChild(valuesGroup);
          }
        });
        
        updateStatus(`Found ${contestedResources.length} contested resource type(s)`, 'success');
        
      } catch (error) {
        console.error('Error fetching contested resources:', error);
        updateStatus(`Error: ${error.message || error}`, 'error');
      }
    };
    
    function generateDocumentFields(schema) {
      const container = document.getElementById('dynamic_documentFields');
      if (!container) return;
      
      // Clear existing fields
      // Show the container
      container.parentElement.style.display = 'block';
      
      // Use the shared function
      populateDocumentFields(schema, container);
    }
    
    // Shared function to populate document fields
    function populateDocumentFields(schema, container, existingData = null) {
      // Clear existing fields
      container.innerHTML = '';
      
      // Add header
      const header = document.createElement('h4');
      header.textContent = 'Document Fields';
      header.style.marginBottom = '10px';
      container.appendChild(header);
      
      // Generate fields based on schema properties
      const properties = schema.properties || {};
      const required = schema.required || [];
      
      Object.entries(properties).forEach(([fieldName, fieldSchema]) => {
        const fieldGroup = document.createElement('div');
        fieldGroup.className = 'input-group';
        fieldGroup.style.marginBottom = '10px';
        
        const label = document.createElement('label');
        const isRequired = required.includes(fieldName);
        label.textContent = `${fieldName}${isRequired ? ' *' : ' (optional)'}`;
        label.style.display = 'block';
        label.style.marginBottom = '5px';
        label.style.fontWeight = isRequired ? 'bold' : 'normal';
        fieldGroup.appendChild(label);
        
        // Create appropriate input based on field type
        const input = createInputForField(fieldName, fieldSchema);
        
        // Populate with existing data if available
        if (existingData && existingData[fieldName] !== undefined) {
          const value = existingData[fieldName];
          
          if (input.type === 'checkbox') {
            input.checked = value;
          } else if (input.type === 'datetime-local' && typeof value === 'number') {
            // Convert timestamp to datetime-local format
            const date = new Date(value);
            input.value = date.toISOString().slice(0, 16);
          } else if (input.tagName === 'TEXTAREA' && (fieldSchema.type === 'array' || fieldSchema.type === 'object')) {
            // Convert arrays/objects to JSON string
            input.value = JSON.stringify(value, null, 2);
          } else {
            input.value = value;
          }
        }
        
        fieldGroup.appendChild(input);
        
        // Add description if available
        if (fieldSchema.description) {
          const desc = document.createElement('small');
          desc.textContent = fieldSchema.description;
          desc.style.display = 'block';
          desc.style.color = '#666';
          desc.style.marginTop = '2px';
          fieldGroup.appendChild(desc);
        }
        
        container.appendChild(fieldGroup);
      });
    }
    
    function createInputForField(fieldName, fieldSchema) {
      const fieldType = fieldSchema.type;
      const format = fieldSchema.format;
      
      let input;
      
      if (fieldType === 'string') {
        if (format === 'date-time') {
          input = document.createElement('input');
          input.type = 'datetime-local';
        } else if (fieldSchema.maxLength && fieldSchema.maxLength > 100) {
          input = document.createElement('textarea');
          input.rows = 4;
          input.style.width = '100%';
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }
        
        if (fieldSchema.maxLength) {
          input.maxLength = fieldSchema.maxLength;
        }
        if (fieldSchema.minLength) {
          input.minLength = fieldSchema.minLength;
        }
        if (fieldSchema.pattern) {
          input.pattern = fieldSchema.pattern;
        }
      } else if (fieldType === 'integer' || fieldType === 'number') {
        input = document.createElement('input');
        input.type = 'number';
        
        if (fieldSchema.minimum !== undefined) {
          input.min = fieldSchema.minimum;
        }
        if (fieldSchema.maximum !== undefined) {
          input.max = fieldSchema.maximum;
        }
        if (fieldType === 'integer') {
          input.step = '1';
        }
      } else if (fieldType === 'boolean') {
        input = document.createElement('input');
        input.type = 'checkbox';
      } else if (fieldType === 'array') {
        // Check if it's a byte array (identifier)
        if (fieldSchema.byteArray === true) {
          input = document.createElement('input');
          input.type = 'text';
          input.placeholder = fieldSchema.description || 'Enter identifier (base58)';
        } else {
          input = document.createElement('textarea');
          input.placeholder = fieldSchema.description || 'Enter array values';
          input.rows = 3;
          input.style.width = '100%';
        }
      } else if (fieldType === 'object') {
        input = document.createElement('textarea');
        input.placeholder = fieldSchema.description || 'Enter object data';
        input.rows = 4;
        input.style.width = '100%';
      } else {
        // Default to text input
        input = document.createElement('input');
        input.type = 'text';
      }
      
      input.name = `doc_field_${fieldName}`;
      input.dataset.fieldName = fieldName;
      input.dataset.fieldType = fieldType;
      if (fieldSchema.byteArray === true) {
        input.dataset.byteArray = 'true';
      }
      
      if (fieldSchema.default !== undefined) {
        if (fieldType === 'boolean') {
          input.checked = fieldSchema.default;
        } else {
          input.value = typeof fieldSchema.default === 'object' 
            ? JSON.stringify(fieldSchema.default) 
            : fieldSchema.default;
        }
      }
      
      return input;
    }
    
    // Collect document fields for submission
    function collectDocumentFields() {
      const container = document.getElementById('dynamic_documentFields');
      if (!container) return {};
      
      const fields = {};
      const inputs = container.querySelectorAll('input, textarea');
      
      inputs.forEach(input => {
        const fieldName = input.dataset.fieldName;
        const fieldType = input.dataset.fieldType;
        
        if (!fieldName) return;
        
        let value;
        
        if (input.type === 'checkbox') {
          value = input.checked;
        } else if (fieldType === 'integer' || fieldType === 'number') {
          value = input.value ? parseFloat(input.value) : undefined;
          if (fieldType === 'integer' && value !== undefined) {
            value = Math.floor(value);
          }
        } else if (fieldType === 'array') {
          // Check if it's a byte array (identifier)
          if (input.dataset.byteArray === 'true') {
            // For byte arrays, we need to convert the base58 string to bytes
            // For now, just pass the string - the SDK will handle conversion
            value = input.value || undefined;
          } else {
            try {
              value = input.value ? JSON.parse(input.value) : undefined;
            } catch (e) {
              console.error(`Invalid JSON for field ${fieldName}:`, e);
              value = undefined;
            }
          }
        } else if (fieldType === 'object') {
          try {
            value = input.value ? JSON.parse(input.value) : undefined;
          } catch (e) {
            console.error(`Invalid JSON for field ${fieldName}:`, e);
            value = undefined;
          }
        } else if (input.type === 'datetime-local' && input.value) {
          // Convert to Unix timestamp in milliseconds
          value = new Date(input.value).getTime();
        } else {
          value = input.value || undefined;
        }
        
        if (value !== undefined) {
          fields[fieldName] = value;
        }
      });
      
      return fields;
    }

    // Progress tracking for WASM loading
    function updateProgress(percent, text) {
      const progressFill = document.getElementById('progressFill');
      const progressPercent = document.getElementById('progressPercent');
      const preloaderText = document.querySelector('.preloader-text');
      
      if (progressFill) progressFill.style.width = percent + '%';
      if (progressPercent) progressPercent.textContent = percent + '%';
      if (preloaderText && text) preloaderText.textContent = text;
    }

    // Initialize UI after API definitions are loaded
    function initializeUI() {
      console.log('Initializing UI with loaded API definitions');
      console.log(`Available: ${Object.keys(queryDefinitions).length} query categories, ${Object.keys(stateTransitionDefinitions).length} transition categories`);
      
      // Initialize with queries selected to populate dropdowns
      document.getElementById('operationType').dispatchEvent(new Event('change'));
      console.log('UI initialization complete');
    }

    // Initialize
    async function run() {
      try {
        // Load API definitions FIRST (before any UI elements are shown)
        updateStatus('Loading API definitions...', 'loading');
        const apiLoadSuccess = await tryLoadApiDefinitions();
        if (!apiLoadSuccess) {
          updateStatus('Failed to load API definitions', 'error');
          return;
        }
        
        // Now show the preloader and start WASM initialization
        updateStatus('Initializing SDK...', 'loading');
        const preloader = document.getElementById('preloader');
        preloader.style.display = 'block';
        
        // Initialize UI after API definitions are loaded
        updateProgress(2, 'Initializing UI...');
        initializeUI();
        
        updateStatus('Loading WASM module...', 'loading');
        
        // Start with initial progress
        updateProgress(5, 'Downloading WASM module...');
        
        const initStart = performance.now();
        
        try {
          // First, fetch the WASM file with progress tracking
          const wasmUrl = './pkg/wasm_sdk_bg.wasm';
          const response = await fetch(wasmUrl);
          
          if (!response.ok) {
            throw new Error(`Failed to fetch WASM: ${response.status} ${response.statusText}`);
          }
          
          const contentLength = response.headers.get('content-length');
          let wasmBytes;
          
          if (contentLength) {
            // We have content length, can show accurate progress
            const total = parseInt(contentLength, 10);
            let loaded = 0;
            
            const reader = response.body.getReader();
            const chunks = [];
            
            while (true) {
              const { done, value } = await reader.read();
              
              if (done) break;
              
              chunks.push(value);
              loaded += value.byteLength;
              
              const percentComplete = Math.round((loaded / total) * 85); // 0-85% for download
              updateProgress(5 + percentComplete, `Downloading WASM module... ${(loaded / 1024 / 1024).toFixed(1)}MB / ${(total / 1024 / 1024).toFixed(1)}MB`);
            }
            
            // Combine all chunks into a single array
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            wasmBytes = new Uint8Array(totalLength);
            let position = 0;
            for (const chunk of chunks) {
              wasmBytes.set(chunk, position);
              position += chunk.length;
            }
          } else {
            // No content length, just download without accurate progress
            updateProgress(50, 'Downloading WASM module...');
            wasmBytes = new Uint8Array(await response.arrayBuffer());
          }
          
          updateProgress(92, 'Compiling WASM module...');
          
          // Initialize with the downloaded bytes
          await init(wasmBytes);
          
          updateProgress(98, 'WASM module loaded, initializing SDK...');
        } catch (error) {
          throw error;
        }
        
        const initEnd = performance.now();
        console.log(`[Performance] WASM init took ${(initEnd - initStart).toFixed(2)}ms`);
        
        updateStatus('WASM module loaded, initializing SDK...', 'loading');
        
        // Load saved network preference or default to mainnet
        const savedNetwork = localStorage.getItem('wasm-sdk-network') || 'mainnet';
        
        // Update the radio button to match saved preference
        const networkRadio = document.getElementById(savedNetwork);
        if (networkRadio) {
          networkRadio.checked = true;
          
          // Update the network indicator
          const indicator = document.getElementById('networkIndicator');
          indicator.textContent = savedNetwork.toUpperCase();
          indicator.className = `network-indicator ${savedNetwork}`;
        }
        
        await initializeSdk(savedNetwork);
        
        // Complete the progress
        updateProgress(100, 'Ready!');
        setTimeout(() => {
          preloader.style.display = 'none';
        }, 500);
        
      } catch (error) {
        console.error('Failed to initialize WASM:', error);
        updateStatus(`Failed to load WASM module: ${error.message || error}`, 'error');
        
        // Hide preloader on error
        const preloader = document.getElementById('preloader');
        if (preloader) preloader.style.display = 'none';
      }
    }

    // Set up retry button event listener
    document.getElementById('apiRetryButton').addEventListener('click', async function() {
      this.disabled = true;
      this.textContent = 'Retrying...';
      
      updateStatus('Loading API definitions...', 'loading');
      const success = await tryLoadApiDefinitions();
      
      if (success) {
        // API definitions loaded successfully, restart the app initialization
        run();
      } else {
        // Still failed, re-enable the button
        this.disabled = false;
        this.textContent = 'Retry';
      }
    });

    run();
  </script>
</body>

</html>