<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f5f5;
    }

    #preloader {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 5px;
      z-index: 1000;
    }

    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .sidebar {
      width: 450px;
      background-color: white;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .network-toggle {
      padding: 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
    }

    .network-toggle label {
      margin-right: 15px;
      font-weight: 500;
      color: #333;
    }

    .network-indicator {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 3px;
      margin-left: 10px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .network-indicator.testnet {
      background-color: #ff9800;
      color: white;
    }

    .network-indicator.mainnet {
      background-color: #4caf50;
      color: white;
    }

    .query-container {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
    }

    .query-selector {
      margin-bottom: 20px;
    }

    .query-selector select {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
      margin-bottom: 10px;
    }

    .query-inputs {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .query-inputs h4 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 1em;
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-size: 0.9em;
    }

    .input-group input,
    .input-group select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }

    .input-group input[type="checkbox"] {
      width: auto;
      margin-right: 5px;
    }

    .input-group input[type="number"] {
      -moz-appearance: textfield;
    }

    .input-group input[type="number"]::-webkit-inner-spin-button,
    .input-group input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .optional-label {
      color: #888;
      font-size: 0.85em;
      font-style: italic;
    }

    .execute-button {
      width: 100%;
      padding: 12px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .execute-button:hover {
      background-color: #1565c0;
    }

    .execute-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .result-container {
      flex: 1;
      background-color: white;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .result-header {
      padding: 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .result-header h2 {
      margin: 0;
      color: #333;
      font-size: 1.3em;
    }

    .result-actions button {
      margin-left: 10px;
      padding: 8px 16px;
      border: 1px solid #ddd;
      background-color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .result-actions button:hover {
      background-color: #f5f5f5;
    }

    .result-content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .result-content.empty {
      color: #888;
      font-style: italic;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    }

    .status-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 10px 20px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
      z-index: 999;
      transition: all 0.3s ease;
    }

    .status-banner.success {
      background-color: #4caf50;
      color: white;
    }

    .status-banner.error {
      background-color: #f44336;
      color: white;
    }

    .status-banner.loading {
      background-color: #ff9800;
      color: white;
    }

    .error-result {
      color: #d32f2f;
      background-color: #ffebee;
      border: 1px solid #ffcdd2;
      border-radius: 4px;
      padding: 10px;
    }
    
    .credits-value {
      color: #1976d2;
      cursor: help;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 3px;
      position: relative;
    }
    
    .credits-value:hover {
      background-color: #e3f2fd;
      border-radius: 3px;
      padding: 0 2px;
    }
    
    .credits-value::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      margin-bottom: 5px;
      z-index: 1000;
    }
    
    .credits-value:hover::after {
      opacity: 1;
    }
    
    .json-key {
      color: #d73a49;
      font-weight: 500;
    }
    
    .result-content pre {
      margin: 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }

    .mode-selector {
      margin-bottom: 15px;
      display: none;
    }

    .array-input-container {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      background-color: #fafafa;
    }

    .array-item {
      display: flex;
      gap: 10px;
      margin-bottom: 5px;
    }

    .array-item input {
      flex: 1;
    }

    .array-item button {
      padding: 5px 10px;
      background-color: #ff5252;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .add-array-item {
      padding: 5px 15px;
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 5px;
    }

    .query-description {
      font-size: 0.85em;
      color: #666;
      margin-bottom: 15px;
      padding: 10px;
      background-color: #e3f2fd;
      border-radius: 4px;
      line-height: 1.4;
    }

    .action-button {
      padding: 8px 16px;
      background-color: #2196f3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }

    .action-button:hover {
      background-color: #1976d2;
    }

    .dynamic-fields-container {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fafafa;
    }

    .field-group {
      margin-bottom: 10px;
      padding: 8px;
      background-color: white;
      border-radius: 4px;
    }

    .field-group label {
      display: inline-block;
      width: 150px;
      font-weight: 500;
    }
  </style>
</head>

<body>
  <div id="preloader">Loading...</div>
  
  <div class="app-container">
    <div class="sidebar">
      <div class="network-toggle">
        <label>Network:</label>
        <input type="radio" id="mainnet" name="network" value="mainnet" checked>
        <label for="mainnet">Mainnet</label>
        <input type="radio" id="testnet" name="network" value="testnet">
        <label for="testnet">Testnet</label>
        <span id="networkIndicator" class="network-indicator mainnet">MAINNET</span>
        <br>
        <label style="margin-top: 10px; display: block;">
          <input type="checkbox" id="trustedMode" style="margin-right: 5px;" checked disabled>
          Trusted Quorums Mode
        </label>
      </div>
      
      <div class="query-container">
        <div class="query-selector">
          <select id="queryCategory">
            <option value="">Select Query Category</option>
            <option value="identity">Identity Queries</option>
            <option value="dataContract">Data Contract Queries</option>
            <option value="document">Document Queries</option>
            <option value="voting">Voting & Contested Resources</option>
            <option value="protocol">Protocol & Version</option>
            <option value="epoch">Epoch & Block</option>
            <option value="token">Token Queries</option>
            <option value="group">Group Queries</option>
            <option value="system">System & Utility</option>
          </select>
          
          <select id="queryType" style="display: none;">
            <option value="">Select Query Type</option>
          </select>
        </div>
        
        <div id="queryDescription" class="query-description" style="display: none;"></div>
        
        <div id="queryInputs" class="query-inputs" style="display: none;">
          <h4 id="queryTitle">Query Parameters</h4>
          <div id="dynamicInputs"></div>
        </div>
        
        <button id="executeQuery" class="execute-button" style="display: none;">Execute Query</button>
      </div>
    </div>
    
    <div class="result-container">
      <div class="result-header">
        <h2>Results</h2>
        <div class="result-actions">
          <button id="clearButton" onclick="clearResults()">Clear</button>
          <button id="copyButton" onclick="copyResults()">Copy</button>
        </div>
      </div>
      <div id="identityInfo" class="result-content empty">No data fetched yet. Select a query category and type to begin.</div>
    </div>
  </div>

  <div id="statusBanner" class="status-banner loading">Initializing WASM SDK...</div>

  <script type="module">
    import init, { 
      WasmSdkBuilder, 
      identity_fetch, 
      data_contract_fetch, 
      prefetch_trusted_quorums_mainnet, 
      prefetch_trusted_quorums_testnet,
      // Identity queries
      get_identity_keys,
      get_identity_nonce,
      get_identity_contract_nonce,
      get_identity_balance,
      get_identities_balances,
      get_identity_balance_and_revision,
      get_identity_by_public_key_hash,
      get_identities_contract_keys,
      get_identity_by_non_unique_public_key_hash,
      get_identity_token_balances,
      // Data contract queries
      get_data_contract_history,
      get_data_contracts,
      // Document queries
      get_documents,
      get_document,
      // Protocol/Version queries
      get_protocol_version_upgrade_state,
      get_protocol_version_upgrade_vote_status,
      // Epoch/Block queries
      get_epochs_info,
      get_finalized_epoch_infos,
      get_current_epoch,
      get_evonodes_proposed_epoch_blocks_by_ids,
      get_evonodes_proposed_epoch_blocks_by_range,
      // System/Utility queries
      get_status,
      get_total_credits_in_platform,
      get_current_quorums_info,
      get_prefunded_specialized_balance,
      get_path_elements,
      wait_for_state_transition_result,
      // Token queries
      get_identities_token_balances,
      get_identity_token_infos,
      get_identities_token_infos,
      get_token_statuses,
      get_token_direct_purchase_prices,
      get_token_contract_info,
      get_token_perpetual_distribution_last_claim,
      get_token_total_supply,
      // Voting/Contested Resource queries
      get_contested_resources,
      get_contested_resource_vote_state,
      get_contested_resource_voters_for_identity,
      get_contested_resource_identity_votes,
      get_vote_polls_by_end_date,
      // Group queries
      get_group_info,
      get_group_members,
      get_identity_groups,
      get_groups_data_contracts
    } from './pkg/wasm_sdk.js';
    
    // Import all placeholder query functions
    import * as queryFunctions from './pkg/wasm_sdk.js';

    let sdk = null;
    let currentResult = null;
    let initRequestCounter = 0;

    // Query definitions
    const queryDefinitions = {
      identity: {
        label: "Identity Queries",
        queries: {
          getIdentity: {
            label: "Get Identity",
            description: "Fetch an identity by its identifier",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityKeys: {
            label: "Get Identity Keys",
            description: "Retrieve keys associated with an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "keyRequestType", type: "select", label: "Key Request Type", required: true, 
                options: [
                  { value: "all", label: "All Keys" },
                  { value: "specific", label: "Specific Keys" },
                  { value: "search", label: "Search Keys" }
                ]
              },
              { name: "specificKeyIds", type: "array", label: "Key IDs (for Specific Keys)", required: false, 
                dependsOn: { field: "keyRequestType", value: "specific" } },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false }
            ]
          },
          getIdentitiesContractKeys: {
            label: "Get Identities Contract Keys",
            description: "Get keys for multiple identities related to a specific contract",
            inputs: [
              { name: "identitiesIds", type: "array", label: "Identity IDs", required: true },
              { name: "contractId", type: "text", label: "Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: false },
              { name: "purposes", type: "multiselect", label: "Key Purposes", required: false,
                options: [
                  { value: "0", label: "Authentication" },
                  { value: "1", label: "Encryption" },
                  { value: "2", label: "Decryption" },
                  { value: "3", label: "Transfer" },
                  { value: "5", label: "Voting" }
                ]
              }
            ]
          },
          getIdentityNonce: {
            label: "Get Identity Nonce",
            description: "Get the current nonce for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityContractNonce: {
            label: "Get Identity Contract Nonce",
            description: "Get the nonce for an identity in relation to a specific contract",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "contractId", type: "text", label: "Contract ID", required: true }
            ]
          },
          getIdentityBalance: {
            label: "Get Identity Balance",
            description: "Get the credit balance of an identity",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentitiesBalances: {
            label: "Get Identities Balances",
            description: "Get balances for multiple identities",
            inputs: [
              { name: "ids", type: "array", label: "Identity IDs", required: true }
            ]
          },
          getIdentityBalanceAndRevision: {
            label: "Get Identity Balance and Revision",
            description: "Get both balance and revision number for an identity",
            inputs: [
              { name: "id", type: "text", label: "Identity ID", required: true }
            ]
          },
          getIdentityByPublicKeyHash: {
            label: "Get Identity by Public Key Hash",
            description: "Find an identity by its unique public key hash",
            inputs: [
              { name: "publicKeyHash", type: "text", label: "Public Key Hash", required: true }
            ]
          },
          getIdentityByNonUniquePublicKeyHash: {
            label: "Get Identity by Non-Unique Public Key Hash",
            description: "Find identities by non-unique public key hash",
            inputs: [
              { name: "publicKeyHash", type: "text", label: "Public Key Hash", required: true },
              { name: "startAfter", type: "text", label: "Start After (Identity ID)", required: false }
            ]
          },
          getIdentityTokenBalances: {
            label: "Get Identity Token Balances",
            description: "Get token balances for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getIdentitiesTokenBalances: {
            label: "Get Identities Token Balances",
            description: "Get token balance for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          },
          getIdentityTokenInfos: {
            label: "Get Identity Token Info",
            description: "Get token information for an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "tokenIds", type: "array", label: "Token IDs (optional)", required: false },
              { name: "withPurchaseInfo", type: "checkbox", label: "Include Purchase Info", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false }
            ]
          },
          getIdentitiesTokenInfos: {
            label: "Get Identities Token Info",
            description: "Get token information for multiple identities",
            inputs: [
              { name: "identityIds", type: "array", label: "Identity IDs", required: true },
              { name: "tokenId", type: "text", label: "Token ID", required: true },
              { name: "withPurchaseInfo", type: "checkbox", label: "Include Purchase Info", required: false }
            ]
          }
        }
      },
      dataContract: {
        label: "Data Contract Queries",
        queries: {
          getDataContract: {
            label: "Get Data Contract",
            description: "Fetch a data contract by its identifier",
            inputs: [
              { name: "id", type: "text", label: "Data Contract ID", required: true }
            ]
          },
          getDataContractHistory: {
            label: "Get Data Contract History",
            description: "Get the version history of a data contract",
            inputs: [
              { name: "id", type: "text", label: "Data Contract ID", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "startAtMs", type: "number", label: "Start At (ms)", required: false }
            ]
          },
          getDataContracts: {
            label: "Get Data Contracts",
            description: "Fetch multiple data contracts by their identifiers",
            inputs: [
              { name: "ids", type: "array", label: "Data Contract IDs", required: true }
            ]
          }
        }
      },
      document: {
        label: "Document Queries",
        queries: {
          getDocuments: {
            label: "Get Documents",
            description: "Query documents from a data contract",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "loadContract", type: "button", label: "Load Contract", action: "loadDataContractForDocuments" },
              { name: "indexSelector", type: "select", label: "Select Index", required: false, dynamic: true },
              { name: "whereFields", type: "dynamic", label: "Where Fields", required: false },
              { name: "orderByFields", type: "dynamic", label: "Order By Fields", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "startOption", type: "select", label: "Start Option", required: false,
                options: [
                  { value: "none", label: "None" },
                  { value: "startAfter", label: "Start After" },
                  { value: "startAt", label: "Start At" }
                ]
              },
              { name: "startValue", type: "text", label: "Start Value (Document ID)", required: false,
                dependsOn: { field: "startOption", value: ["startAfter", "startAt"] } }
            ]
          },
          getDocument: {
            label: "Get Document",
            description: "Fetch a specific document by ID",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentType", type: "text", label: "Document Type", required: true },
              { name: "documentId", type: "text", label: "Document ID", required: true }
            ]
          }
        }
      },
      voting: {
        label: "Voting & Contested Resources",
        queries: {
          getContestedResources: {
            label: "Get Contested Resources",
            description: "Get list of contested resources",
            inputs: [
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "resultType", type: "select", label: "Result Type", required: true,
                options: [
                  { value: "documents", label: "Documents" },
                  { value: "vote_tally", label: "Vote Tally" },
                  { value: "document_with_vote_tally", label: "Document with Vote Tally" }
                ]
              },
              { name: "allowIncludeLockedAndAbstainingVoteTally", type: "checkbox", label: "Include Locked and Abstaining", required: false },
              { name: "startAtValue", type: "text", label: "Start At Value (hex bytes)", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceVoteState: {
            label: "Get Contested Resource Vote State",
            description: "Get the current vote state for a contested resource",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "resultType", type: "select", label: "Result Type", required: true,
                options: [
                  { value: "contenders", label: "Contenders" },
                  { value: "abstainers", label: "Abstainers" },
                  { value: "locked", label: "Locked" }
                ]
              },
              { name: "allowIncludeLockedAndAbstainingVoteTally", type: "checkbox", label: "Include Locked and Abstaining", required: false },
              { name: "startAtIdentifierInfo", type: "json", label: "Start At Identifier Info (JSON)", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceVotersForIdentity: {
            label: "Get Contested Resource Voters for Identity",
            description: "Get voters who voted for a specific identity in a contested resource",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true },
              { name: "documentTypeName", type: "text", label: "Document Type Name", required: true },
              { name: "indexName", type: "text", label: "Index Name", required: true },
              { name: "contestantId", type: "text", label: "Contestant ID", required: true },
              { name: "startAtIdentifierInfo", type: "json", label: "Start At Identifier Info (JSON)", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getContestedResourceIdentityVotes: {
            label: "Get Contested Resource Identity Votes",
            description: "Get all votes cast by a specific identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          },
          getVotePollsByEndDate: {
            label: "Get Vote Polls by End Date",
            description: "Get vote polls within a time range",
            inputs: [
              { name: "startTimeMs", type: "number", label: "Start Time (ms)", required: false },
              { name: "endTimeMs", type: "number", label: "End Time (ms)", required: false },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "offset", type: "number", label: "Offset", required: false },
              { name: "orderAscending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          }
        }
      },
      protocol: {
        label: "Protocol & Version",
        queries: {
          getProtocolVersionUpgradeState: {
            label: "Get Protocol Version Upgrade State",
            description: "Get the current state of protocol version upgrades",
            inputs: []
          },
          getProtocolVersionUpgradeVoteStatus: {
            label: "Get Protocol Version Upgrade Vote Status",
            description: "Get voting status for protocol version upgrades",
            inputs: [
              { name: "startProTxHash", type: "text", label: "Start ProTx Hash (optional - leave empty to start from beginning)", required: false },
              { name: "count", type: "number", label: "Count (default: 100)", required: false }
            ]
          }
        }
      },
      epoch: {
        label: "Epoch & Block",
        queries: {
          getEpochsInfo: {
            label: "Get Epochs Info",
            description: "Get information about epochs",
            inputs: [
              { name: "startEpoch", type: "number", label: "Start Epoch", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "ascending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          },
          getCurrentEpoch: {
            label: "Get Current Epoch",
            description: "Get information about the current epoch",
            inputs: []
          },
          getFinalizedEpochInfos: {
            label: "Get Finalized Epoch Info",
            description: "Get information about finalized epochs",
            inputs: [
              { name: "startEpoch", type: "number", label: "Start Epoch", required: false },
              { name: "count", type: "number", label: "Count", required: false },
              { name: "ascending", type: "checkbox", label: "Ascending Order", required: false }
            ]
          },
          getEvonodesProposedEpochBlocksByIds: {
            label: "Get Evonodes Proposed Epoch Blocks by IDs",
            description: "Get proposed blocks by evonode IDs",
            inputs: [
              { name: "epoch", type: "number", label: "Epoch", required: true },
              { name: "ids", type: "array", label: "Evonode IDs", required: true }
            ]
          },
          getEvonodesProposedEpochBlocksByRange: {
            label: "Get Evonodes Proposed Epoch Blocks by Range",
            description: "Get proposed blocks by range",
            inputs: [
              { name: "epoch", type: "number", label: "Epoch", required: true },
              { name: "limit", type: "number", label: "Limit", required: false },
              { name: "startAfter", type: "text", label: "Start After (Evonode ID)", required: false },
              { name: "orderAscending", type: "checkbox", label: "Order Ascending", required: false }
            ]
          }
        }
      },
      token: {
        label: "Token Queries",
        queries: {
          getTokenStatuses: {
            label: "Get Token Statuses",
            description: "Get pause/unpause status for tokens",
            inputs: [
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getTokenDirectPurchasePrices: {
            label: "Get Token Direct Purchase Prices",
            description: "Get direct purchase prices for tokens",
            inputs: [
              { name: "tokenIds", type: "array", label: "Token IDs", required: true }
            ]
          },
          getTokenContractInfo: {
            label: "Get Token Contract Info",
            description: "Get contract information for a token",
            inputs: [
              { name: "dataContractId", type: "text", label: "Data Contract ID", required: true }
            ]
          },
          getTokenPerpetualDistributionLastClaim: {
            label: "Get Token Perpetual Distribution Last Claim",
            description: "Get last claim information for token perpetual distribution",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "distributionId", type: "text", label: "Distribution ID", required: true }
            ]
          },
          getTokenTotalSupply: {
            label: "Get Token Total Supply",
            description: "Get total supply information for a token",
            inputs: [
              { name: "tokenId", type: "text", label: "Token ID", required: true }
            ]
          }
        }
      },
      group: {
        label: "Group Queries",
        queries: {
          getGroupInfo: {
            label: "Get Group Info",
            description: "Get information about a specific group",
            inputs: [
              { name: "groupContractId", type: "text", label: "Group Contract ID", required: true }
            ]
          },
          getGroupMembers: {
            label: "Get Group Members",
            description: "Get members of a specific group",
            inputs: [
              { name: "groupContractId", type: "text", label: "Group Contract ID", required: true },
              { name: "memberIds", type: "array", label: "Member IDs (optional)", required: false },
              { name: "startAt", type: "text", label: "Start At (Member ID)", required: false },
              { name: "limit", type: "number", label: "Limit", required: false }
            ]
          },
          getIdentityGroups: {
            label: "Get Identity Groups",
            description: "Get groups associated with an identity",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true },
              { name: "memberDataContracts", type: "array", label: "Member Data Contracts", required: false },
              { name: "ownerDataContracts", type: "array", label: "Owner Data Contracts", required: false },
              { name: "moderatorDataContracts", type: "array", label: "Moderator Data Contracts", required: false }
            ]
          },
          getGroupsDataContracts: {
            label: "Get Groups Data Contracts",
            description: "Get data contracts for multiple groups",
            inputs: [
              { name: "dataContractIds", type: "array", label: "Data Contract IDs", required: true }
            ]
          }
        }
      },
      system: {
        label: "System & Utility",
        queries: {
          getStatus: {
            label: "Get Status",
            description: "Get node and network status information",
            inputs: []
          },
          getCurrentQuorumsInfo: {
            label: "Get Current Quorums Info",
            description: "Get information about current quorums",
            inputs: []
          },
          getPrefundedSpecializedBalance: {
            label: "Get Prefunded Specialized Balance",
            description: "Get prefunded balance for specialized transactions",
            inputs: [
              { name: "identityId", type: "text", label: "Identity ID", required: true }
            ]
          },
          getTotalCreditsInPlatform: {
            label: "Get Total Credits in Platform",
            description: "Get the total amount of credits in the platform",
            inputs: []
          },
          getPathElements: {
            label: "Get Path Elements",
            description: "Get elements at specific paths in the state tree",
            inputs: [
              { name: "keys", type: "array", label: "Keys (hex strings)", required: true }
            ]
          },
          waitForStateTransitionResult: {
            label: "Wait for State Transition Result",
            description: "Wait for a state transition to be processed",
            inputs: [
              { name: "stateTransitionHash", type: "text", label: "State Transition Hash", required: true }
            ]
          }
        }
      }
    };

    // Helper functions for result actions
    window.clearResults = function() {
      const resultContent = document.getElementById('identityInfo');
      resultContent.textContent = 'No data fetched yet. Select a query category and type to begin.';
      resultContent.className = 'result-content empty';
      currentResult = null;
    };

    window.copyResults = function() {
      if (!currentResult) {
        alert('No results to copy');
        return;
      }
      navigator.clipboard.writeText(JSON.stringify(currentResult, null, 2))
        .then(() => {
          const copyButton = document.getElementById('copyButton');
          const originalText = copyButton.textContent;
          copyButton.textContent = 'Copied!';
          setTimeout(() => {
            copyButton.textContent = originalText;
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy:', err);
          alert('Failed to copy to clipboard');
        });
    };

    // Function to load data contract and populate index selector
    window.loadDataContractForDocuments = async function() {
      const contractIdInput = document.querySelector('input[name="dataContractId"]');
      const documentTypeInput = document.querySelector('input[name="documentType"]');
      
      if (!contractIdInput?.value || !documentTypeInput?.value) {
        alert('Please enter both Data Contract ID and Document Type');
        return;
      }

      const contractId = contractIdInput.value;
      const documentType = documentTypeInput.value;
      
      try {
        updateStatus('Loading data contract...', 'loading');
        
        // Fetch the data contract
        const dataContract = await data_contract_fetch(sdk, contractId);
        const contractData = dataContract.toJSON();
        
        // Find the document type
        // Note: The serialized format uses 'documentSchemas' while internal representation might use 'documentTypes'
        const docType = contractData.documentSchemas?.[documentType];
        if (!docType) {
          throw new Error(`Document type '${documentType}' not found in contract`);
        }

        // Extract indexes
        const indexes = docType.indices || [];
        
        // Populate index selector
        const indexSelector = document.querySelector('select[name="indexSelector"]');
        if (indexSelector) {
          // Clear existing options
          indexSelector.innerHTML = '<option value="">Select an index</option>';
          
          // Add index options
          indexes.forEach((index, idx) => {
            const option = document.createElement('option');
            option.value = idx;
            option.textContent = index.name || `Index ${idx}`;
            option.dataset.indexData = JSON.stringify(index);
            indexSelector.appendChild(option);
          });

          // Show the selector
          indexSelector.parentElement.style.display = 'block';
        }

        // Add index change handler
        indexSelector.addEventListener('change', function() {
          const selectedOption = this.options[this.selectedIndex];
          if (selectedOption.value && selectedOption.dataset.indexData) {
            const indexData = JSON.parse(selectedOption.dataset.indexData);
            populateIndexFields(indexData, docType);
          } else {
            clearIndexFields();
          }
        });

        updateStatus('Data contract loaded successfully', 'success');
      } catch (error) {
        console.error('Error loading data contract:', error);
        updateStatus(`Error loading data contract: ${error.message}`, 'error');
      }
    };

    // Function to populate where and order by fields based on selected index
    function populateIndexFields(index, docType) {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (!whereContainer || !orderByContainer) return;

      // Clear existing fields
      whereContainer.innerHTML = '<h5>Where Conditions</h5>';
      orderByContainer.innerHTML = '<h5>Order By</h5>';

      // Extract properties from index
      const indexProperties = index.properties || [];
      
      // Create where fields for each indexed property
      indexProperties.forEach(prop => {
        // Properties are objects like {"records.identity": "asc"}
        let propName;
        let sortOrder;
        
        if (typeof prop === 'object' && !Array.isArray(prop)) {
          // Extract the property name and sort order from the object
          const keys = Object.keys(prop);
          if (keys.length > 0) {
            propName = keys[0];
            sortOrder = prop[propName];
          }
        } else if (typeof prop === 'string') {
          propName = prop;
        } else {
          return; // Skip invalid properties
        }
        
        if (!propName) return;
        
        // Where field
        const whereGroup = document.createElement('div');
        whereGroup.className = 'field-group';
        
        const whereLabel = document.createElement('label');
        whereLabel.textContent = `${propName}:`;
        
        const whereInput = document.createElement('input');
        whereInput.type = 'text';
        whereInput.name = `where_${propName}`;
        whereInput.placeholder = `Filter by ${propName}`;
        
        whereGroup.appendChild(whereLabel);
        whereGroup.appendChild(whereInput);
        whereContainer.appendChild(whereGroup);

        // Order by field (only if the property has a sort order)
        if (sortOrder) {
          const orderGroup = document.createElement('div');
          orderGroup.className = 'field-group';
          
          const orderLabel = document.createElement('label');
          orderLabel.textContent = `Sort by ${propName}:`;
          
          const orderSelect = document.createElement('select');
          orderSelect.name = `orderBy_${propName}`;
          
          const noneOption = document.createElement('option');
          noneOption.value = '';
          noneOption.textContent = 'None';
          orderSelect.appendChild(noneOption);
          
          const ascOption = document.createElement('option');
          ascOption.value = 'asc';
          ascOption.textContent = 'Ascending';
          orderSelect.appendChild(ascOption);
          
          const descOption = document.createElement('option');
          descOption.value = 'desc';
          descOption.textContent = 'Descending';
          orderSelect.appendChild(descOption);
          
          orderGroup.appendChild(orderLabel);
          orderGroup.appendChild(orderSelect);
          orderByContainer.appendChild(orderGroup);
        }
      });

      // Show the containers
      whereContainer.parentElement.style.display = 'block';
      orderByContainer.parentElement.style.display = 'block';
    }

    // Function to clear index fields
    function clearIndexFields() {
      const whereContainer = document.getElementById('dynamic_whereFields');
      const orderByContainer = document.getElementById('dynamic_orderByFields');
      
      if (whereContainer) {
        whereContainer.innerHTML = '';
        whereContainer.parentElement.style.display = 'none';
      }
      
      if (orderByContainer) {
        orderByContainer.innerHTML = '';
        orderByContainer.parentElement.style.display = 'none';
      }
    }

    function displayResult(data, isError = false) {
      const resultContent = document.getElementById('identityInfo');
      if (isError) {
        resultContent.className = 'result-content error-result';
        resultContent.textContent = data;
        currentResult = null;
      } else {
        resultContent.className = 'result-content';
        // Use custom formatter for better display with credit tooltips
        resultContent.innerHTML = formatResultWithCredits(data);
        currentResult = data;
      }
    }
    
    function formatResultWithCredits(data) {
      const CREDITS_PER_DASH = 100000000000; // 100 billion credits = 1 Dash
      
      function formatCreditsValue(credits) {
        const creditsNum = BigInt(credits);
        const dashValue = Number(creditsNum) / CREDITS_PER_DASH;
        const dashFormatted = dashValue.toFixed(8).replace(/\.?0+$/, '');
        return `<span class="credits-value" title="${dashFormatted} DASH">${credits}</span>`;
      }
      
      function processValue(value, key) {
        // Check if this is a credits field
        const creditsFields = ['balance', 'totalCreditsInPlatform', 'credits', 'amount', 'totalCredits'];
        const isCreditsField = creditsFields.some(field => key.toLowerCase().includes(field.toLowerCase()));
        
        if (typeof value === 'string' && isCreditsField && /^\d+$/.test(value)) {
          return formatCreditsValue(value);
        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          return formatObject(value);
        } else if (Array.isArray(value)) {
          return formatArray(value);
        } else {
          return escapeHtml(JSON.stringify(value));
        }
      }
      
      function formatObject(obj) {
        const entries = Object.entries(obj).map(([key, value]) => {
          return `<span class="json-key">"${escapeHtml(key)}"</span>: ${processValue(value, key)}`;
        });
        return `{
  ${entries.join(',\n  ')}
}`;
      }
      
      function formatArray(arr) {
        const items = arr.map((item, index) => {
          const indent = '  ';
          const formatted = processValue(item, '');
          return formatted.split('\n').map((line, i) => i === 0 ? line : indent + line).join('\n');
        });
        return `[
  ${items.join(',\n  ')}
]`;
      }
      
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      return `<pre>${processValue(data, '')}</pre>`;
    }

    function updateStatus(message, type = 'loading') {
      const statusBanner = document.getElementById('statusBanner');
      statusBanner.textContent = message;
      statusBanner.className = `status-banner ${type}`;
    }

    async function initializeSdk(network) {
      const currentRequestToken = ++initRequestCounter;
      
      const preloader = document.getElementById('preloader');
      preloader.style.display = 'block';
      const useTrusted = true; // Always use trusted mode
      const modeStr = 'trusted';
      updateStatus(`Initializing ${network.toUpperCase()} SDK (${modeStr} mode)...`, 'loading');
      
      try {
        let newSdk;
        let shouldContinue = true;
        
        if (useTrusted) {
          updateStatus(`Prefetching quorum information for ${network.toUpperCase()}...`, 'loading');
          if (network === 'mainnet') {
            await prefetch_trusted_quorums_mainnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              newSdk = await WasmSdkBuilder.new_mainnet_trusted().build();
            }
          } else {
            await prefetch_trusted_quorums_testnet();
            if (currentRequestToken !== initRequestCounter) {
              console.log(`Discarding stale SDK initialization request ${currentRequestToken}`);
              shouldContinue = false;
            } else {
              newSdk = await WasmSdkBuilder.new_testnet_trusted().build();
            }
          }
        } else if (shouldContinue) {
          if (network === 'mainnet') {
            newSdk = await WasmSdkBuilder.new_mainnet().build();
          } else {
            newSdk = await WasmSdkBuilder.new_testnet().build();
          }
        }
        
        if (shouldContinue && currentRequestToken === initRequestCounter) {
          sdk = newSdk;
          console.log(`Initialized ${network} SDK (${modeStr} mode):`, sdk);
          updateStatus(`WASM SDK successfully loaded on ${network.toUpperCase()} (${modeStr} mode)`, 'success');
        }
      } catch (error) {
        if (currentRequestToken === initRequestCounter) {
          console.error(`Error initializing ${network} SDK:`, error);
          clearResults();
          updateStatus(`Error loading WASM SDK: ${error.message || error}`, 'error');
        }
      } finally {
        if (currentRequestToken === initRequestCounter) {
          preloader.style.display = 'none';
        }
      }
    }

    // Dynamic input creation
    function createInput(inputDef, container) {
      const inputGroup = document.createElement('div');
      inputGroup.className = 'input-group';
      
      const label = document.createElement('label');
      label.textContent = inputDef.label;
      if (!inputDef.required) {
        const optionalSpan = document.createElement('span');
        optionalSpan.className = 'optional-label';
        optionalSpan.textContent = ' (optional)';
        label.appendChild(optionalSpan);
      }
      inputGroup.appendChild(label);

      if (inputDef.type === 'text' || inputDef.type === 'number') {
        const input = document.createElement('input');
        input.type = inputDef.type;
        input.name = inputDef.name;
        input.placeholder = inputDef.label;
        inputGroup.appendChild(input);
      } else if (inputDef.type === 'checkbox') {
        const checkboxContainer = document.createElement('div');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = inputDef.name;
        checkbox.id = `input_${inputDef.name}`;
        
        const checkboxLabel = document.createElement('label');
        checkboxLabel.htmlFor = checkbox.id;
        checkboxLabel.textContent = inputDef.label;
        
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(checkboxLabel);
        inputGroup.appendChild(checkboxContainer);
      } else if (inputDef.type === 'select') {
        const select = document.createElement('select');
        select.name = inputDef.name;
        
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = `Select ${inputDef.label}`;
        select.appendChild(defaultOption);
        
        if (!inputDef.dynamic) {
          inputDef.options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            select.appendChild(option);
          });
        }
        
        inputGroup.appendChild(select);
        
        // Hide dynamic selects initially
        if (inputDef.dynamic) {
          inputGroup.style.display = 'none';
        }
      } else if (inputDef.type === 'multiselect') {
        const selectContainer = document.createElement('div');
        selectContainer.className = 'array-input-container';
        
        inputDef.options.forEach(opt => {
          const checkboxDiv = document.createElement('div');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.name = `${inputDef.name}_${opt.value}`;
          checkbox.value = opt.value;
          checkbox.id = `input_${inputDef.name}_${opt.value}`;
          
          const checkboxLabel = document.createElement('label');
          checkboxLabel.htmlFor = checkbox.id;
          checkboxLabel.textContent = opt.label;
          checkboxLabel.style.marginLeft = '5px';
          
          checkboxDiv.appendChild(checkbox);
          checkboxDiv.appendChild(checkboxLabel);
          selectContainer.appendChild(checkboxDiv);
        });
        
        inputGroup.appendChild(selectContainer);
      } else if (inputDef.type === 'array') {
        const arrayContainer = document.createElement('div');
        arrayContainer.className = 'array-input-container';
        arrayContainer.dataset.arrayName = inputDef.name;
        
        const addButton = document.createElement('button');
        addButton.className = 'add-array-item';
        addButton.textContent = '+ Add Item';
        addButton.onclick = () => addArrayItem(arrayContainer);
        
        arrayContainer.appendChild(addButton);
        inputGroup.appendChild(arrayContainer);
        
        // Add one empty item by default
        addArrayItem(arrayContainer);
      } else if (inputDef.type === 'json') {
        const textarea = document.createElement('textarea');
        textarea.name = inputDef.name;
        textarea.placeholder = `Enter valid JSON for ${inputDef.label}`;
        textarea.style.width = '100%';
        textarea.style.minHeight = '100px';
        textarea.style.padding = '8px';
        textarea.style.border = '1px solid #ddd';
        textarea.style.borderRadius = '4px';
        textarea.style.fontFamily = 'monospace';
        inputGroup.appendChild(textarea);
      } else if (inputDef.type === 'button') {
        const button = document.createElement('button');
        button.textContent = inputDef.label;
        button.className = 'action-button';
        button.onclick = () => window[inputDef.action]();
        inputGroup.appendChild(button);
      } else if (inputDef.type === 'dynamic') {
        // Container for dynamically generated fields
        const dynamicContainer = document.createElement('div');
        dynamicContainer.id = `dynamic_${inputDef.name}`;
        dynamicContainer.className = 'dynamic-fields-container';
        inputGroup.appendChild(dynamicContainer);
        // Hide initially
        inputGroup.style.display = 'none';
      }

      // Handle dependencies
      if (inputDef.dependsOn) {
        inputGroup.style.display = 'none';
        inputGroup.dataset.dependsOn = inputDef.dependsOn.field;
        inputGroup.dataset.dependsOnValue = Array.isArray(inputDef.dependsOn.value) 
          ? inputDef.dependsOn.value.join(',') 
          : inputDef.dependsOn.value;
      }

      container.appendChild(inputGroup);
    }

    function addArrayItem(container) {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'array-item';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Enter value';
      
      const removeButton = document.createElement('button');
      removeButton.textContent = 'Remove';
      removeButton.onclick = () => itemDiv.remove();
      
      itemDiv.appendChild(input);
      itemDiv.appendChild(removeButton);
      
      const addButton = container.querySelector('.add-array-item');
      container.insertBefore(itemDiv, addButton);
    }

    function getInputValues() {
      const values = {};
      const dynamicInputs = document.getElementById('dynamicInputs');
      
      // Text, number, and select inputs
      dynamicInputs.querySelectorAll('input[type="text"], input[type="number"], select').forEach(input => {
        if (input.name) {
          if (input.type === 'number') {
            if (input.value !== '') {
              const numValue = parseInt(input.value);
              if (!isNaN(numValue)) {
                values[input.name] = numValue;
              }
            }
          } else if (input.value) {
            values[input.name] = input.value;
          }
        }
      });
      
      // Checkboxes
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && !checkbox.name.includes('_')) {
          values[checkbox.name] = checkbox.checked;
        }
      });
      
      // Multiselect checkboxes
      const multiselects = {};
      dynamicInputs.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        if (checkbox.name && checkbox.name.includes('_')) {
          const baseName = checkbox.name.split('_')[0];
          if (!multiselects[baseName]) multiselects[baseName] = [];
          if (checkbox.checked) {
            multiselects[baseName].push(parseInt(checkbox.value));
          }
        }
      });
      Object.assign(values, multiselects);
      
      // Arrays
      dynamicInputs.querySelectorAll('.array-input-container').forEach(container => {
        const arrayName = container.dataset.arrayName;
        if (arrayName) {
          const arrayValues = [];
          container.querySelectorAll('.array-item input').forEach(input => {
            if (input.value) arrayValues.push(input.value);
          });
          if (arrayValues.length > 0) {
            values[arrayName] = arrayValues;
          }
        }
      });
      
      // JSON inputs
      dynamicInputs.querySelectorAll('textarea').forEach(textarea => {
        if (textarea.name && textarea.value) {
          try {
            values[textarea.name] = JSON.parse(textarea.value);
          } catch (e) {
            throw new Error(`Invalid JSON in ${textarea.name}: ${e.message}`);
          }
        }
      });
      
      // Handle dynamic where fields
      const whereInputs = dynamicInputs.querySelectorAll('input[name^="where_"]');
      if (whereInputs.length > 0) {
        const whereClause = [];
        whereInputs.forEach(input => {
          if (input.value) {
            const fieldName = input.name.replace('where_', '');
            whereClause.push([fieldName, '==', input.value]);
          }
        });
        if (whereClause.length > 0) {
          values.where = whereClause;
        }
      }
      
      // Handle dynamic order by fields
      const orderBySelects = dynamicInputs.querySelectorAll('select[name^="orderBy_"]');
      if (orderBySelects.length > 0) {
        const orderBy = [];
        orderBySelects.forEach(select => {
          if (select.value) {
            const fieldName = select.name.replace('orderBy_', '');
            orderBy.push([fieldName, select.value]);
          }
        });
        if (orderBy.length > 0) {
          values.orderBy = orderBy;
        }
      }
      
      return values;
    }

    // Query execution
    async function executeQuery(category, queryType) {
      if (!sdk) {
        alert('SDK not initialized. Please wait or refresh the page.');
        return;
      }

      const queryDef = queryDefinitions[category].queries[queryType];
      if (!queryDef) {
        alert('Invalid query selection');
        return;
      }

      const preloader = document.getElementById('preloader');
      const button = document.getElementById('executeQuery');
      const originalButtonText = button.textContent;

      preloader.style.display = 'block';
      button.disabled = true;
      button.textContent = 'Executing...';
      updateStatus(`Executing ${queryDef.label}...`, 'loading');

      try {
        const values = getInputValues();
        let result;
        
        // Identity queries
        if (queryType === 'getIdentity' && values.id) {
          result = await identity_fetch(sdk, values.id);
          result = result.toJSON();
        } else if (queryType === 'getIdentityKeys') {
          const keyIds = values.keyRequestType === 'specific' ? values.specificKeyIds : undefined;
          result = await get_identity_keys(
            sdk,
            values.identityId,
            values.keyRequestType,
            keyIds,
            values.limit,
            values.offset
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentitiesContractKeys') {
          const purposes = values.purposes ? values.purposes.map(p => parseInt(p)) : undefined;
          result = await get_identities_contract_keys(
            sdk,
            values.identitiesIds,
            values.contractId,
            values.documentTypeName || undefined,
            purposes
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityNonce') {
          result = await get_identity_nonce(sdk, values.identityId);
        } else if (queryType === 'getIdentityContractNonce') {
          result = await get_identity_contract_nonce(sdk, values.identityId, values.contractId);
        } else if (queryType === 'getIdentityBalance') {
          result = await get_identity_balance(sdk, values.id);
          // Result is already an object with balance field
        } else if (queryType === 'getIdentitiesBalances') {
          result = await get_identities_balances(sdk, values.ids);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityBalanceAndRevision') {
          result = await get_identity_balance_and_revision(sdk, values.id);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getIdentityByPublicKeyHash') {
          result = await get_identity_by_public_key_hash(sdk, values.publicKeyHash);
          result = result.toJSON();
        } else if (queryType === 'getIdentityByNonUniquePublicKeyHash') {
          result = await get_identity_by_non_unique_public_key_hash(
            sdk,
            values.publicKeyHash,
            values.startAfter || undefined
          );
          // Result is already a JS array
        } else if (queryType === 'getIdentityTokenBalances') {
          result = await get_identity_token_balances(sdk, values.identityId, values.tokenIds);
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Data contract queries
        else if (queryType === 'getDataContract' && values.id) {
          result = await data_contract_fetch(sdk, values.id);
          result = result.toJSON();
        } else if (queryType === 'getDataContractHistory') {
          result = await get_data_contract_history(
            sdk,
            values.id,
            values.limit,
            values.offset,
            values.startAtMs
          );
          result = JSON.parse(result);
        } else if (queryType === 'getDataContracts') {
          result = await get_data_contracts(sdk, values.ids);
          result = JSON.parse(result);
        }
        // Document queries
        else if (queryType === 'getDocuments') {
          const startAfter = values.startOption === 'startAfter' ? values.startValue : undefined;
          const startAt = values.startOption === 'startAt' ? values.startValue : undefined;
          result = await get_documents(
            sdk,
            values.dataContractId,
            values.documentType,
            values.where ? JSON.stringify(values.where) : undefined,
            values.orderBy ? JSON.stringify(values.orderBy) : undefined,
            values.limit,
            startAfter,
            startAt
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getDocument') {
          result = await get_document(
            sdk,
            values.dataContractId,
            values.documentType,
            values.documentId
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Protocol/Version queries
        else if (queryType === 'getProtocolVersionUpgradeState') {
          result = await get_protocol_version_upgrade_state(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getProtocolVersionUpgradeVoteStatus') {
          result = await get_protocol_version_upgrade_vote_status(
            sdk,
            values.startProTxHash || '',  // Empty string if not provided
            values.count || 100           // Default to 100 if not provided
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Epoch/Block queries
        else if (queryType === 'getEpochsInfo') {
          result = await get_epochs_info(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentEpoch') {
          result = await get_current_epoch(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getFinalizedEpochInfos') {
          result = await get_finalized_epoch_infos(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter || undefined,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // System/Utility queries
        else if (queryType === 'getStatus') {
          result = await get_status(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getTotalCreditsInPlatform') {
          result = await get_total_credits_in_platform(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'waitForStateTransitionResult') {
          if (!values.stateTransitionHash) {
            throw new Error('Missing required parameter: stateTransitionHash is required');
          }
          result = await wait_for_state_transition_result(sdk, values.stateTransitionHash);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getCurrentQuorumsInfo') {
          result = await get_current_quorums_info(sdk);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPrefundedSpecializedBalance') {
          if (!values.identityId) {
            throw new Error('Missing required parameter: identityId is required');
          }
          result = await get_prefunded_specialized_balance(sdk, values.identityId);
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getPathElements') {
          if (!values.keys || values.keys.length === 0) {
            throw new Error('Missing required parameter: keys array is required');
          }
          result = await get_path_elements(sdk, values.keys);
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Token queries
        else if (queryType === 'getIdentitiesTokenBalances') {
          result = await get_identities_token_balances(sdk, values.identityIds, values.tokenId);
          result = JSON.parse(result);
        } else if (queryType === 'getIdentityTokenInfos') {
          result = await get_identity_token_infos(
            sdk,
            values.identityId,
            values.tokenIds,
            values.withPurchaseInfo,
            values.limit,
            values.offset
          );
          result = JSON.parse(result);
        } else if (queryType === 'getIdentitiesTokenInfos') {
          result = await get_identities_token_infos(
            sdk,
            values.identityIds,
            values.tokenId,
            values.withPurchaseInfo
          );
          result = JSON.parse(result);
        } else if (queryType === 'getTokenStatuses') {
          result = await get_token_statuses(sdk, values.tokenIds);
          result = JSON.parse(result);
        } else if (queryType === 'getTokenDirectPurchasePrices') {
          result = await get_token_direct_purchase_prices(sdk, values.tokenIds);
          result = JSON.parse(result);
        } else if (queryType === 'getTokenContractInfo') {
          result = await get_token_contract_info(sdk, values.dataContractId);
          result = JSON.parse(result);
        } else if (queryType === 'getTokenPerpetualDistributionLastClaim') {
          result = await get_token_perpetual_distribution_last_claim(
            sdk,
            values.identityId,
            values.distributionId
          );
          result = JSON.parse(result);
        } else if (queryType === 'getTokenTotalSupply') {
          result = await get_token_total_supply(sdk, values.tokenId);
          result = JSON.parse(result);
        }
        // Voting/Contested Resource queries
        else if (queryType === 'getContestedResources') {
          const startAtValue = values.startAtValue ? new TextEncoder().encode(values.startAtValue) : undefined;
          result = await get_contested_resources(
            sdk,
            values.documentTypeName,
            values.dataContractId,
            values.indexName,
            values.resultType,
            values.allowIncludeLockedAndAbstainingVoteTally,
            startAtValue,
            values.limit,
            values.offset,
            values.orderAscending
          );
          result = JSON.parse(result);
        } else if (queryType === 'getContestedResourceVoteState') {
          result = await get_contested_resource_vote_state(
            sdk,
            values.dataContractId,
            values.documentTypeName,
            values.indexName,
            values.resultType,
            values.allowIncludeLockedAndAbstainingVoteTally,
            values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
            values.count,
            values.orderAscending
          );
          result = JSON.parse(result);
        } else if (queryType === 'getContestedResourceVotersForIdentity') {
          result = await get_contested_resource_voters_for_identity(
            sdk,
            values.dataContractId,
            values.documentTypeName,
            values.indexName,
            values.contestantId,
            values.startAtIdentifierInfo ? JSON.stringify(values.startAtIdentifierInfo) : undefined,
            values.count,
            values.orderAscending
          );
          result = JSON.parse(result);
        } else if (queryType === 'getContestedResourceIdentityVotes') {
          result = await get_contested_resource_identity_votes(
            sdk,
            values.identityId,
            values.limit,
            values.offset,
            values.orderAscending
          );
          result = JSON.parse(result);
        } else if (queryType === 'getVotePollsByEndDate') {
          result = await get_vote_polls_by_end_date(
            sdk,
            values.startTimeMs,
            values.endTimeMs,
            values.limit,
            values.offset,
            values.orderAscending
          );
          result = JSON.parse(result);
        }
        // Epoch/Block queries
        else if (queryType === 'getFinalizedEpochInfos') {
          result = await get_finalized_epoch_infos(
            sdk,
            values.startEpoch,
            values.count,
            values.ascending
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByIds') {
          result = await get_evonodes_proposed_epoch_blocks_by_ids(
            sdk,
            values.epoch,
            values.ids
          );
          // Result is already a JS object from serde_wasm_bindgen
        } else if (queryType === 'getEvonodesProposedEpochBlocksByRange') {
          result = await get_evonodes_proposed_epoch_blocks_by_range(
            sdk,
            values.epoch,
            values.limit,
            values.startAfter,
            values.orderAscending
          );
          // Result is already a JS object from serde_wasm_bindgen
        }
        // Group queries
        else if (queryType === 'getGroupInfo') {
          result = await get_group_info(sdk, values.groupContractId);
          result = JSON.parse(result);
        } else if (queryType === 'getGroupMembers') {
          result = await get_group_members(
            sdk,
            values.groupContractId,
            values.memberIds,
            values.startAt,
            values.limit
          );
          result = JSON.parse(result);
        } else if (queryType === 'getIdentityGroups') {
          result = await get_identity_groups(
            sdk,
            values.identityId,
            values.memberDataContracts,
            values.ownerDataContracts,
            values.moderatorDataContracts
          );
          result = JSON.parse(result);
        } else if (queryType === 'getGroupsDataContracts') {
          result = await get_groups_data_contracts(sdk, values.dataContractIds);
          result = JSON.parse(result);
        } else {
          // Placeholder for unimplemented queries
          throw new Error(`Query ${queryType} is not yet implemented in the WASM SDK bindings`);
        }
        
        displayResult(result);
        updateStatus(`${queryDef.label} executed successfully`, 'success');
      } catch (error) {
        console.error(`Error executing ${queryType}:`, error);
        displayResult(`Error executing query: ${error.message || error}`, true);
        updateStatus(`Error: ${error.message || error}`, 'error');
      } finally {
        preloader.style.display = 'none';
        button.disabled = false;
        button.textContent = originalButtonText;
      }
    }

    // Event handlers
    document.getElementById('queryCategory').addEventListener('change', (e) => {
      const category = e.target.value;
      const queryTypeSelect = document.getElementById('queryType');
      const queryInputs = document.getElementById('queryInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear query type
      queryTypeSelect.innerHTML = '<option value="">Select Query Type</option>';
      queryTypeSelect.style.display = category ? 'block' : 'none';
      
      // Hide inputs and button
      queryInputs.style.display = 'none';
      executeButton.style.display = 'none';
      queryDescription.style.display = 'none';
      
      if (category && queryDefinitions[category]) {
        // Populate query types
        Object.entries(queryDefinitions[category].queries).forEach(([key, query]) => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = query.label;
          queryTypeSelect.appendChild(option);
        });
      }
    });

    document.getElementById('queryType').addEventListener('change', (e) => {
      const queryType = e.target.value;
      const category = document.getElementById('queryCategory').value;
      const queryInputs = document.getElementById('queryInputs');
      const dynamicInputs = document.getElementById('dynamicInputs');
      const executeButton = document.getElementById('executeQuery');
      const queryTitle = document.getElementById('queryTitle');
      const queryDescription = document.getElementById('queryDescription');
      
      // Clear existing inputs
      dynamicInputs.innerHTML = '';
      
      if (queryType && category && queryDefinitions[category].queries[queryType]) {
        const query = queryDefinitions[category].queries[queryType];
        queryTitle.textContent = query.label;
        
        // Show description
        if (query.description) {
          queryDescription.textContent = query.description;
          queryDescription.style.display = 'block';
        } else {
          queryDescription.style.display = 'none';
        }
        
        // Create inputs
        query.inputs.forEach(inputDef => {
          createInput(inputDef, dynamicInputs);
        });
        
        // Setup dependency handlers
        dynamicInputs.querySelectorAll('select, input[type="checkbox"]').forEach(input => {
          input.addEventListener('change', () => {
            dynamicInputs.querySelectorAll('[data-depends-on]').forEach(dependent => {
              const dependsOn = dependent.dataset.dependsOn;
              const dependsOnValues = dependent.dataset.dependsOnValue.split(',');
              const currentValue = dynamicInputs.querySelector(`[name="${dependsOn}"]`)?.value;
              
              if (dependsOnValues.includes(currentValue)) {
                dependent.style.display = 'block';
              } else {
                dependent.style.display = 'none';
              }
            });
          });
        });
        
        queryInputs.style.display = 'block';
        executeButton.style.display = 'block';
      } else {
        queryInputs.style.display = 'none';
        executeButton.style.display = 'none';
        queryDescription.style.display = 'none';
      }
    });

    document.getElementById('executeQuery').addEventListener('click', async () => {
      const category = document.getElementById('queryCategory').value;
      const queryType = document.getElementById('queryType').value;
      await executeQuery(category, queryType);
    });

    // Network toggle handlers
    document.querySelectorAll('input[name="network"]').forEach(radio => {
      radio.addEventListener('change', async (event) => {
        const network = event.target.value;
        const indicator = document.getElementById('networkIndicator');
        
        indicator.textContent = network.toUpperCase();
        indicator.className = `network-indicator ${network}`;
        
        clearResults();
        await initializeSdk(network);
      });
    });

    // Trusted mode is always on, no need for event listener

    // Initialize
    async function run() {
      try {
        updateStatus('Loading WASM module...', 'loading');
        await init();
        updateStatus('WASM module loaded, initializing SDK...', 'loading');
        await initializeSdk('mainnet');
      } catch (error) {
        console.error('Failed to initialize WASM:', error);
        updateStatus(`Failed to load WASM module: ${error.message || error}`, 'error');
      }
    }

    run();
  </script>
</body>

</html>