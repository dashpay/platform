//! Platform events upstream multiplexer (PlatformEventsMux)
//!
//! This module provides a reusable upstream multiplexer for the
//! bi-directional gRPC `subscribePlatformEvents` stream exposed by
//! Drive ABCI. It manages a small pool of upstream connections and
//! exposes per-client sessions and a shared in-process EventBus used to
//! fan-out upstream responses by `client_subscription_id` (UUID, preserved
//! across layers) without any ID rewriting.
//!
//! Message flow (with channels and order)
//!
//! Channels used:
//! - `upstream_txs: Vec<mpsc::UnboundedSender<PlatformEventsCommand>>`
//!   per upstream connection; paired with `up_rx` in `spawn_upstream`.
//! - `up_rx: mpsc::UnboundedReceiver<PlatformEventsCommand>` per upstream;
//!   converted to `UnboundedReceiverStream` and used as the gRPC request stream.
//! - `downstream_tx: mpsc::UnboundedSender<Result<PlatformEventsResponse, Status>>`
//!   per client session; provided by the consumer to deliver filtered responses.
//! - `inbound: tonic::Streaming<PlatformEventsCommand>` per client session;
//!   gRPC request stream coming from the consumer’s client.
//!
//! Command path (client -> upstream):
//! 1) Consumer calls `PlatformEventsMux::register_session_with_tx(downstream_tx)`
//!    to obtain a `PlatformEventsSession { upstream_tx, downstream_tx, ... }`.
//! 2) Consumer calls `spawn_client_command_processor(session, inbound, out_tx)`.
//!    - For each `PlatformEventsCommand` on `inbound`:
//!      a) `Add` → `PlatformEventsSession::add(client_subscription_id, filter)`:
//!         - Subscribes to the mux EventBus with `IdFilter{ id }` and forwards
//!           matched upstream responses to `downstream_tx`.
//!         - Sends Add upstream via `upstream_tx`.
//!      b) `Remove` → `PlatformEventsSession::remove(client_subscription_id)`:
//!         - Drops the EventBus handle to stop forwarding.
//!         - Sends Remove upstream via `upstream_tx`.
//!      c) `Ping` → Responds locally on `out_tx` with `AckV0` (no upstream call).
//!      d) Invalid/missing → Responds on `out_tx` with `PlatformErrorV0`.
//! 3) In `spawn_upstream(client, up_rx, bus)` per upstream:
//!    - `up_rx` is wrapped into `UnboundedReceiverStream` and passed to
//!      `client.subscribe_platform_events(cmd_stream)` as the request stream.
//!
//! Event path (upstream -> client):
//! 1) `spawn_upstream` reads gRPC responses from `resp_stream.message().await`.
//! 2) For each `PlatformEventsResponse` frame:
//!    - Extract `client_subscription_id` (UUID).
//!    - Publish the frame to the EventBus; all sessions with `IdFilter { id }`
//!      receive it and forward through their `downstream_tx`.
//!
//! Subscription IDs
//! - `client_subscription_id` should be a UUID string generated by the client.
//! - The same UUID is used across all layers (SDK → rs-dapi → rs-drive-abci).
//! - No ID rewriting occurs; frames are forwarded as-is.
//!
//! Cleanup and metrics
//! - `PlatformEventsSession::drop` sends `RemoveSubscriptionV0` for all
//!   active upstream IDs and decrements the active sessions gauge.
//! - Metrics are gated behind the `metrics` feature and registered via
//!   `metrics_register_once()`. Counters/gauges are updated in
//!   `spawn_upstream` and on session drop (`metrics_upstream_stream_started`,
//!   `metrics_forwarded_event`, `metrics_forwarded_ack`, `metrics_forwarded_error`,
//!   `metrics_active_sessions_dec`).
//! - All logging uses the `tracing` crate.

use std::collections::BTreeMap;
use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};

use dapi_grpc::platform::v0::platform_client::PlatformClient;
use dapi_grpc::platform::v0::platform_events_command::platform_events_command_v0::Command as Cmd;
use dapi_grpc::platform::v0::platform_events_command::Version as CmdVersion;
use dapi_grpc::platform::v0::platform_events_response::platform_events_response_v0::Response as Resp;
use dapi_grpc::platform::v0::platform_events_response::PlatformEventsResponseV0;
use dapi_grpc::platform::v0::{
    PlatformEventMessageV0, PlatformEventsCommand, PlatformEventsResponse, PlatformFilterV0,
};
use dapi_grpc::tonic::{Status, Streaming};
use tokio::sync::{mpsc, Mutex};
use tokio_stream::wrappers::UnboundedReceiverStream;
use tokio_util::sync::CancellationToken;

use crate::event_bus::{EventBus, Filter as EventFilter, SubscriptionHandle};
use rs_dapi_client::transport::{create_channel, PlatformGrpcClient};
use rs_dapi_client::{AddressList, Uri};

/// Settings for PlatformEventsMux
#[derive(Clone, Debug)]
pub struct PlatformMuxSettings {
    /// Number of upstream bi-di connections to maintain.
    pub upstream_conn_count: usize,
}

impl Default for PlatformMuxSettings {
    fn default() -> Self {
        Self {
            upstream_conn_count: 2,
        }
    }
}

/// Multiplexer that manages a pool of bi‑di upstream connections to Drive ABCI.
#[derive(Clone)]
pub struct PlatformEventsMux {
    /// Address list for upstream Drive ABCI nodes.
    addresses: AddressList,
    /// Per‑upstream sender for commands into each bi‑di stream.
    upstream_txs: Vec<mpsc::UnboundedSender<PlatformEventsCommand>>,
    /// In‑process bus used to fan‑out upstream responses by subscription id
    bus: EventBus<PlatformEventsResponse, IdFilter>,
    /// Round‑robin counter for choosing an upstream connection.
    rr_counter: Arc<AtomicUsize>,
    cancel: CancellationToken,
}

impl PlatformEventsMux {
    /// Create a new mux and spawn the upstream connection tasks.
    ///
    /// Inputs:
    /// - `addresses`: upstream Drive ABCI node addresses (used to create gRPC clients)
    /// - `settings`: pool size (`upstream_conn_count`)
    ///
    /// Output:
    /// - Returns a `PlatformEventsMux` with a pool of upstream command senders
    ///   (`upstream_txs`) and a shared routing table (`routes`).
    ///
    /// Side effects:
    /// - Spawns one [`spawn_upstream`] task per upstream connection.
    pub fn new(addresses: AddressList, settings: PlatformMuxSettings) -> Result<Self, Status> {
        if addresses.is_empty() {
            return Err(Status::unavailable("empty AddressList"));
        }

        metrics_register_once();
        let bus = EventBus::new();
        let cancel = CancellationToken::new();

        let mut upstream_txs = Vec::with_capacity(settings.upstream_conn_count.max(1));
        for i in 0..settings.upstream_conn_count.max(1) {
            let (up_tx, up_rx) = mpsc::unbounded_channel::<PlatformEventsCommand>();
            let uri = pick_uri(&addresses)
                .ok_or_else(|| Status::unavailable("no live address available"))?;
            let client = make_platform_client(uri.clone());
            tracing::info!(index = i, %uri, "platform_mux: spawning upstream");
            Self::spawn_upstream(client, up_rx, bus.clone(), cancel.clone());
            upstream_txs.push(up_tx);
        }

        Ok(Self {
            addresses,
            upstream_txs,
            bus,
            rr_counter: Arc::new(AtomicUsize::new(0)),
            cancel,
        })
    }

    /// Spawn a single upstream bi‑di stream task to Drive ABCI.
    ///
    /// Inputs:
    /// - `client`: Platform gRPC client bound to a specific upstream
    /// - `up_rx`: receives local `PlatformEventsCommand` frames; becomes the request stream
    /// - `bus`: EventBus that delivers responses filtered by `client_subscription_id`
    ///
    /// Output/Effects:
    /// - Feeds `up_rx` into `client.subscribe_platform_events(..)` as the request stream.
    /// - Reads upstream `PlatformEventsResponse` frames and forwards them unchanged
    ///   to the matching `downstream_tx` found in `routes`.
    fn spawn_upstream(
        mut client: PlatformGrpcClient,
        up_rx: mpsc::UnboundedReceiver<PlatformEventsCommand>,
        bus: EventBus<PlatformEventsResponse, IdFilter>,
        cancel: CancellationToken,
    ) {
        tokio::spawn(async move {
            let cmd_stream = UnboundedReceiverStream::new(up_rx);
            let Ok(resp) = client.subscribe_platform_events(cmd_stream).await else {
                tracing::warn!("platform_mux: failed to open upstream stream");
                return;
            };
            metrics_upstream_stream_started();
            let mut resp_stream = resp.into_inner();
            loop {
                tokio::select! {
                    _ = cancel.cancelled() => break,
                    msg = resp_stream.message() => {
                        match msg {
                            Ok(Some(PlatformEventsResponse { version: Some(v) })) => {
                                let dapi_grpc::platform::v0::platform_events_response::Version::V0(v0) = v;
                                match v0.response {
                                    Some(Resp::Event(PlatformEventMessageV0 { client_subscription_id, event })) => {
                                        let _ = bus.notify(PlatformEventsResponse{ version: Some(dapi_grpc::platform::v0::platform_events_response::Version::V0(PlatformEventsResponseV0{ response: Some(Resp::Event(PlatformEventMessageV0{ client_subscription_id, event }))})) }).await;
                                        metrics_forwarded_event();
                                    }
                                    Some(Resp::Ack(ack)) => {
                                        let _ = bus.notify(PlatformEventsResponse{ version: Some(dapi_grpc::platform::v0::platform_events_response::Version::V0(PlatformEventsResponseV0{ response: Some(Resp::Ack(ack)) })) }).await;
                                        metrics_forwarded_ack();
                                    }
                                    Some(Resp::Error(err)) => {
                                        let _ = bus.notify(PlatformEventsResponse{ version: Some(dapi_grpc::platform::v0::platform_events_response::Version::V0(PlatformEventsResponseV0{ response: Some(Resp::Error(err)) })) }).await;
                                        metrics_forwarded_error();
                                    }
                                    None => {}
                                }
                            }
                            Ok(Some(PlatformEventsResponse { version: None })) => { tracing::warn!("platform_mux: upstream response missing version"); }
                            Ok(None) => break,
                            Err(e) => { tracing::warn!(error = %e, "platform_mux: upstream stream error"); break; }
                        }
                    }
                }
            }
        });
    }

    /// Request graceful shutdown of upstream tasks.
    pub fn shutdown(&self) {
        self.cancel.cancel();
    }

    /// Pick an upstream connection in round‑robin fashion.
    fn choose_upstream(&self) -> (usize, mpsc::UnboundedSender<PlatformEventsCommand>) {
        let idx = self.rr_counter.fetch_add(1, Ordering::Relaxed) % self.upstream_txs.len();
        (idx, self.upstream_txs[idx].clone())
    }

    /// Register a new client session and bind it to an upstream.
    ///
    /// Input:
    /// - `downstream_tx`: per-client sender for upstream responses.
    ///
    /// Output:
    /// - Returns a `PlatformEventsSession` with `upstream_tx` for commands and
    ///   `downstream_tx` retained for routing responses.
    pub async fn register_session_with_tx(
        &self,
        downstream_tx: mpsc::UnboundedSender<Result<PlatformEventsResponse, Status>>,
    ) -> PlatformEventsSession {
        let (_, upstream_tx) = self.choose_upstream();
        PlatformEventsSession {
            mux: self.clone(),
            downstream_tx,
            upstream_tx,
            subscribed_ids: Arc::new(Mutex::new(std::collections::BTreeSet::new())),
            handles: Arc::new(Mutex::new(BTreeMap::new())),
        }
    }

    /// Subscribe to Platform events upstream and return an EventBus handle that
    /// receives only messages for the generated `client_subscription_id`. When
    /// the last clone of the handle is dropped, a `RemoveSubscription` is sent
    /// upstream automatically (RAII) via the attached drop callback.
    pub async fn subscribe(
        &self,
        filter: PlatformFilterV0,
    ) -> Result<(String, PlatformEventsSubscriptionHandle), Status> {
        let id = uuid::Uuid::new_v4().to_string();
        let id_for_cb = id.clone();
        let (_up_idx, upstream_tx) = self.choose_upstream();

        // Send upstream Add
        let cmd = PlatformEventsCommand {
            version: Some(CmdVersion::V0(
                dapi_grpc::platform::v0::platform_events_command::PlatformEventsCommandV0 {
                    command: Some(Cmd::Add(dapi_grpc::platform::v0::AddSubscriptionV0 {
                        client_subscription_id: id.clone(),
                        filter: Some(filter),
                    })),
                },
            )),
        };
        let _ = upstream_tx.send(cmd);

        // Subscribe to bus and attach RAII Remove callback
        let handle = self
            .bus
            .add_subscription(IdFilter { id: id.clone() })
            .await
            .with_drop_cb(Arc::new(move |_bus_sub_id| {
                let cmd = PlatformEventsCommand {
                    version: Some(CmdVersion::V0(
                        dapi_grpc::platform::v0::platform_events_command::PlatformEventsCommandV0 {
                            command: Some(Cmd::Remove(
                                dapi_grpc::platform::v0::RemoveSubscriptionV0 {
                                    client_subscription_id: id_for_cb.clone(),
                                },
                            )),
                        },
                    )),
                };
                let _ = upstream_tx.send(cmd);
            }))
            .await;

        Ok((id, handle))
    }
}

/// Per‑client session that routes events and commands.
pub struct PlatformEventsSession {
    /// Shared upstream multiplexer used by this session.
    mux: PlatformEventsMux,
    /// Sender for responses to the public client stream.
    downstream_tx: mpsc::UnboundedSender<Result<PlatformEventsResponse, Status>>,
    /// Sender for commands to the chosen upstream connection.
    upstream_tx: mpsc::UnboundedSender<PlatformEventsCommand>,
    /// Per‑session set of active subscription IDs (UUIDs)
    subscribed_ids: Arc<Mutex<std::collections::BTreeSet<String>>>,
    /// EventBus handles per subscription id
    handles: Arc<Mutex<BTreeMap<String, SubscriptionHandle<PlatformEventsResponse, IdFilter>>>>,
}

impl PlatformEventsSession {
    /// Add a subscription: register routing and forward upstream.
    ///
    /// Inputs:
    /// - `client_subscription_id`: UUID string
    /// - `filter`: Platform filter to install upstream
    ///
    /// Output/Effects:
    /// - Adds `client_subscription_id` to the session set and mux routes: `id -> downstream_tx`.
    /// - Sends `AddSubscriptionV0 { client_subscription_id: id }` upstream.
    pub async fn add(&self, client_subscription_id: String, filter: PlatformFilterV0) {
        // register route: use the same UUID across layers
        {
            let mut set = self.subscribed_ids.lock().await;
            set.insert(client_subscription_id.clone());
        }
        // subscribe to mux bus and forward
        let handle = self
            .mux
            .bus
            .add_subscription(IdFilter {
                id: client_subscription_id.clone(),
            })
            .await;
        {
            let mut map = self.handles.lock().await;
            map.insert(client_subscription_id.clone(), handle.clone());
        }
        let down = self.downstream_tx.clone();
        tokio::spawn(async move {
            loop {
                match handle.recv().await {
                    Some(resp) => {
                        tracing::debug!(?resp, "platform_mux: forwarding event to client");
                        let _ = down.send(Ok(resp));
                    }
                    None => break,
                }
            }
        });
        // send upstream add
        let cmd = PlatformEventsCommand {
            version: Some(CmdVersion::V0(
                dapi_grpc::platform::v0::platform_events_command::PlatformEventsCommandV0 {
                    command: Some(Cmd::Add(dapi_grpc::platform::v0::AddSubscriptionV0 {
                        client_subscription_id,
                        filter: Some(filter),
                    })),
                },
            )),
        };
        let _ = self.upstream_tx.send(cmd);
    }

    /// Remove a subscription: drop routing and forward upstream.
    ///
    /// Input: `client_subscription_id` — UUID string
    ///
    /// Output/Effects:
    /// - Removes `client_subscription_id` from the session set and mux routes.
    /// - Sends `RemoveSubscriptionV0 { client_subscription_id: id }` upstream.
    pub async fn remove(&self, client_subscription_id: String) {
        let was_present = {
            self.subscribed_ids
                .lock()
                .await
                .remove(&client_subscription_id)
        };
        if was_present {
            {
                let mut map = self.handles.lock().await;
                map.remove(&client_subscription_id);
            }
            let cmd = PlatformEventsCommand {
                version: Some(CmdVersion::V0(
                    dapi_grpc::platform::v0::platform_events_command::PlatformEventsCommandV0 {
                        command: Some(Cmd::Remove(dapi_grpc::platform::v0::RemoveSubscriptionV0 {
                            client_subscription_id,
                        })),
                    },
                )),
            };
            let _ = self.upstream_tx.send(cmd);
        }
    }
}

impl Drop for PlatformEventsSession {
    fn drop(&mut self) {
        let upstream_tx = self.upstream_tx.clone();
        let set = self.subscribed_ids.clone();
        let handles = self.handles.clone();
        tokio::spawn(async move {
            {
                handles.lock().await.clear();
            }
            let ids: Vec<String> = {
                let s = set.lock().await;
                s.iter().cloned().collect()
            };
            for id in ids {
                let cmd = PlatformEventsCommand {
                    version: Some(CmdVersion::V0(
                        dapi_grpc::platform::v0::platform_events_command::PlatformEventsCommandV0 {
                            command: Some(Cmd::Remove(
                                dapi_grpc::platform::v0::RemoveSubscriptionV0 {
                                    client_subscription_id: id,
                                },
                            )),
                        },
                    )),
                };
                let _ = upstream_tx.send(cmd);
            }
        });
        metrics_active_sessions_dec();
    }
}

/// Create a Platform gRPC client for a given URI (lazy connect).
fn make_platform_client(uri: Uri) -> PlatformGrpcClient {
    let channel = create_channel(uri, None).expect("failed to create gRPC channel");
    PlatformClient::new(channel)
}

fn pick_uri(addresses: &AddressList) -> Option<Uri> {
    addresses.get_live_address().map(|a| a.uri().clone())
}

// ---- Filters ----

#[derive(Clone)]
pub struct IdFilter {
    id: String,
}

impl EventFilter<PlatformEventsResponse> for IdFilter {
    fn matches(&self, event: &PlatformEventsResponse) -> bool {
        if let Some(dapi_grpc::platform::v0::platform_events_response::Version::V0(v0)) =
            &event.version
        {
            match &v0.response {
                Some(Resp::Event(ev)) => ev.client_subscription_id == self.id,
                Some(Resp::Ack(ack)) => ack.client_subscription_id == self.id,
                Some(Resp::Error(err)) => err.client_subscription_id == self.id,
                None => false,
            }
        } else {
            false
        }
    }
}

/// Public alias for the EventBus subscription handle used for Platform events.
pub type PlatformEventsSubscriptionHandle = SubscriptionHandle<PlatformEventsResponse, IdFilter>;

// ---- Metrics helpers (gated) ----

#[cfg(feature = "metrics")]
mod met {
    use metrics::{counter, describe_counter, describe_gauge, gauge};
    use std::sync::Once;

    pub const ACTIVE_SESSIONS: &str = "platform_mux_active_sessions";
    pub const UPSTREAM_STREAMS_TOTAL: &str = "platform_mux_upstream_streams_total";
    pub const FORWARDED_EVENTS_TOTAL: &str = "platform_mux_forwarded_events_total";
    pub const FORWARDED_ACKS_TOTAL: &str = "platform_mux_forwarded_acks_total";
    pub const FORWARDED_ERRORS_TOTAL: &str = "platform_mux_forwarded_errors_total";

    pub fn register_metrics_once() {
        static ONCE: Once = Once::new();
        ONCE.call_once(|| {
            describe_gauge!(ACTIVE_SESSIONS, "Active client sessions in platform mux");
            describe_counter!(UPSTREAM_STREAMS_TOTAL, "Upstream streams started");
            describe_counter!(FORWARDED_EVENTS_TOTAL, "Events forwarded to clients");
            describe_counter!(FORWARDED_ACKS_TOTAL, "Acks forwarded to clients");
            describe_counter!(FORWARDED_ERRORS_TOTAL, "Errors forwarded to clients");
        });
    }
    pub fn active_sessions_inc() {
        gauge!(ACTIVE_SESSIONS).increment(1.0);
    }
    pub fn active_sessions_dec() {
        gauge!(ACTIVE_SESSIONS).decrement(1.0);
    }
    pub fn upstream_stream_started() {
        counter!(UPSTREAM_STREAMS_TOTAL).increment(1);
    }
    pub fn forwarded_event() {
        counter!(FORWARDED_EVENTS_TOTAL).increment(1);
    }
    pub fn forwarded_ack() {
        counter!(FORWARDED_ACKS_TOTAL).increment(1);
    }
    pub fn forwarded_error() {
        counter!(FORWARDED_ERRORS_TOTAL).increment(1);
    }
}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_register_once() {
    met::register_metrics_once()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_register_once() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_active_sessions_inc() {
    met::active_sessions_inc()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_active_sessions_inc() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_active_sessions_dec() {
    met::active_sessions_dec()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_active_sessions_dec() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_upstream_stream_started() {
    met::upstream_stream_started()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_upstream_stream_started() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_forwarded_event() {
    met::forwarded_event()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_forwarded_event() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_forwarded_ack() {
    met::forwarded_ack()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_forwarded_ack() {}

#[cfg(feature = "metrics")]
#[inline]
fn metrics_forwarded_error() {
    met::forwarded_error()
}
#[cfg(not(feature = "metrics"))]
#[inline]
fn metrics_forwarded_error() {}

/// Spawn a task to process client `PlatformEventsCommand` frames for a session.
///
/// Inputs:
/// - `session`: per-client session used to add/remove upstream subscriptions
/// - `inbound`: client-side gRPC request stream of `PlatformEventsCommand`
/// - `out_tx`: sender used to deliver immediate local responses (Ack/Error)
///
/// Output/Effects:
/// - For `Add`/`Remove`, updates local routing and sends the command upstream.
/// - For `Ping`, responds locally on `out_tx` with an Ack (no upstream call).
/// - For invalid frames, responds with a structured Error (no upstream call).
pub fn spawn_client_command_processor(
    session: PlatformEventsSession,
    mut inbound: Streaming<PlatformEventsCommand>,
    out_tx: mpsc::UnboundedSender<Result<PlatformEventsResponse, Status>>,
) {
    tokio::spawn(async move {
        use tokio_stream::StreamExt;
        loop {
            let inbound_message = inbound.message().await;
            tracing::debug!(?inbound_message, "platform_mux: received inbound message");
            match inbound_message {
                Ok(Some(PlatformEventsCommand {
                    version: Some(CmdVersion::V0(v0)),
                })) => match v0.command {
                    Some(Cmd::Add(add)) => {
                        let filter = add.filter.unwrap_or(PlatformFilterV0 { kind: None });
                        session.add(add.client_subscription_id, filter).await;
                    }
                    Some(Cmd::Remove(rem)) => {
                        session.remove(rem.client_subscription_id).await;
                    }
                    Some(Cmd::Ping(p)) => {
                        let resp = PlatformEventsResponse {
                            version: Some(
                                dapi_grpc::platform::v0::platform_events_response::Version::V0(
                                    PlatformEventsResponseV0 {
                                        response: Some(Resp::Ack(dapi_grpc::platform::v0::AckV0 {
                                            client_subscription_id: p.nonce.to_string(),
                                            op: "ping".to_string(),
                                        })),
                                    },
                                ),
                            ),
                        };
                        let _ = out_tx.send(Ok(resp));
                    }
                    None => {
                        let resp = PlatformEventsResponse {
                            version: Some(
                                dapi_grpc::platform::v0::platform_events_response::Version::V0(
                                    PlatformEventsResponseV0 {
                                        response: Some(Resp::Error(
                                            dapi_grpc::platform::v0::PlatformErrorV0 {
                                                client_subscription_id: "".to_string(),
                                                code: 400,
                                                message: "missing command".to_string(),
                                            },
                                        )),
                                    },
                                ),
                            ),
                        };
                        let _ = out_tx.send(Ok(resp));
                    }
                },
                Ok(Some(PlatformEventsCommand { version: None })) => {
                    let resp = PlatformEventsResponse {
                        version: Some(
                            dapi_grpc::platform::v0::platform_events_response::Version::V0(
                                PlatformEventsResponseV0 {
                                    response: Some(Resp::Error(
                                        dapi_grpc::platform::v0::PlatformErrorV0 {
                                            client_subscription_id: "".to_string(),
                                            code: 400,
                                            message: "missing version".to_string(),
                                        },
                                    )),
                                },
                            ),
                        ),
                    };
                    let _ = out_tx.send(Ok(resp));
                }
                Ok(None) => break,
                Err(e) => {
                    let resp = PlatformEventsResponse {
                        version: Some(
                            dapi_grpc::platform::v0::platform_events_response::Version::V0(
                                PlatformEventsResponseV0 {
                                    response: Some(Resp::Error(
                                        dapi_grpc::platform::v0::PlatformErrorV0 {
                                            client_subscription_id: "".to_string(),
                                            code: 500,
                                            message: format!("{}", e),
                                        },
                                    )),
                                },
                            ),
                        ),
                    };
                    let _ = out_tx.send(Ok(resp));
                    break;
                }
            }
        }
    });
}
