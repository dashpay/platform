//! Generate test vectors for drive proof verifier.
//!
//! This example connects to a Dash Platform node and fetches data from it.
//! It then generates test vectors for the drive proof verifier.
//!
//! Test vectors should be saved to `tests/vectors` directory.
//!
//! You can configure the example by setting environment variables in the `${CARGO_MANIFEST_DIR}/.env` file.
//! See ``.env.example` and [Config] for more details.

use dpp::{
    document::Document,
    prelude::{DataContract, Identifier, Identity},
};
use drive_proof_verifier::FromProof;
use rs_sdk::{
    mock::MockResponse,
    platform::{
        dapi::{transport::TransportRequest, AddressList, Uri},
        DocumentQuery, {Fetch, List},
    },
    Sdk, SdkBuilder,
};
use serde::Deserialize;
use std::{
    collections::BTreeMap,
    fmt::Debug,
    fs::copy,
    path::{Path, PathBuf},
    str::FromStr,
};
use tracing_subscriber::{filter::LevelFilter, EnvFilter};

#[derive(Debug, Deserialize)]
pub struct Config {
    pub platform_host: String,
    pub platform_port: u16,
    pub core_port: u16,
    pub core_user: String,
    pub core_password: String,

    // IDs of some objects generated by the testnet
    pub existing_identity_id: Identifier,
    pub existing_data_contract_id: Identifier,
    pub existing_document_type_name: String,

    pub existing_document_id: Identifier,

    // Where all files will be saved
    #[serde(default = "Config::default_destination_dir")]
    pub destination_dir: PathBuf,
}

impl Config {
    /// Load config from enviroment variables
    pub fn new() -> Self {
        // load config from .env file, ignore errors
        let path = env!("CARGO_MANIFEST_DIR").to_owned() + "/.env";
        dotenvy::from_path(&path).expect("failed to load config file");

        // println!("Load .env file: {:?}", dotenvy::dotenv());
        envy::from_env().expect("configuration error")
    }

    pub fn address_list(&self) -> AddressList {
        let address: String = format!("http://{}:{}", self.platform_host, self.platform_port);

        AddressList::from_iter(vec![Uri::from_str(&address).expect("valid uri")])
    }

    fn default_destination_dir() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("vectors")
    }
}

#[tokio::main]
async fn main() {
    enable_logging();
    let cfg = Config::new();
    let dump_dir = tempfile::tempdir().expect("create temp dir");
    let mut sdk = setup_sdk(&cfg, &dump_dir.path());

    // Identity
    let identity_test_cases: BTreeMap<&'static str, Identifier> = BTreeMap::from([
        ("identity_ok", cfg.existing_identity_id.clone()),
        ("identity_not_found", Identifier::random()),
    ]);
    generate_fetch::<Identity, Identifier>(&mut sdk, identity_test_cases, &cfg, &dump_dir.path())
        .await;

    // Data contract
    let contract_tc: BTreeMap<&'static str, Identifier> = BTreeMap::from([
        ("data_contract_ok", cfg.existing_data_contract_id.clone()),
        ("data_contract_not_found", Identifier::random()),
    ]);
    generate_fetch::<DataContract, Identifier>(&mut sdk, contract_tc, &cfg, &dump_dir.path()).await;

    // Single document
    let base_query = DocumentQuery::new_with_data_contract_id(
        &mut sdk,
        cfg.existing_data_contract_id.clone(),
        &cfg.existing_document_type_name,
    )
    .await
    .expect("document query creation");
    let document_tc: BTreeMap<&'static str, DocumentQuery> = BTreeMap::from([
        (
            "document_ok",
            base_query
                .clone()
                .with_document_id(&cfg.existing_document_id),
        ),
        (
            "document_not_found",
            base_query.with_document_id(&Identifier::random()),
        ),
    ]);

    generate_fetch::<Document, _>(&mut sdk, document_tc.clone(), &cfg, &dump_dir.path()).await;

    // the same should also work for list
    generate_list::<Document, _>(&mut sdk, document_tc, &cfg, &dump_dir.path()).await;
}

/// Enable logging with `RUST_LOG` env variable, default to `info` level
fn enable_logging() {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::builder()
                .with_default_directive(LevelFilter::INFO.into())
                .from_env_lossy(),
        )
        .init();
}

/// Configure Dash Platform SDK to connect to the platform
fn setup_sdk(cfg: &Config, dump_dir: &Path) -> Sdk {
    let sdk = SdkBuilder::new(cfg.address_list())
        .with_core(
            &cfg.platform_host,
            cfg.core_port,
            &cfg.core_user,
            &cfg.core_password,
        )
        .with_dump_dir(dump_dir)
        .build()
        .expect("connect to dash platform");

    return sdk;
}

/// Generate test vectors for the fetch operation
///
/// Fetch data from the platform and save the request and response to a file.
async fn generate_fetch<T: Fetch + Send, I>(
    sdk: &mut Sdk,
    test_cases: BTreeMap<&'static str, I>,
    cfg: &Config,
    dump_dir: &Path,
) where
    I: rs_sdk::platform::Query<<T as Fetch>::Request>,
{
    for (name, query) in test_cases {
        let _object = T::fetch(sdk, query).await.expect("fetch identity");
        copy_dumps(dump_dir, name, cfg)
    }
}

/// Generate test vectors for the list operation
///
/// List data from the platform and save the request and response to a file.
async fn generate_list<T: List + Sync + Send, I>(
    sdk: &mut Sdk,
    test_cases: BTreeMap<&'static str, I>,
    cfg: &Config,
    dump_dir: &Path,
) where
    I: rs_sdk::platform::Query<<T as List>::Request>,
    Vec<T>: MockResponse
        + FromProof<
            <T as List>::Request,
            Request = <T as List>::Request,
            Response = <<T as List>::Request as TransportRequest>::Response,
        >,
{
    for (name, query) in test_cases {
        let _object = T::list(sdk, query).await.expect("fetch identity");
        copy_dumps(dump_dir, name, cfg)
    }
}

/// Copy dump of the most recent request+response to the final destination
fn copy_dumps(dump_dir: &Path, test_name: &str, cfg: &Config) {
    // retrieve dump of the most recent request and response
    let dump_src = find_newest(dump_dir, "msg-").expect("find dump file");
    let dump_dest = cfg.destination_dir.join(format!("{}.json", test_name));
    copy(dump_src, dump_dest).expect("copy dump file to final destination");

    let key_src = find_newest(dump_dir, "quorum_pubkey").expect("find quorum_pubkey file");
    let key_dest = cfg.destination_dir.join(key_src.file_name().unwrap());
    copy(key_src, key_dest).expect("copy dump file to final destination");
}

/// Find the newest file in a directory
///
/// Find the newest file dumped by the Sdk in the dump_dir.
/// It should reflect last request+response sent to the Platform.
fn find_newest(dir: &Path, prefix: &str) -> Result<PathBuf, std::io::Error> {
    if let Ok(entries) = dir.read_dir() {
        let last_file = entries
            .into_iter()
            .filter_map(|x| x.ok())
            .filter(|f| f.file_name().to_string_lossy().starts_with(prefix))
            .max_by(|a, b| {
                a.metadata()
                    .unwrap()
                    .modified()
                    .unwrap()
                    .cmp(&b.metadata().unwrap().modified().unwrap())
            })
            .ok_or(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "no file found",
            ))?
            .path();
        Ok(last_file)
    } else {
        Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "no file found",
        ))
    }
}
