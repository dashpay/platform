//! Dumping of requests and responses to disk

use crate::{mock::Key, transport::TransportRequest, DapiClient};
use std::path::PathBuf;

#[derive(serde::Serialize, serde::Deserialize)]
/// Data format of dumps created with [DapiClient::dump_dir].
pub struct DumpData<T: TransportRequest> {
    /// Request that was sent to DAPI.
    pub request: T,
    /// Response that was received from DAPI.
    pub response: T::Response,
}

impl<T: TransportRequest> DumpData<T> {
    /// Create new dump data.
    pub fn new(request: T, response: T::Response) -> Self {
        Self { request, response }
    }

    // Return request type (T) name without module prefix
    fn request_type() -> String {
        let req_type = std::any::type_name::<T>();
        req_type.split(':').last().unwrap_or(req_type).to_string()
    }
    /// Generate unique filename for this dump.
    ///
    /// Filename consists of:
    ///
    /// * [DapiClient::DUMP_FILE_PREFIX]
    /// * current timestamp
    /// * basename of the type of request, like `GetIdentityRequest`
    /// * unique identifier (hash) of the request
    pub fn filename(&self) -> Result<String, std::io::Error> {
        let now = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Nanos, true);
        let key = Key::try_new(&self.request)?;
        // get request type without underscores (which we use as a file name separator)
        let request_type = Self::request_type().replace('_', "-");

        let file = format!(
            "{}_{}_{}_{}.json",
            DapiClient::DUMP_FILE_PREFIX,
            now,
            request_type,
            key
        );

        Ok(file)
    }

    /// Load dump data from file.
    pub fn load<P: AsRef<std::path::Path>>(file: P) -> Result<Self, std::io::Error>
    where
        T: for<'de> serde::Deserialize<'de>,
        T::Response: for<'de> serde::Deserialize<'de>,
    {
        let f = std::fs::File::open(file)?;

        let data: Self = serde_json::from_reader(f).map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("unable to parse json: {}", e),
            )
        })?;

        Ok(data)
    }

    /// Save dump data to file.
    pub fn save(&self, file: &std::path::Path) -> Result<(), std::io::Error>
    where
        T: serde::Serialize,
        T::Response: serde::Serialize,
    {
        let encoded = serde_json::to_vec(self).map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("unable to serialize json: {}", e),
            )
        })?;

        std::fs::write(file, encoded)
    }
}

impl DapiClient {
    /// Prefix of dump files.
    pub const DUMP_FILE_PREFIX: &str = "msg";

    /// Define directory where dumps of all traffic will be saved.
    ///
    /// Each request and response pair will be saved to a JSON file in `dump_dir`.
    /// Data is saved as [DumpData] structure.
    /// Any errors are logged on `warn` level and ignored.
    ///
    /// Dump file name is generated by [DumpData::filename()].
    ///
    /// Useful for debugging and mocking.
    /// See also [MockDapiClient::load()](crate::mock::MockDapiClient::load()).
    pub fn dump_dir(mut self, dump_dir: Option<PathBuf>) -> Self {
        self.dump_dir = dump_dir;

        self
    }

    /// Save dump of request and response to disk.
    ///
    /// Any errors are logged on `warn` level and ignored.
    pub(crate) fn dump_request_response<R: TransportRequest>(
        request: R,
        response: R::Response,
        dump_dir: Option<PathBuf>,
    ) where
        R: serde::Serialize,
        R::Response: serde::Serialize,
    {
        let path = match dump_dir {
            Some(p) => p,
            None => return,
        };

        let data = DumpData::new(request, response);

        // Construct file name
        let filename = match data.filename() {
            Ok(f) => f,
            Err(e) => return tracing::warn!("unable to create dump file name: {}", e),
        };

        let file = path.join(filename);

        if let Err(e) = data.save(&file) {
            tracing::warn!("unable to write dump file {:?}: {}", path, e);
        }
    }
}
