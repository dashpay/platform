#![allow(unexpected_cfgs, unused_variables, dead_code)]
//! Configuration helpers for testing of rs-sdk-ffi.
//!
//! This module contains [Config] struct that can be used to configure tests.

use serde::Deserialize;
use std::path::PathBuf;
use zeroize::Zeroizing;

#[derive(Debug, Deserialize)]
/// Configuration for rs-sdk-ffi tests.
///
/// Content of this configuration is loaded from environment variables or `${CARGO_MANIFEST_DIR}/.env` file
/// when the [Config::new()] is called.
/// Variable names in the environment and `.env` file must be prefixed with [DASH_SDK_](Config::CONFIG_PREFIX)
/// and written as SCREAMING_SNAKE_CASE (e.g. `DASH_SDK_PLATFORM_HOST`).
pub struct Config {
    /// Hostname of the Dash Platform node to connect to
    #[serde(default)]
    pub platform_host: String,
    /// Port of the Dash Platform node grpc interface
    #[serde(default)]
    pub platform_port: u16,
    /// Host of the Dash Core RPC interface running on the Dash Platform node.
    /// Defaults to the same as [platform_host](Config::platform_host).
    #[serde(default)]
    #[cfg_attr(not(feature = "network-testing"), allow(unused))]
    pub core_host: Option<String>,
    /// Port of the Dash Core RPC interface running on the Dash Platform node
    #[serde(default)]
    pub core_port: u16,
    /// Username for Dash Core RPC interface
    #[serde(default)]
    pub core_user: String,
    /// Password for Dash Core RPC interface
    #[serde(default)]
    pub core_password: Zeroizing<String>,
    /// When true, use SSL for the Dash Platform node grpc interface
    #[serde(default)]
    pub platform_ssl: bool,

    /// Directory where all generated test vectors will be saved.
    #[serde(default = "Config::default_dump_dir")]
    pub dump_dir: PathBuf,

    // IDs of some objects generated by the testnet
    /// ID of existing identity.
    ///
    /// Format: Base58
    #[serde(default = "Config::default_identity_id")]
    pub existing_identity_id: String,
    /// ID of existing data contract.
    ///
    /// Format: Base58
    #[serde(default = "Config::default_data_contract_id")]
    pub existing_data_contract_id: String,
    /// Name of document type defined for [`existing_data_contract_id`](Config::existing_data_contract_id).
    #[serde(default = "Config::default_document_type_name")]
    pub existing_document_type_name: String,
    /// ID of document of the type [`existing_document_type_name`](Config::existing_document_type_name)
    /// in [`existing_data_contract_id`](Config::existing_data_contract_id).
    #[serde(default = "Config::default_document_id")]
    #[allow(unused)]
    pub existing_document_id: String,
    // Hex-encoded ProTxHash of the existing HP masternode
    #[serde(default = "Config::default_protxhash")]
    pub masternode_owner_pro_reg_tx_hash: String,
}

impl Config {
    /// Prefix of configuration options in the environment variables and `.env` file.
    pub const CONFIG_PREFIX: &'static str = "DASH_SDK_";

    /// Load configuration from operating system environment variables and `.env` file.
    ///
    /// Create new [Config] with data from environment variables and `${CARGO_MANIFEST_DIR}/tests/.env` file.
    /// Variable names in the environment and `.env` file must be converted to SCREAMING_SNAKE_CASE and
    /// prefixed with [DASH_SDK_](Config::CONFIG_PREFIX).
    pub fn new() -> Self {
        // load config from .env file, ignore errors
        let path: String = env!("CARGO_MANIFEST_DIR").to_owned() + "/tests/.env";
        if let Err(err) = dotenvy::from_path(&path) {
            eprintln!("Failed to load config file {}: {:?}", path, err);
        }

        let config: Self = envy::prefixed(Self::CONFIG_PREFIX)
            .from_env()
            .expect("configuration error");

        if config.is_empty() {
            eprintln!("Warning: some config fields are empty: {:?}", config);
            // Do not panic by default. Tests that require network should
            // explicitly check configuration or be marked as ignored.
        }

        config
    }

    /// Check if credentials of the config are empty.
    pub fn is_empty(&self) -> bool {
        self.core_user.is_empty()
            || self.core_password.is_empty()
            || self.platform_host.is_empty()
            || self.platform_port == 0
            || self.core_port == 0
    }

    fn default_identity_id() -> String {
        // Using a well-known test identity ID
        "4EfA9Jrvv3nnCFdSf7fad59851iiTRZ6Wcu6YVJ4iSeF".to_string()
    }

    fn default_data_contract_id() -> String {
        // DPNS contract ID
        "GWRSAVFMjXx8HpQFaNJMqBV7MBgMK4br5UESsB4S31Ec".to_string()
    }

    fn default_document_type_name() -> String {
        "domain".to_string()
    }

    fn default_document_id() -> String {
        // dash TLD document ID
        "GWRSAVFMjXx8HpQFaNJMqBV7MBgMK4br5UESsB4S31Ec".to_string()
    }

    fn default_dump_dir() -> PathBuf {
        // Use the rs-sdk test vectors directory so we can reuse the test data
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("rs-sdk")
            .join("tests")
            .join("vectors")
    }

    /// Existing masternode proTxHash. Must be updated every time test vectors are regenerated.
    fn default_protxhash() -> String {
        String::from("069dcb6e829988af0edb245f30d3b1297a47081854a78c3cdea9fddb8fbd07eb")
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}
// per-file allows are set at the top
