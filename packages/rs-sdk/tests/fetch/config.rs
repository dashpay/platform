//! Configuration helpers for mocking of dash-platform-sdk.
//!
//! This module contains [Config] struct that can be used to configure dash-platform-sdk.
//! It's mainly used for testing.

use crate::fetch::generated_data::*;
use dpp::{
    dashcore::{hashes::Hash, ProTxHash},
    prelude::Identifier,
};
use rs_dapi_client::{Address, AddressList};
use serde::Deserialize;
use std::path::PathBuf;
use zeroize::Zeroizing;

#[derive(Debug, Deserialize)]
/// Configuration for dash-platform-sdk.
///
/// Content of this configuration is loaded from environment variables or `${CARGO_MANIFEST_DIR}/.env` file
/// when the [Config::new()] is called.
/// Variable names in the enviroment and `.env` file must be prefixed with [DASH_SDK_](Config::CONFIG_PREFIX)
/// and written as SCREAMING_SNAKE_CASE (e.g. `DASH_SDK_PLATFORM_HOST`).
pub struct Config {
    /// Hostname of the Dash Platform node to connect to
    #[serde(default)]
    pub platform_host: String,
    /// Port of the Dash Platform node grpc interface
    #[serde(default)]
    pub platform_port: u16,
    /// Host of the Dash Core RPC interface running on the Dash Platform node.
    /// Defaults to the same as [platform_host](Config::platform_host).
    #[serde(default)]
    #[cfg_attr(not(feature = "network-testing"), allow(unused))]
    pub core_host: Option<String>,
    /// Port of the Dash Core RPC interface running on the Dash Platform node
    #[serde(default)]
    pub core_port: u16,
    /// Username for Dash Core RPC interface
    #[serde(default)]
    pub core_user: String,
    /// Password for Dash Core RPC interface
    #[serde(default)]
    pub core_password: Zeroizing<String>,
    /// When true, use SSL for the Dash Platform node grpc interface
    #[serde(default)]
    pub platform_ssl: bool,

    /// When platform_ssl is true, use the PEM-encoded CA certificate from provided absolute path to verify the server certificate.
    #[serde(default)]
    pub platform_ca_cert_path: Option<PathBuf>,

    /// Directory where all generated test vectors will be saved.
    ///
    /// See [SdkBuilder::with_dump_dir()](crate::SdkBuilder::with_dump_dir()) for more details.
    #[serde(default = "Config::default_dump_dir")]
    pub dump_dir: PathBuf,

    // IDs of some objects generated by the testnet
    /// ID of existing identity.
    ///
    /// Format: Base58
    #[serde(default = "Config::default_identity_id")]
    pub existing_identity_id: Identifier,
    /// ID of existing data contract.
    ///
    /// Format: Base58
    #[serde(default = "Config::default_data_contract_id")]
    pub existing_data_contract_id: Identifier,
    /// Name of document type defined for [`existing_data_contract_id`](Config::existing_data_contract_id).
    #[serde(default = "Config::default_document_type_name")]
    pub existing_document_type_name: String,
    /// ID of document of the type [`existing_document_type_name`](Config::existing_document_type_name)
    /// in [`existing_data_contract_id`](Config::existing_data_contract_id).
    #[serde(default = "Config::default_document_id")]
    #[allow(unused)]
    pub existing_document_id: Identifier,
    // Hex-encoded ProTxHash of the existing HP masternode
    #[serde(default = "Config::default_protxhash")]
    pub masternode_owner_pro_reg_tx_hash: String,
}

impl Config {
    /// Prefix of configuration options in the environment variables and `.env` file.
    pub const CONFIG_PREFIX: &'static str = "DASH_SDK_";
    /// Load configuration from operating system environment variables and `.env` file.
    ///
    /// Create new [Config] with data from environment variables and `${CARGO_MANIFEST_DIR}/tests/.env` file.
    /// Variable names in the environment and `.env` file must be converted to SCREAMING_SNAKE_CASE and
    /// prefixed with [DASH_SDK_](Config::CONFIG_PREFIX).
    pub fn new() -> Self {
        // load config from .env file, ignore errors

        let path: String = env!("CARGO_MANIFEST_DIR").to_owned() + "/tests/.env";
        if let Err(err) = dotenvy::from_path(&path) {
            tracing::warn!(path, ?err, "failed to load config file");
        }

        let config: Self = envy::prefixed(Self::CONFIG_PREFIX)
            .from_env()
            .expect("configuration error");

        if config.is_empty() {
            tracing::warn!(path, ?config, "some config fields are empty");
            #[cfg(not(feature = "offline-testing"))]
            panic!("invalid configuration")
        }

        config
    }

    /// Check if credentials of the config are empty.
    ///
    /// Checks if fields [platform_host](Config::platform_host), [platform_port](Config::platform_port),
    /// [core_port](Config::core_port), [core_user](Config::core_user) and [core_password](Config::core_password)
    /// are not empty.
    ///
    /// Other fields are ignored.
    pub fn is_empty(&self) -> bool {
        self.core_user.is_empty()
            || self.core_password.is_empty()
            || self.platform_host.is_empty()
            || self.platform_port == 0
            || self.core_port == 0
    }

    #[allow(unused)]
    /// Create list of Platform addresses from the configuration
    pub fn address_list(&self) -> AddressList {
        let scheme = match self.platform_ssl {
            true => "https",
            false => "http",
        };

        let address: Address =
            format!("{}://{}:{}", scheme, self.platform_host, self.platform_port)
                .parse()
                .expect("valid address");

        AddressList::from_iter([address])
    }

    /// Create new SDK instance
    ///
    /// Depending on the feature flags, it will connect to the configured platform node or mock API.
    ///
    /// ## Feature flags
    ///
    /// * `offline-testing` is not set - connect to Platform and generate
    ///   new test vectors during execution
    /// * `offline-testing` is set - use mock implementation and
    ///   load existing test vectors from disk
    ///
    /// ## Arguments
    ///
    /// * namespace - namespace to use when storing mock expectations; this is used to separate
    ///   expectations from different tests.
    ///
    /// When empty string is provided, expectations are stored in the root of the dump directory.
    pub async fn setup_api(&self, namespace: &str) -> dash_sdk::Sdk {
        let dump_dir = match namespace.is_empty() {
            true => self.dump_dir.clone(),
            false => {
                // looks like spaces are not replaced by sanitize_filename, and we don't want them as they are confusing
                let namespace = namespace.replace(' ', "_");
                self.dump_dir.join(sanitize_filename::sanitize(namespace))
            }
        };

        if dump_dir.is_relative() {
            panic!(
                "dump dir must be absolute path to avoid mistakes, got: {}",
                dump_dir.display()
            );
        }

        if dump_dir.as_os_str().eq("/") {
            panic!("cannot use namespace with root dump dir");
        }

        // offline testing takes precedence over network testing
        #[cfg(all(feature = "network-testing", not(feature = "offline-testing")))]
        let sdk = {
            let core_host = self.core_host.as_ref().unwrap_or(&self.platform_host);
            // Dump all traffic to disk
            let mut builder = dash_sdk::SdkBuilder::new(self.address_list()).with_core(
                core_host,
                self.core_port,
                &self.core_user,
                &self.core_password,
            );
            if let Some(cert_file) = &self.platform_ca_cert_path {
                builder = builder
                    .with_ca_certificate_file(cert_file)
                    .expect("load CA cert");
            }
            #[cfg(feature = "generate-test-vectors")]
            let builder = {
                // When we use namespaces, clean up the namespaced dump dir before starting
                // to avoid mixing expectations from different test runs
                if !namespace.is_empty() {
                    if let Err(err) = std::fs::remove_dir_all(&dump_dir) {
                        tracing::warn!(?err, ?dump_dir, "failed to remove dump dir");
                    }
                    std::fs::create_dir_all(&dump_dir)
                        .expect(format!("create dump dir {}", dump_dir.display()).as_str());
                    // ensure dump dir is committed to git
                    let gitkeep = dump_dir.join(".gitkeep");
                    std::fs::write(&gitkeep, "")
                        .expect(format!("create {} file", gitkeep.display()).as_str());
                }

                builder.with_dump_dir(&dump_dir)
            };

            builder.build().expect("cannot initialize api")
        };

        // offline testing takes precedence over network testing
        #[cfg(feature = "offline-testing")]
        let sdk = {
            dash_sdk::SdkBuilder::new_mock()
                .with_dump_dir(&dump_dir)
                .build()
                .expect("initialize api")
        };

        sdk
    }

    fn default_identity_id() -> Identifier {
        IDENTITY_ID_1
    }

    fn default_data_contract_id() -> Identifier {
        [
            230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29,
            113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85,
        ]
        .into()
    }

    fn default_document_type_name() -> String {
        "domain".to_string()
    }
    fn default_document_id() -> Identifier {
        DPNS_DASH_TLD_DOCUMENT_ID.into()
    }

    fn default_dump_dir() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("vectors")
    }

    /// Existing masternode proTxHash. Must be updated every time test vectors are regenerated.
    ///
    /// See documentation of [contested_resource_identity_votes_ok](super::contested_resource_identity_votes::contested_resource_identity_votes_ok).
    fn default_protxhash() -> String {
        String::from("069dcb6e829988af0edb245f30d3b1297a47081854a78c3cdea9fddb8fbd07eb")
    }

    /// Return ProTxHash of an existing evo node, or None if not set
    pub fn existing_protxhash(&self) -> Result<ProTxHash, String> {
        hex::decode(&self.masternode_owner_pro_reg_tx_hash)
            .map_err(|e| e.to_string())
            .and_then(|b| ProTxHash::from_slice(&b).map_err(|e| e.to_string()))
            .map_err(|e| {
                format!(
                    "Invalid {}MASTERNODE_OWNER_PRO_REG_TX_HASH {}: {}",
                    Self::CONFIG_PREFIX,
                    self.masternode_owner_pro_reg_tx_hash,
                    e
                )
            })
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}
