use dpp::{data_contract::DataContractFactory, prelude::Identifier};
use rs_dapi_client::AddressList;
use serde::Deserialize;
use std::{path::PathBuf, str::FromStr};

/// Existing identity ID, created as part of platform test suite run
pub const IDENTITY_ID_BYTES: [u8; 32] = [
    65, 63, 57, 243, 204, 9, 106, 71, 187, 2, 94, 221, 190, 127, 141, 114, 137, 209, 243, 50, 60,
    215, 90, 101, 229, 15, 115, 5, 44, 117, 182, 217,
];

#[derive(Debug, Deserialize)]
pub struct Config {
    pub platform_host: String,
    pub platform_port: u16,
    pub core_port: u16,
    pub core_user: String,
    pub core_password: String,

    // IDs of some objects generated by the testnet
    pub existing_identity_id: Identifier,
    pub existing_data_contract_id: Identifier,
    pub existing_document_type_name: String,

    pub existing_document_id: Identifier,

    // Where all files will be saved
    #[serde(default = "Config::default_destination_dir")]
    pub destination_dir: PathBuf,
}

impl Config {
    /// Load config from enviroment variables
    pub fn new() -> Self {
        // load config from .env file, ignore errors
        let path = env!("CARGO_MANIFEST_DIR").to_owned() + "/.env";
        dotenvy::from_path(&path).expect("failed to load config file");

        // println!("Load .env file: {:?}", dotenvy::dotenv());
        envy::from_env().expect("configuration error")
    }
    #[allow(unused)]
    pub fn address_list(&self) -> AddressList {
        let address: String = format!("http://{}:{}", self.platform_host, self.platform_port);

        AddressList::from_iter(vec![http::Uri::from_str(&address).expect("valid uri")])
    }

    fn default_destination_dir() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("vectors")
    }
}

/// Create new SDK instance
///
/// Depending on the feature flags, it will connect to the platform or mock API
///
/// ## Feature flags
///
/// * `online-testing` is set - connect to the platform and generate
/// new test vectors during execution
/// * `online-testing` is not set - use mock implementation and
/// load existing test vectors from disk
pub async fn setup_api() -> rs_sdk::Sdk {
    let config = Config::new();

    #[cfg(feature = "online-testing")]
    // Dump all traffic to disk
    let sdk = rs_sdk::SdkBuilder::new(config.address_list())
        .with_core(
            &config.platform_host,
            config.core_port,
            &config.core_user,
            &config.core_password,
        )
        .with_dump_dir(&config.destination_dir)
        .build()
        .expect("cannot initialize api");

    #[cfg(not(feature = "online-testing"))]
    let mut sdk = rs_sdk::SdkBuilder::new_mock()
        .build()
        .expect("initialize api");
    #[cfg(not(feature = "online-testing"))]
    sdk.mock()
        .quorum_info_dir(&config.destination_dir)
        .load_expectations(config.destination_dir)
        .await
        .expect("load expectations");

    sdk
}

/// Create a mock document type for testing of mock API
pub fn mock_document_type() -> dpp::data_contract::document_type::DocumentType {
    use dpp::{
        data_contract::document_type::DocumentType,
        platform_value::platform_value,
        version::{PlatformVersion, PlatformVersionCurrentVersion},
    };

    let platform_version = PlatformVersion::get_current().unwrap();

    let schema = platform_value!({
        "type": "object",
        "properties": {
            "a": {
                "type": "string",
                "maxLength": 10,
            }
        },
        "additionalProperties": false,
    });

    DocumentType::try_from_schema(
        Identifier::random(),
        "document_type_name",
        schema,
        None,
        false,
        false,
        true,
        platform_version,
    )
    .expect("expected to create a document type")
}

/// Create a mock data contract for testing of mock API
pub fn mock_data_contract(
    document_type: Option<&dpp::data_contract::document_type::DocumentType>,
) -> dpp::prelude::DataContract {
    use dpp::{
        data_contract::document_type::accessors::DocumentTypeV0Getters,
        platform_value::{platform_value, Value},
        version::PlatformVersion,
    };
    use std::collections::BTreeMap;

    let platform_version = PlatformVersion::latest();
    let protocol_version = platform_version.protocol_version;

    let owner_id = Identifier::from_bytes(&IDENTITY_ID_BYTES).unwrap();

    let mut document_types: BTreeMap<String, Value> = BTreeMap::new();

    if let Some(doc) = document_type {
        let schema = doc.schema();
        document_types.insert(doc.name().to_string(), schema.clone());
    }

    let data_contract = DataContractFactory::new(protocol_version, None)
        .unwrap()
        .create(owner_id, platform_value!(document_types), None, None)
        .expect("create data contract")
        .data_contract_owned();

    data_contract
}

/// Enable logging for tests
pub fn setup_logs() {
    tracing_subscriber::fmt::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::new(
            "info,rs_sdk=trace,h2=info",
        ))
        .pretty()
        .with_ansi(true)
        .with_writer(std::io::stdout)
        .try_init()
        .ok();
}
